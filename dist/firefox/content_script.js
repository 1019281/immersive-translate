var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// <define:process.env>
var define_process_env_default = { BUILD_TIME: "2023-02-10T09:14:58.155Z", VERSION: "0.2.56", PROD: "0", REDIRECT_URL: "http://localhost:8000/auth-done/", IMMERSIVE_TRANSLATE_INJECTED_CSS: `.immersive-translate-target-translation-pre-whitespace {
  white-space: pre-wrap !important;
}

.immersive-translate-pdf-target-container {
  position: absolute;
  background-color: #fff;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica,
    sans-serif;
  top: 0;
  width: 600px;
  height: 100%;
  z-index: 2;
  line-height: 1.3;
  font-size: 16px;
}
.immersive-translate-pdf-target-container
  span.immersive-translate-target-wrapper {
  color: rgb(0, 0, 0);
  white-space: normal;
  position: absolute;
}

.immersive-translate-pdf-target-container
  span.immersive-translate-target-wrapper
  span {
  color: inherit;
  white-space: inherit;
  position: unset;
}

.immersive-translate-target-translation-block-wrapper {
  margin: 8px 0 !important;
  display: block;
}

.immersive-translate-target-translation-pdf-block-wrapper {
  margin: 0 !important;
  display: block;
}

.immersive-translate-target-translation-inline-wrapper {
}
.immersive-translate-target-translation-theme-underline-inner {
  border-bottom: 1px solid #72ece9 !important;
}

.immersive-translate-target-translation-theme-nativeUnderline-inner {
  text-decoration: underline #72ece9 !important;
}

.immersive-translate-target-translation-block-wrapper-theme-dashedBorder {
  border: 1px dashed rgb(148 163 184) !important;
  padding: 6px;
  margin-top: 2px;
  display: block;
}

.immersive-translate-target-translation-inline-wrapper-theme-dashedBorder {
  border: 1px dashed rgb(148 163 184) !important;
  padding: 2px;
}

.immersive-translate-target-translation-theme-nativeDashed-inner {
  text-decoration: dashed underline #72ece9 !important;
}

.immersive-translate-target-translation-theme-thinDashed-inner {
  border-bottom: 1px dashed #ff374f !important;
}

.immersive-translate-target-translation-theme-dotted-inner {
  background-repeat: repeat-x;
  background-image: linear-gradient(
    to right,
    currentColor 10%,
    rgba(255, 255, 255, 0) 0%
  );
  background-position: bottom;
  background-size: 5px 1px;
  background-repeat: repeat-x;
  padding-bottom: 3px;
}
.immersive-translate-target-translation-theme-nativeDotted-inner {
  text-decoration: dotted underline #72ece9 !important;
}

.immersive-translate-target-translation-theme-wavy-inner {
  text-decoration: wavy underline #59c1bd !important;
}

.immersive-translate-target-translation-theme-dashed-inner {
  background-repeat: repeat-x !important;
  background: linear-gradient(
      to right,
      #59c1bd 0%,
      #59c1bd 50%,
      transparent 50%,
      transparent 100%
    )
    repeat-x left bottom;
  background-size: 8px 2px;
  padding-bottom: 2px;
}

.immersive-translate-target-translation-block-wrapper-theme-dividingLine::before {
  content: "";
  display: block;
  max-width: 80px;
  width: 10%;
  border-top: 1px dashed currentColor;
  padding-top: 0.5em;
}

.immersive-translate-target-translation-theme-highlight-inner {
  background: rgb(255, 255, 0);
  box-decoration-break: clone;
  -webkit-box-decoration-break: clone;
}
.immersive-translate-target-translation-block-wrapper-theme-marker {
  line-height: 1.5em;
}

.immersive-translate-target-translation-theme-marker-inner {
  /* TODO: add more texture */
  background: linear-gradient(
    to right,
    rgba(255, 225, 0, 0.1),
    rgba(251, 218, 65, 0.9) 3%,
    rgba(252, 210, 23, 0.9) 35%,
    rgba(251, 218, 65, 0.9) 70%,
    rgba(251, 218, 65, 0.8) 95%,
    rgba(255, 225, 0, 0.3)
  );
  box-decoration-break: clone;
  -webkit-box-decoration-break: clone;
}

.immersive-translate-target-translation-theme-weakening {
  opacity: 0.4 !important;
}

.immersive-translate-target-translation-theme-italic {
  font-style: italic !important;
}

.immersive-translate-target-translation-theme-bold {
  font-weight: bold !important;
}

.immersive-translate-target-translation-block-wrapper-theme-paper {
  margin: 8px 0;
  box-shadow: rgba(0, 0, 0, 0.24) 0px 3px 8px;
  padding: 16px 32px;
  display: block;
}

.immersive-translate-target-translation-block-wrapper-theme-blockquote {
  border-left: 4px solid #cc3355 !important;
  padding-left: 12px !important;
  margin-top: 4px;
  margin-bottom: 4px;
  padding-top: 4px;
  padding-bottom: 4px;
  display: block;
}

.immersive-translate-target-translation-theme-mask-inner {
  filter: blur(5px) !important;
  transition: filter 0.3s ease !important;
  border-radius: 10px;
}

[data-immersive-translate-root-translation-theme="none"]
  .immersive-translate-target-translation-theme-mask-inner {
  filter: none !important;
}
[data-immersive-translate-root-translation-theme="mask"]
  .immersive-translate-target-inner {
  filter: blur(5px) !important;
  transition: filter 0.3s ease !important;
  border-radius: 10px;
}

.immersive-translate-target-translation-theme-mask-inner:hover {
  filter: none !important;
}

[data-immersive-translate-root-translation-theme="mask"]
  .immersive-translate-target-inner:hover {
  filter: none !important;
}

/* vertical css , please remain it in the last one. */
.immersive-translate-target-translation-vertical-block-wrapper {
  margin: 0px 8px !important;
}

.immersive-translate-text {
  font-size: 15px !important;
}

.immersive-translate-error {
  color: red;
}
.immersive-translate-clickable-button {
  align-items: normal;
  background-color: rgba(0, 0, 0, 0);
  border-color: rgb(0, 0, 238);
  border-style: none;
  box-sizing: content-box;
  color: rgb(0, 0, 238);
  cursor: pointer;
  display: inline;
  font: inherit;
  height: auto;
  padding: 0;
  perspective-origin: 0 0;
  text-align: start;
  transform-origin: 0 0;
  width: auto;
  -moz-appearance: none;
  appearance: none;
  -webkit-logical-height: 1em; /* Chrome ignores auto, so we have to use this hack to set the correct height  */
  -webkit-logical-width: auto; /* Chrome ignores auto, but here for completeness */
}

.immersive-translate-loading-spinner {
  vertical-align: middle !important;
  width: 10px !important;
  height: 10px !important;
  display: inline-block !important;
  margin: 0 4px !important;
  border: 2px rgba(0, 0, 0, 0.25) solid !important;
  border-top: 2px rgba(0, 0, 0, 1) solid !important;
  border-radius: 50% !important;
  padding: 0 !important;
  -webkit-animation: immersive-translate-loading-animation 0.6s infinite linear !important;
  animation: immersive-translate-loading-animation 0.6s infinite linear !important;
}

.immersive-translate-loading-text:before {
  content: "...";
}

.immersive-translate-loading-none {
}
/* dark mode for loading */

@media only screen and (prefers-color-scheme: dark) {
  .immersive-translate-loading {
    border: 2px rgba(255, 255, 255, 0.25) solid !important;
    border-top: 2px rgba(255, 255, 255, 1) solid !important;
  }

  .immersive-translate-target-translation-theme-marker-inner {
    background: linear-gradient(
      to right,
      rgba(255, 225, 0, 0.1),
      rgba(102, 99, 78, 0.9) 3%,
      rgba(102, 99, 78, 0.8) 97%,
      rgba(255, 225, 0, 0.3)
    );
  }
}

.immersive-translate-tooltip {
  position: relative;
  display: inline-block;
  border-bottom: 1px dashed #000; /* little indicater to indicate it's hoverable */
}
.immersive-translate-tooltip:before {
  content: attr(data-immersive-translate-tooltip-text); /* here's the magic */
  position: absolute;
  z-index: 100000000000;

  /* vertically center */
  top: 50%;
  transform: translateY(-50%);

  /* move to right */
  left: 100%;
  margin-left: 15px; /* and add a small left margin */

  /* basic styles */
  width: max-content;
  max-width: 250px;
  word-wrap: break-word;
  white-space: pre-line;
  padding: 10px;
  border-radius: 10px;
  background: #000;
  color: #fff;
  text-align: center;

  display: none; /* hide by default */
}
.immersive-translate-tooltip:hover:before {
  display: block;
}

@-webkit-keyframes immersive-translate-loading-animation {
  from {
    -webkit-transform: rotate(0deg);
  }
  to {
    -webkit-transform: rotate(359deg);
  }
}
@keyframes immersive-translate-loading-animation {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(359deg);
  }
}
`, IMMERSIVE_TRANSLATE_PICO_CSS: `@charset "UTF-8";
/*!
 * Pico.css v1.5.6 (https://picocss.com)
 * Copyright 2019-2022 - Licensed under MIT
 */
/**
 * Theme: default
 */
#mount {
  --font-family: system-ui, -apple-system, "Segoe UI", "Roboto", "Ubuntu",
    "Cantarell", "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji",
    "Segoe UI Symbol", "Noto Color Emoji";
  --line-height: 1.5;
  --font-weight: 400;
  --font-size: 16px;
  --border-radius: 0.25rem;
  --border-width: 1px;
  --outline-width: 3px;
  --spacing: 1rem;
  --typography-spacing-vertical: 1.5rem;
  --block-spacing-vertical: calc(var(--spacing) * 2);
  --block-spacing-horizontal: var(--spacing);
  --grid-spacing-vertical: 0;
  --grid-spacing-horizontal: var(--spacing);
  --form-element-spacing-vertical: 0.75rem;
  --form-element-spacing-horizontal: 1rem;
  --nav-element-spacing-vertical: 1rem;
  --nav-element-spacing-horizontal: 0.5rem;
  --nav-link-spacing-vertical: 0.5rem;
  --nav-link-spacing-horizontal: 0.5rem;
  --form-label-font-weight: var(--font-weight);
  --transition: 0.2s ease-in-out;
  --modal-overlay-backdrop-filter: blur(0.25rem);
}
@media (min-width: 576px) {
  #mount {
    --font-size: 17px;
  }
}
@media (min-width: 768px) {
  #mount {
    --font-size: 18px;
  }
}
@media (min-width: 992px) {
  #mount {
    --font-size: 19px;
  }
}
@media (min-width: 1200px) {
  #mount {
    --font-size: 20px;
  }
}

@media (min-width: 576px) {
  #mount > header,
  #mount > main,
  #mount > footer,
  section {
    --block-spacing-vertical: calc(var(--spacing) * 2.5);
  }
}
@media (min-width: 768px) {
  #mount > header,
  #mount > main,
  #mount > footer,
  section {
    --block-spacing-vertical: calc(var(--spacing) * 3);
  }
}
@media (min-width: 992px) {
  #mount > header,
  #mount > main,
  #mount > footer,
  section {
    --block-spacing-vertical: calc(var(--spacing) * 3.5);
  }
}
@media (min-width: 1200px) {
  #mount > header,
  #mount > main,
  #mount > footer,
  section {
    --block-spacing-vertical: calc(var(--spacing) * 4);
  }
}

@media (min-width: 576px) {
  article {
    --block-spacing-horizontal: calc(var(--spacing) * 1.25);
  }
}
@media (min-width: 768px) {
  article {
    --block-spacing-horizontal: calc(var(--spacing) * 1.5);
  }
}
@media (min-width: 992px) {
  article {
    --block-spacing-horizontal: calc(var(--spacing) * 1.75);
  }
}
@media (min-width: 1200px) {
  article {
    --block-spacing-horizontal: calc(var(--spacing) * 2);
  }
}

dialog > article {
  --block-spacing-vertical: calc(var(--spacing) * 2);
  --block-spacing-horizontal: var(--spacing);
}
@media (min-width: 576px) {
  dialog > article {
    --block-spacing-vertical: calc(var(--spacing) * 2.5);
    --block-spacing-horizontal: calc(var(--spacing) * 1.25);
  }
}
@media (min-width: 768px) {
  dialog > article {
    --block-spacing-vertical: calc(var(--spacing) * 3);
    --block-spacing-horizontal: calc(var(--spacing) * 1.5);
  }
}

a {
  --text-decoration: none;
}
a.secondary,
a.contrast {
  --text-decoration: underline;
}

small {
  --font-size: 0.875em;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  --font-weight: 700;
}

h1 {
  --font-size: 2rem;
  --typography-spacing-vertical: 3rem;
}

h2 {
  --font-size: 1.75rem;
  --typography-spacing-vertical: 2.625rem;
}

h3 {
  --font-size: 1.5rem;
  --typography-spacing-vertical: 2.25rem;
}

h4 {
  --font-size: 1.25rem;
  --typography-spacing-vertical: 1.874rem;
}

h5 {
  --font-size: 1.125rem;
  --typography-spacing-vertical: 1.6875rem;
}

[type="checkbox"],
[type="radio"] {
  --border-width: 2px;
}

[type="checkbox"][role="switch"] {
  --border-width: 3px;
}

thead th,
thead td,
tfoot th,
tfoot td {
  --border-width: 3px;
}

:not(thead, tfoot) > * > td {
  --font-size: 0.875em;
}

pre,
code,
kbd,
samp {
  --font-family: "Menlo", "Consolas", "Roboto Mono", "Ubuntu Monospace",
    "Noto Mono", "Oxygen Mono", "Liberation Mono", monospace,
    "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}

kbd {
  --font-weight: bolder;
}

[data-theme="light"],
#mount:not([data-theme="dark"]) {
  --background-color: #fff;
  --color: hsl(205deg, 20%, 32%);
  --h1-color: hsl(205deg, 30%, 15%);
  --h2-color: #24333e;
  --h3-color: hsl(205deg, 25%, 23%);
  --h4-color: #374956;
  --h5-color: hsl(205deg, 20%, 32%);
  --h6-color: #4d606d;
  --muted-color: hsl(205deg, 10%, 50%);
  --muted-border-color: hsl(205deg, 20%, 94%);
  --primary: hsl(195deg, 85%, 41%);
  --primary-hover: hsl(195deg, 90%, 32%);
  --primary-focus: rgba(16, 149, 193, 0.125);
  --primary-inverse: #fff;
  --secondary: hsl(205deg, 15%, 41%);
  --secondary-hover: hsl(205deg, 20%, 32%);
  --secondary-focus: rgba(89, 107, 120, 0.125);
  --secondary-inverse: #fff;
  --contrast: hsl(205deg, 30%, 15%);
  --contrast-hover: #000;
  --contrast-focus: rgba(89, 107, 120, 0.125);
  --contrast-inverse: #fff;
  --mark-background-color: #fff2ca;
  --mark-color: #543a26;
  --ins-color: #388e3c;
  --del-color: #c62828;
  --blockquote-border-color: var(--muted-border-color);
  --blockquote-footer-color: var(--muted-color);
  --button-box-shadow: 0 0 0 rgba(0, 0, 0, 0);
  --button-hover-box-shadow: 0 0 0 rgba(0, 0, 0, 0);
  --form-element-background-color: transparent;
  --form-element-border-color: hsl(205deg, 14%, 68%);
  --form-element-color: var(--color);
  --form-element-placeholder-color: var(--muted-color);
  --form-element-active-background-color: transparent;
  --form-element-active-border-color: var(--primary);
  --form-element-focus-color: var(--primary-focus);
  --form-element-disabled-background-color: hsl(205deg, 18%, 86%);
  --form-element-disabled-border-color: hsl(205deg, 14%, 68%);
  --form-element-disabled-opacity: 0.5;
  --form-element-invalid-border-color: #c62828;
  --form-element-invalid-active-border-color: #d32f2f;
  --form-element-invalid-focus-color: rgba(211, 47, 47, 0.125);
  --form-element-valid-border-color: #388e3c;
  --form-element-valid-active-border-color: #43a047;
  --form-element-valid-focus-color: rgba(67, 160, 71, 0.125);
  --switch-background-color: hsl(205deg, 16%, 77%);
  --switch-color: var(--primary-inverse);
  --switch-checked-background-color: var(--primary);
  --range-border-color: hsl(205deg, 18%, 86%);
  --range-active-border-color: hsl(205deg, 16%, 77%);
  --range-thumb-border-color: var(--background-color);
  --range-thumb-color: var(--secondary);
  --range-thumb-hover-color: var(--secondary-hover);
  --range-thumb-active-color: var(--primary);
  --table-border-color: var(--muted-border-color);
  --table-row-stripped-background-color: #f6f8f9;
  --code-background-color: hsl(205deg, 20%, 94%);
  --code-color: var(--muted-color);
  --code-kbd-background-color: var(--contrast);
  --code-kbd-color: var(--contrast-inverse);
  --code-tag-color: hsl(330deg, 40%, 50%);
  --code-property-color: hsl(185deg, 40%, 40%);
  --code-value-color: hsl(40deg, 20%, 50%);
  --code-comment-color: hsl(205deg, 14%, 68%);
  --accordion-border-color: var(--muted-border-color);
  --accordion-close-summary-color: var(--color);
  --accordion-open-summary-color: var(--muted-color);
  --card-background-color: var(--background-color);
  --card-border-color: var(--muted-border-color);
  --card-box-shadow: 0.0145rem 0.029rem 0.174rem rgba(27, 40, 50, 0.01698),
    0.0335rem 0.067rem 0.402rem rgba(27, 40, 50, 0.024),
    0.0625rem 0.125rem 0.75rem rgba(27, 40, 50, 0.03),
    0.1125rem 0.225rem 1.35rem rgba(27, 40, 50, 0.036),
    0.2085rem 0.417rem 2.502rem rgba(27, 40, 50, 0.04302),
    0.5rem 1rem 6rem rgba(27, 40, 50, 0.06),
    0 0 0 0.0625rem rgba(27, 40, 50, 0.015);
  --card-sectionning-background-color: #fbfbfc;
  --dropdown-background-color: #fbfbfc;
  --dropdown-border-color: #e1e6eb;
  --dropdown-box-shadow: var(--card-box-shadow);
  --dropdown-color: var(--color);
  --dropdown-hover-background-color: hsl(205deg, 20%, 94%);
  --modal-overlay-background-color: rgba(213, 220, 226, 0.7);
  --progress-background-color: hsl(205deg, 18%, 86%);
  --progress-color: var(--primary);
  --loading-spinner-opacity: 0.5;
  --tooltip-background-color: var(--contrast);
  --tooltip-color: var(--contrast-inverse);
  --icon-checkbox: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(255, 255, 255)' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20 6 9 17 4 12'%3E%3C/polyline%3E%3C/svg%3E");
  --icon-chevron: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(65, 84, 98)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
  --icon-chevron-button: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(255, 255, 255)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
  --icon-chevron-button-inverse: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(255, 255, 255)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
  --icon-close: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(115, 130, 140)' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'%3E%3Cline x1='18' y1='6' x2='6' y2='18'%3E%3C/line%3E%3Cline x1='6' y1='6' x2='18' y2='18'%3E%3C/line%3E%3C/svg%3E");
  --icon-date: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(65, 84, 98)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect x='3' y='4' width='18' height='18' rx='2' ry='2'%3E%3C/rect%3E%3Cline x1='16' y1='2' x2='16' y2='6'%3E%3C/line%3E%3Cline x1='8' y1='2' x2='8' y2='6'%3E%3C/line%3E%3Cline x1='3' y1='10' x2='21' y2='10'%3E%3C/line%3E%3C/svg%3E");
  --icon-invalid: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(198, 40, 40)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10'%3E%3C/circle%3E%3Cline x1='12' y1='8' x2='12' y2='12'%3E%3C/line%3E%3Cline x1='12' y1='16' x2='12.01' y2='16'%3E%3C/line%3E%3C/svg%3E");
  --icon-minus: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(255, 255, 255)' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'%3E%3Cline x1='5' y1='12' x2='19' y2='12'%3E%3C/line%3E%3C/svg%3E");
  --icon-search: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(65, 84, 98)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='11' cy='11' r='8'%3E%3C/circle%3E%3Cline x1='21' y1='21' x2='16.65' y2='16.65'%3E%3C/line%3E%3C/svg%3E");
  --icon-time: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(65, 84, 98)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10'%3E%3C/circle%3E%3Cpolyline points='12 6 12 12 16 14'%3E%3C/polyline%3E%3C/svg%3E");
  --icon-valid: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(56, 142, 60)' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20 6 9 17 4 12'%3E%3C/polyline%3E%3C/svg%3E");
  color-scheme: light;
}

@media only screen and (prefers-color-scheme: dark) {
  #mount:not([data-theme="light"]) {
    --background-color: #11191f;
    --color: hsl(205deg, 16%, 77%);
    --h1-color: hsl(205deg, 20%, 94%);
    --h2-color: #e1e6eb;
    --h3-color: hsl(205deg, 18%, 86%);
    --h4-color: #c8d1d8;
    --h5-color: hsl(205deg, 16%, 77%);
    --h6-color: #afbbc4;
    --muted-color: hsl(205deg, 10%, 50%);
    --muted-border-color: #1f2d38;
    --primary: hsl(195deg, 85%, 41%);
    --primary-hover: hsl(195deg, 80%, 50%);
    --primary-focus: rgba(16, 149, 193, 0.25);
    --primary-inverse: #fff;
    --secondary: hsl(205deg, 15%, 41%);
    --secondary-hover: hsl(205deg, 10%, 50%);
    --secondary-focus: rgba(115, 130, 140, 0.25);
    --secondary-inverse: #fff;
    --contrast: hsl(205deg, 20%, 94%);
    --contrast-hover: #fff;
    --contrast-focus: rgba(115, 130, 140, 0.25);
    --contrast-inverse: #000;
    --mark-background-color: #d1c284;
    --mark-color: #11191f;
    --ins-color: #388e3c;
    --del-color: #c62828;
    --blockquote-border-color: var(--muted-border-color);
    --blockquote-footer-color: var(--muted-color);
    --button-box-shadow: 0 0 0 rgba(0, 0, 0, 0);
    --button-hover-box-shadow: 0 0 0 rgba(0, 0, 0, 0);
    --form-element-background-color: #11191f;
    --form-element-border-color: #374956;
    --form-element-color: var(--color);
    --form-element-placeholder-color: var(--muted-color);
    --form-element-active-background-color: var(
      --form-element-background-color
    );
    --form-element-active-border-color: var(--primary);
    --form-element-focus-color: var(--primary-focus);
    --form-element-disabled-background-color: hsl(205deg, 25%, 23%);
    --form-element-disabled-border-color: hsl(205deg, 20%, 32%);
    --form-element-disabled-opacity: 0.5;
    --form-element-invalid-border-color: #b71c1c;
    --form-element-invalid-active-border-color: #c62828;
    --form-element-invalid-focus-color: rgba(198, 40, 40, 0.25);
    --form-element-valid-border-color: #2e7d32;
    --form-element-valid-active-border-color: #388e3c;
    --form-element-valid-focus-color: rgba(56, 142, 60, 0.25);
    --switch-background-color: #374956;
    --switch-color: var(--primary-inverse);
    --switch-checked-background-color: var(--primary);
    --range-border-color: #24333e;
    --range-active-border-color: hsl(205deg, 25%, 23%);
    --range-thumb-border-color: var(--background-color);
    --range-thumb-color: var(--secondary);
    --range-thumb-hover-color: var(--secondary-hover);
    --range-thumb-active-color: var(--primary);
    --table-border-color: var(--muted-border-color);
    --table-row-stripped-background-color: rgba(115, 130, 140, 0.05);
    --code-background-color: #18232c;
    --code-color: var(--muted-color);
    --code-kbd-background-color: var(--contrast);
    --code-kbd-color: var(--contrast-inverse);
    --code-tag-color: hsl(330deg, 30%, 50%);
    --code-property-color: hsl(185deg, 30%, 50%);
    --code-value-color: hsl(40deg, 10%, 50%);
    --code-comment-color: #4d606d;
    --accordion-border-color: var(--muted-border-color);
    --accordion-active-summary-color: var(--primary);
    --accordion-close-summary-color: var(--color);
    --accordion-open-summary-color: var(--muted-color);
    --card-background-color: #141e26;
    --card-border-color: var(--card-background-color);
    --card-box-shadow: 0.0145rem 0.029rem 0.174rem rgba(0, 0, 0, 0.01698),
      0.0335rem 0.067rem 0.402rem rgba(0, 0, 0, 0.024),
      0.0625rem 0.125rem 0.75rem rgba(0, 0, 0, 0.03),
      0.1125rem 0.225rem 1.35rem rgba(0, 0, 0, 0.036),
      0.2085rem 0.417rem 2.502rem rgba(0, 0, 0, 0.04302),
      0.5rem 1rem 6rem rgba(0, 0, 0, 0.06), 0 0 0 0.0625rem rgba(0, 0, 0, 0.015);
    --card-sectionning-background-color: #18232c;
    --dropdown-background-color: hsl(205deg, 30%, 15%);
    --dropdown-border-color: #24333e;
    --dropdown-box-shadow: var(--card-box-shadow);
    --dropdown-color: var(--color);
    --dropdown-hover-background-color: rgba(36, 51, 62, 0.75);
    --modal-overlay-background-color: rgba(36, 51, 62, 0.8);
    --progress-background-color: #24333e;
    --progress-color: var(--primary);
    --loading-spinner-opacity: 0.5;
    --tooltip-background-color: var(--contrast);
    --tooltip-color: var(--contrast-inverse);
    --icon-checkbox: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(255, 255, 255)' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20 6 9 17 4 12'%3E%3C/polyline%3E%3C/svg%3E");
    --icon-chevron: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(162, 175, 185)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
    --icon-chevron-button: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(255, 255, 255)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
    --icon-chevron-button-inverse: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(0, 0, 0)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
    --icon-close: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(115, 130, 140)' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'%3E%3Cline x1='18' y1='6' x2='6' y2='18'%3E%3C/line%3E%3Cline x1='6' y1='6' x2='18' y2='18'%3E%3C/line%3E%3C/svg%3E");
    --icon-date: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(162, 175, 185)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect x='3' y='4' width='18' height='18' rx='2' ry='2'%3E%3C/rect%3E%3Cline x1='16' y1='2' x2='16' y2='6'%3E%3C/line%3E%3Cline x1='8' y1='2' x2='8' y2='6'%3E%3C/line%3E%3Cline x1='3' y1='10' x2='21' y2='10'%3E%3C/line%3E%3C/svg%3E");
    --icon-invalid: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(183, 28, 28)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10'%3E%3C/circle%3E%3Cline x1='12' y1='8' x2='12' y2='12'%3E%3C/line%3E%3Cline x1='12' y1='16' x2='12.01' y2='16'%3E%3C/line%3E%3C/svg%3E");
    --icon-minus: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(255, 255, 255)' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'%3E%3Cline x1='5' y1='12' x2='19' y2='12'%3E%3C/line%3E%3C/svg%3E");
    --icon-search: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(162, 175, 185)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='11' cy='11' r='8'%3E%3C/circle%3E%3Cline x1='21' y1='21' x2='16.65' y2='16.65'%3E%3C/line%3E%3C/svg%3E");
    --icon-time: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(162, 175, 185)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10'%3E%3C/circle%3E%3Cpolyline points='12 6 12 12 16 14'%3E%3C/polyline%3E%3C/svg%3E");
    --icon-valid: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(46, 125, 50)' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20 6 9 17 4 12'%3E%3C/polyline%3E%3C/svg%3E");
    color-scheme: dark;
  }
}
[data-theme="dark"] {
  --background-color: #11191f;
  --color: hsl(205deg, 16%, 77%);
  --h1-color: hsl(205deg, 20%, 94%);
  --h2-color: #e1e6eb;
  --h3-color: hsl(205deg, 18%, 86%);
  --h4-color: #c8d1d8;
  --h5-color: hsl(205deg, 16%, 77%);
  --h6-color: #afbbc4;
  --muted-color: hsl(205deg, 10%, 50%);
  --muted-border-color: #1f2d38;
  --primary: hsl(195deg, 85%, 41%);
  --primary-hover: hsl(195deg, 80%, 50%);
  --primary-focus: rgba(16, 149, 193, 0.25);
  --primary-inverse: #fff;
  --secondary: hsl(205deg, 15%, 41%);
  --secondary-hover: hsl(205deg, 10%, 50%);
  --secondary-focus: rgba(115, 130, 140, 0.25);
  --secondary-inverse: #fff;
  --contrast: hsl(205deg, 20%, 94%);
  --contrast-hover: #fff;
  --contrast-focus: rgba(115, 130, 140, 0.25);
  --contrast-inverse: #000;
  --mark-background-color: #d1c284;
  --mark-color: #11191f;
  --ins-color: #388e3c;
  --del-color: #c62828;
  --blockquote-border-color: var(--muted-border-color);
  --blockquote-footer-color: var(--muted-color);
  --button-box-shadow: 0 0 0 rgba(0, 0, 0, 0);
  --button-hover-box-shadow: 0 0 0 rgba(0, 0, 0, 0);
  --form-element-background-color: #11191f;
  --form-element-border-color: #374956;
  --form-element-color: var(--color);
  --form-element-placeholder-color: var(--muted-color);
  --form-element-active-background-color: var(--form-element-background-color);
  --form-element-active-border-color: var(--primary);
  --form-element-focus-color: var(--primary-focus);
  --form-element-disabled-background-color: hsl(205deg, 25%, 23%);
  --form-element-disabled-border-color: hsl(205deg, 20%, 32%);
  --form-element-disabled-opacity: 0.5;
  --form-element-invalid-border-color: #b71c1c;
  --form-element-invalid-active-border-color: #c62828;
  --form-element-invalid-focus-color: rgba(198, 40, 40, 0.25);
  --form-element-valid-border-color: #2e7d32;
  --form-element-valid-active-border-color: #388e3c;
  --form-element-valid-focus-color: rgba(56, 142, 60, 0.25);
  --switch-background-color: #374956;
  --switch-color: var(--primary-inverse);
  --switch-checked-background-color: var(--primary);
  --range-border-color: #24333e;
  --range-active-border-color: hsl(205deg, 25%, 23%);
  --range-thumb-border-color: var(--background-color);
  --range-thumb-color: var(--secondary);
  --range-thumb-hover-color: var(--secondary-hover);
  --range-thumb-active-color: var(--primary);
  --table-border-color: var(--muted-border-color);
  --table-row-stripped-background-color: rgba(115, 130, 140, 0.05);
  --code-background-color: #18232c;
  --code-color: var(--muted-color);
  --code-kbd-background-color: var(--contrast);
  --code-kbd-color: var(--contrast-inverse);
  --code-tag-color: hsl(330deg, 30%, 50%);
  --code-property-color: hsl(185deg, 30%, 50%);
  --code-value-color: hsl(40deg, 10%, 50%);
  --code-comment-color: #4d606d;
  --accordion-border-color: var(--muted-border-color);
  --accordion-active-summary-color: var(--primary);
  --accordion-close-summary-color: var(--color);
  --accordion-open-summary-color: var(--muted-color);
  --card-background-color: #141e26;
  --card-border-color: var(--card-background-color);
  --card-box-shadow: 0.0145rem 0.029rem 0.174rem rgba(0, 0, 0, 0.01698),
    0.0335rem 0.067rem 0.402rem rgba(0, 0, 0, 0.024),
    0.0625rem 0.125rem 0.75rem rgba(0, 0, 0, 0.03),
    0.1125rem 0.225rem 1.35rem rgba(0, 0, 0, 0.036),
    0.2085rem 0.417rem 2.502rem rgba(0, 0, 0, 0.04302),
    0.5rem 1rem 6rem rgba(0, 0, 0, 0.06), 0 0 0 0.0625rem rgba(0, 0, 0, 0.015);
  --card-sectionning-background-color: #18232c;
  --dropdown-background-color: hsl(205deg, 30%, 15%);
  --dropdown-border-color: #24333e;
  --dropdown-box-shadow: var(--card-box-shadow);
  --dropdown-color: var(--color);
  --dropdown-hover-background-color: rgba(36, 51, 62, 0.75);
  --modal-overlay-background-color: rgba(36, 51, 62, 0.8);
  --progress-background-color: #24333e;
  --progress-color: var(--primary);
  --loading-spinner-opacity: 0.5;
  --tooltip-background-color: var(--contrast);
  --tooltip-color: var(--contrast-inverse);
  --icon-checkbox: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(255, 255, 255)' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20 6 9 17 4 12'%3E%3C/polyline%3E%3C/svg%3E");
  --icon-chevron: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(162, 175, 185)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
  --icon-chevron-button: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(255, 255, 255)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
  --icon-chevron-button-inverse: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(0, 0, 0)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
  --icon-close: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(115, 130, 140)' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'%3E%3Cline x1='18' y1='6' x2='6' y2='18'%3E%3C/line%3E%3Cline x1='6' y1='6' x2='18' y2='18'%3E%3C/line%3E%3C/svg%3E");
  --icon-date: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(162, 175, 185)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect x='3' y='4' width='18' height='18' rx='2' ry='2'%3E%3C/rect%3E%3Cline x1='16' y1='2' x2='16' y2='6'%3E%3C/line%3E%3Cline x1='8' y1='2' x2='8' y2='6'%3E%3C/line%3E%3Cline x1='3' y1='10' x2='21' y2='10'%3E%3C/line%3E%3C/svg%3E");
  --icon-invalid: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(183, 28, 28)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10'%3E%3C/circle%3E%3Cline x1='12' y1='8' x2='12' y2='12'%3E%3C/line%3E%3Cline x1='12' y1='16' x2='12.01' y2='16'%3E%3C/line%3E%3C/svg%3E");
  --icon-minus: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(255, 255, 255)' stroke-width='4' stroke-linecap='round' stroke-linejoin='round'%3E%3Cline x1='5' y1='12' x2='19' y2='12'%3E%3C/line%3E%3C/svg%3E");
  --icon-search: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(162, 175, 185)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='11' cy='11' r='8'%3E%3C/circle%3E%3Cline x1='21' y1='21' x2='16.65' y2='16.65'%3E%3C/line%3E%3C/svg%3E");
  --icon-time: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(162, 175, 185)' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10'%3E%3C/circle%3E%3Cpolyline points='12 6 12 12 16 14'%3E%3C/polyline%3E%3C/svg%3E");
  --icon-valid: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='rgb(46, 125, 50)' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='20 6 9 17 4 12'%3E%3C/polyline%3E%3C/svg%3E");
  color-scheme: dark;
}

progress,
[type="checkbox"],
[type="radio"],
[type="range"] {
  accent-color: var(--primary);
}

/**
 * Document
 * Content-box & Responsive typography
 */
*,
*::before,
*::after {
  box-sizing: border-box;
  background-repeat: no-repeat;
}

::before,
::after {
  text-decoration: inherit;
  vertical-align: inherit;
}

:where(#mount) {
  -webkit-tap-highlight-color: transparent;
  -webkit-text-size-adjust: 100%;
  -moz-text-size-adjust: 100%;
  text-size-adjust: 100%;
  background-color: var(--background-color);
  color: var(--color);
  font-weight: var(--font-weight);
  font-size: var(--font-size);
  line-height: var(--line-height);
  font-family: var(--font-family);
  text-rendering: optimizeLegibility;
  overflow-wrap: break-word;
  cursor: default;
  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;
}

/**
 * Sectioning
 * Container and responsive spacings for header, main, footer
 */
main {
  display: block;
}

#mount {
  width: 100%;
  margin: 0;
}
#mount > header,
#mount > main,
#mount > footer {
  width: 100%;
  margin-right: auto;
  margin-left: auto;
  padding: var(--block-spacing-vertical) var(--block-spacing-horizontal);
}
@media (min-width: 576px) {
  #mount > header,
  #mount > main,
  #mount > footer {
    max-width: 510px;
    padding-right: 0;
    padding-left: 0;
  }
}
@media (min-width: 768px) {
  #mount > header,
  #mount > main,
  #mount > footer {
    max-width: 700px;
  }
}
@media (min-width: 992px) {
  #mount > header,
  #mount > main,
  #mount > footer {
    max-width: 920px;
  }
}
@media (min-width: 1200px) {
  #mount > header,
  #mount > main,
  #mount > footer {
    max-width: 1130px;
  }
}

/**
* Container
*/
.container,
.container-fluid {
  width: 100%;
  margin-right: auto;
  margin-left: auto;
  padding-right: var(--spacing);
  padding-left: var(--spacing);
}

@media (min-width: 576px) {
  .container {
    max-width: 510px;
    padding-right: 0;
    padding-left: 0;
  }
}
@media (min-width: 768px) {
  .container {
    max-width: 700px;
  }
}
@media (min-width: 992px) {
  .container {
    max-width: 920px;
  }
}
@media (min-width: 1200px) {
  .container {
    max-width: 1130px;
  }
}

/**
 * Section
 * Responsive spacings for section
 */
section {
  margin-bottom: var(--block-spacing-vertical);
}

/**
* Grid
* Minimal grid system with auto-layout columns
*/
.grid {
  grid-column-gap: var(--grid-spacing-horizontal);
  grid-row-gap: var(--grid-spacing-vertical);
  display: grid;
  grid-template-columns: 1fr;
  margin: 0;
}
@media (min-width: 992px) {
  .grid {
    grid-template-columns: repeat(auto-fit, minmax(0%, 1fr));
  }
}
.grid > * {
  min-width: 0;
}

/**
 * Horizontal scroller (<figure>)
 */
figure {
  display: block;
  margin: 0;
  padding: 0;
  overflow-x: auto;
}
figure figcaption {
  padding: calc(var(--spacing) * 0.5) 0;
  color: var(--muted-color);
}

/**
 * Typography
 */
b,
strong {
  font-weight: bolder;
}

sub,
sup {
  position: relative;
  font-size: 0.75em;
  line-height: 0;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

address,
blockquote,
dl,
figure,
form,
ol,
p,
pre,
table,
ul {
  margin-top: 0;
  margin-bottom: var(--typography-spacing-vertical);
  color: var(--color);
  font-style: normal;
  font-weight: var(--font-weight);
  font-size: var(--font-size);
}

a,
[role="link"] {
  --color: var(--primary);
  --background-color: transparent;
  outline: none;
  background-color: var(--background-color);
  color: var(--color);
  -webkit-text-decoration: var(--text-decoration);
  text-decoration: var(--text-decoration);
  transition: background-color var(--transition), color var(--transition),
    box-shadow var(--transition), -webkit-text-decoration var(--transition);
  transition: background-color var(--transition), color var(--transition),
    text-decoration var(--transition), box-shadow var(--transition);
  transition: background-color var(--transition), color var(--transition),
    text-decoration var(--transition), box-shadow var(--transition),
    -webkit-text-decoration var(--transition);
}
a:is([aria-current], :hover, :active, :focus),
[role="link"]:is([aria-current], :hover, :active, :focus) {
  --color: var(--primary-hover);
  --text-decoration: underline;
}
a:focus,
[role="link"]:focus {
  --background-color: var(--primary-focus);
}
a.secondary,
[role="link"].secondary {
  --color: var(--secondary);
}
a.secondary:is([aria-current], :hover, :active, :focus),
[role="link"].secondary:is([aria-current], :hover, :active, :focus) {
  --color: var(--secondary-hover);
}
a.secondary:focus,
[role="link"].secondary:focus {
  --background-color: var(--secondary-focus);
}
a.contrast,
[role="link"].contrast {
  --color: var(--contrast);
}
a.contrast:is([aria-current], :hover, :active, :focus),
[role="link"].contrast:is([aria-current], :hover, :active, :focus) {
  --color: var(--contrast-hover);
}
a.contrast:focus,
[role="link"].contrast:focus {
  --background-color: var(--contrast-focus);
}

h1,
h2,
h3,
h4,
h5,
h6 {
  margin-top: 0;
  margin-bottom: var(--typography-spacing-vertical);
  color: var(--color);
  font-weight: var(--font-weight);
  font-size: var(--font-size);
  font-family: var(--font-family);
}

h1 {
  --color: var(--h1-color);
}

h2 {
  --color: var(--h2-color);
}

h3 {
  --color: var(--h3-color);
}

h4 {
  --color: var(--h4-color);
}

h5 {
  --color: var(--h5-color);
}

h6 {
  --color: var(--h6-color);
}

:where(address, blockquote, dl, figure, form, ol, p, pre, table, ul)
  ~ :is(h1, h2, h3, h4, h5, h6) {
  margin-top: var(--typography-spacing-vertical);
}

hgroup,
.headings {
  margin-bottom: var(--typography-spacing-vertical);
}
hgroup > *,
.headings > * {
  margin-bottom: 0;
}
hgroup > *:last-child,
.headings > *:last-child {
  --color: var(--muted-color);
  --font-weight: unset;
  font-size: 1rem;
  font-family: unset;
}

p {
  margin-bottom: var(--typography-spacing-vertical);
}

small {
  font-size: var(--font-size);
}

:where(dl, ol, ul) {
  padding-right: 0;
  padding-left: var(--spacing);
  -webkit-padding-start: var(--spacing);
  padding-inline-start: var(--spacing);
  -webkit-padding-end: 0;
  padding-inline-end: 0;
}
:where(dl, ol, ul) li {
  margin-bottom: calc(var(--typography-spacing-vertical) * 0.25);
}

:where(dl, ol, ul) :is(dl, ol, ul) {
  margin: 0;
  margin-top: calc(var(--typography-spacing-vertical) * 0.25);
}

ul li {
  list-style: square;
}

mark {
  padding: 0.125rem 0.25rem;
  background-color: var(--mark-background-color);
  color: var(--mark-color);
  vertical-align: baseline;
}

blockquote {
  display: block;
  margin: var(--typography-spacing-vertical) 0;
  padding: var(--spacing);
  border-right: none;
  border-left: 0.25rem solid var(--blockquote-border-color);
  -webkit-border-start: 0.25rem solid var(--blockquote-border-color);
  border-inline-start: 0.25rem solid var(--blockquote-border-color);
  -webkit-border-end: none;
  border-inline-end: none;
}
blockquote footer {
  margin-top: calc(var(--typography-spacing-vertical) * 0.5);
  color: var(--blockquote-footer-color);
}

abbr[title] {
  border-bottom: 1px dotted;
  text-decoration: none;
  cursor: help;
}

ins {
  color: var(--ins-color);
  text-decoration: none;
}

del {
  color: var(--del-color);
}

::-moz-selection {
  background-color: var(--primary-focus);
}

::selection {
  background-color: var(--primary-focus);
}

/**
 * Embedded content
 */
:where(audio, canvas, iframe, img, svg, video) {
  vertical-align: middle;
}

audio,
video {
  display: inline-block;
}

audio:not([controls]) {
  display: none;
  height: 0;
}

:where(iframe) {
  border-style: none;
}

img {
  max-width: 100%;
  height: auto;
  border-style: none;
}

:where(svg:not([fill])) {
  fill: currentColor;
}

svg:not(#mount) {
  overflow: hidden;
}

/**
 * Button
 */
button {
  margin: 0;
  overflow: visible;
  font-family: inherit;
  text-transform: none;
}

button,
[type="button"],
[type="reset"],
[type="submit"] {
  -webkit-appearance: button;
}

button {
  display: block;
  width: 100%;
  margin-bottom: var(--spacing);
}

[role="button"] {
  display: inline-block;
  text-decoration: none;
}

button,
input[type="submit"],
input[type="button"],
input[type="reset"],
[role="button"] {
  --background-color: var(--primary);
  --border-color: var(--primary);
  --color: var(--primary-inverse);
  --box-shadow: var(--button-box-shadow, 0 0 0 rgba(0, 0, 0, 0));
  padding: var(--form-element-spacing-vertical)
    var(--form-element-spacing-horizontal);
  border: var(--border-width) solid var(--border-color);
  border-radius: var(--border-radius);
  outline: none;
  background-color: var(--background-color);
  box-shadow: var(--box-shadow);
  color: var(--color);
  font-weight: var(--font-weight);
  font-size: 1rem;
  line-height: var(--line-height);
  text-align: center;
  cursor: pointer;
  transition: background-color var(--transition), border-color var(--transition),
    color var(--transition), box-shadow var(--transition);
}
button:is([aria-current], :hover, :active, :focus),
input[type="submit"]:is([aria-current], :hover, :active, :focus),
input[type="button"]:is([aria-current], :hover, :active, :focus),
input[type="reset"]:is([aria-current], :hover, :active, :focus),
[role="button"]:is([aria-current], :hover, :active, :focus) {
  --background-color: var(--primary-hover);
  --border-color: var(--primary-hover);
  --box-shadow: var(--button-hover-box-shadow, 0 0 0 rgba(0, 0, 0, 0));
  --color: var(--primary-inverse);
}
button:focus,
input[type="submit"]:focus,
input[type="button"]:focus,
input[type="reset"]:focus,
[role="button"]:focus {
  --box-shadow: var(--button-hover-box-shadow, 0 0 0 rgba(0, 0, 0, 0)),
    0 0 0 var(--outline-width) var(--primary-focus);
}

:is(
    button,
    input[type="submit"],
    input[type="button"],
    [role="button"]
  ).secondary,
input[type="reset"] {
  --background-color: var(--secondary);
  --border-color: var(--secondary);
  --color: var(--secondary-inverse);
  cursor: pointer;
}
:is(
    button,
    input[type="submit"],
    input[type="button"],
    [role="button"]
  ).secondary:is([aria-current], :hover, :active, :focus),
input[type="reset"]:is([aria-current], :hover, :active, :focus) {
  --background-color: var(--secondary-hover);
  --border-color: var(--secondary-hover);
  --color: var(--secondary-inverse);
}
:is(
    button,
    input[type="submit"],
    input[type="button"],
    [role="button"]
  ).secondary:focus,
input[type="reset"]:focus {
  --box-shadow: var(--button-hover-box-shadow, 0 0 0 rgba(0, 0, 0, 0)),
    0 0 0 var(--outline-width) var(--secondary-focus);
}

:is(
    button,
    input[type="submit"],
    input[type="button"],
    [role="button"]
  ).contrast {
  --background-color: var(--contrast);
  --border-color: var(--contrast);
  --color: var(--contrast-inverse);
}
:is(
    button,
    input[type="submit"],
    input[type="button"],
    [role="button"]
  ).contrast:is([aria-current], :hover, :active, :focus) {
  --background-color: var(--contrast-hover);
  --border-color: var(--contrast-hover);
  --color: var(--contrast-inverse);
}
:is(
    button,
    input[type="submit"],
    input[type="button"],
    [role="button"]
  ).contrast:focus {
  --box-shadow: var(--button-hover-box-shadow, 0 0 0 rgba(0, 0, 0, 0)),
    0 0 0 var(--outline-width) var(--contrast-focus);
}

:is(
    button,
    input[type="submit"],
    input[type="button"],
    [role="button"]
  ).outline,
input[type="reset"].outline {
  --background-color: transparent;
  --color: var(--primary);
}
:is(
    button,
    input[type="submit"],
    input[type="button"],
    [role="button"]
  ).outline:is([aria-current], :hover, :active, :focus),
input[type="reset"].outline:is([aria-current], :hover, :active, :focus) {
  --background-color: transparent;
  --color: var(--primary-hover);
}

:is(
    button,
    input[type="submit"],
    input[type="button"],
    [role="button"]
  ).outline.secondary,
input[type="reset"].outline {
  --color: var(--secondary);
}
:is(
    button,
    input[type="submit"],
    input[type="button"],
    [role="button"]
  ).outline.secondary:is([aria-current], :hover, :active, :focus),
input[type="reset"].outline:is([aria-current], :hover, :active, :focus) {
  --color: var(--secondary-hover);
}

:is(
    button,
    input[type="submit"],
    input[type="button"],
    [role="button"]
  ).outline.contrast {
  --color: var(--contrast);
}
:is(
    button,
    input[type="submit"],
    input[type="button"],
    [role="button"]
  ).outline.contrast:is([aria-current], :hover, :active, :focus) {
  --color: var(--contrast-hover);
}

:where(
    button,
    [type="submit"],
    [type="button"],
    [type="reset"],
    [role="button"]
  )[disabled],
:where(fieldset[disabled])
  :is(
    button,
    [type="submit"],
    [type="button"],
    [type="reset"],
    [role="button"]
  ),
a[role="button"]:not([href]) {
  opacity: 0.5;
  pointer-events: none;
}

/**
 * Form elements
 */
input,
optgroup,
select,
textarea {
  margin: 0;
  font-size: 1rem;
  line-height: var(--line-height);
  font-family: inherit;
  letter-spacing: inherit;
}

input {
  overflow: visible;
}

select {
  text-transform: none;
}

legend {
  max-width: 100%;
  padding: 0;
  color: inherit;
  white-space: normal;
}

textarea {
  overflow: auto;
}

[type="checkbox"],
[type="radio"] {
  padding: 0;
}

::-webkit-inner-spin-button,
::-webkit-outer-spin-button {
  height: auto;
}

[type="search"] {
  -webkit-appearance: textfield;
  outline-offset: -2px;
}

[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none;
}

::-webkit-file-upload-button {
  -webkit-appearance: button;
  font: inherit;
}

::-moz-focus-inner {
  padding: 0;
  border-style: none;
}

:-moz-focusring {
  outline: none;
}

:-moz-ui-invalid {
  box-shadow: none;
}

::-ms-expand {
  display: none;
}

[type="file"],
[type="range"] {
  padding: 0;
  border-width: 0;
}

input:not([type="checkbox"], [type="radio"], [type="range"]) {
  height: calc(
    1rem * var(--line-height) + var(--form-element-spacing-vertical) * 2 +
      var(--border-width) * 2
  );
}

fieldset {
  margin: 0;
  margin-bottom: var(--spacing);
  padding: 0;
  border: 0;
}

label,
fieldset legend {
  display: block;
  margin-bottom: calc(var(--spacing) * 0.25);
  font-weight: var(--form-label-font-weight, var(--font-weight));
}

input:not([type="checkbox"], [type="radio"]),
select,
textarea {
  width: 100%;
}

input:not([type="checkbox"], [type="radio"], [type="range"], [type="file"]),
select,
textarea {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  padding: var(--form-element-spacing-vertical)
    var(--form-element-spacing-horizontal);
}

input,
select,
textarea {
  --background-color: var(--form-element-background-color);
  --border-color: var(--form-element-border-color);
  --color: var(--form-element-color);
  --box-shadow: none;
  border: var(--border-width) solid var(--border-color);
  border-radius: var(--border-radius);
  outline: none;
  background-color: var(--background-color);
  box-shadow: var(--box-shadow);
  color: var(--color);
  font-weight: var(--font-weight);
  transition: background-color var(--transition), border-color var(--transition),
    color var(--transition), box-shadow var(--transition);
}

input:not(
    [type="submit"],
    [type="button"],
    [type="reset"],
    [type="checkbox"],
    [type="radio"],
    [readonly]
  ):is(:active, :focus),
:where(select, textarea):is(:active, :focus) {
  --background-color: var(--form-element-active-background-color);
}

input:not(
    [type="submit"],
    [type="button"],
    [type="reset"],
    [role="switch"],
    [readonly]
  ):is(:active, :focus),
:where(select, textarea):is(:active, :focus) {
  --border-color: var(--form-element-active-border-color);
}

input:not(
    [type="submit"],
    [type="button"],
    [type="reset"],
    [type="range"],
    [type="file"],
    [readonly]
  ):focus,
select:focus,
textarea:focus {
  --box-shadow: 0 0 0 var(--outline-width) var(--form-element-focus-color);
}

input:not([type="submit"], [type="button"], [type="reset"])[disabled],
select[disabled],
textarea[disabled],
:where(fieldset[disabled])
  :is(
    input:not([type="submit"], [type="button"], [type="reset"]),
    select,
    textarea
  ) {
  --background-color: var(--form-element-disabled-background-color);
  --border-color: var(--form-element-disabled-border-color);
  opacity: var(--form-element-disabled-opacity);
  pointer-events: none;
}

:where(input, select, textarea):not(
    [type="checkbox"],
    [type="radio"],
    [type="date"],
    [type="datetime-local"],
    [type="month"],
    [type="time"],
    [type="week"]
  )[aria-invalid] {
  padding-right: calc(
    var(--form-element-spacing-horizontal) + 1.5rem
  ) !important;
  padding-left: var(--form-element-spacing-horizontal);
  -webkit-padding-start: var(--form-element-spacing-horizontal) !important;
  padding-inline-start: var(--form-element-spacing-horizontal) !important;
  -webkit-padding-end: calc(
    var(--form-element-spacing-horizontal) + 1.5rem
  ) !important;
  padding-inline-end: calc(
    var(--form-element-spacing-horizontal) + 1.5rem
  ) !important;
  background-position: center right 0.75rem;
  background-size: 1rem auto;
  background-repeat: no-repeat;
}
:where(input, select, textarea):not(
    [type="checkbox"],
    [type="radio"],
    [type="date"],
    [type="datetime-local"],
    [type="month"],
    [type="time"],
    [type="week"]
  )[aria-invalid="false"] {
  background-image: var(--icon-valid);
}
:where(input, select, textarea):not(
    [type="checkbox"],
    [type="radio"],
    [type="date"],
    [type="datetime-local"],
    [type="month"],
    [type="time"],
    [type="week"]
  )[aria-invalid="true"] {
  background-image: var(--icon-invalid);
}
:where(input, select, textarea)[aria-invalid="false"] {
  --border-color: var(--form-element-valid-border-color);
}
:where(input, select, textarea)[aria-invalid="false"]:is(:active, :focus) {
  --border-color: var(--form-element-valid-active-border-color) !important;
  --box-shadow: 0 0 0 var(--outline-width) var(--form-element-valid-focus-color) !important;
}
:where(input, select, textarea)[aria-invalid="true"] {
  --border-color: var(--form-element-invalid-border-color);
}
:where(input, select, textarea)[aria-invalid="true"]:is(:active, :focus) {
  --border-color: var(--form-element-invalid-active-border-color) !important;
  --box-shadow: 0 0 0 var(--outline-width)
    var(--form-element-invalid-focus-color) !important;
}

[dir="rtl"]
  :where(input, select, textarea):not([type="checkbox"], [type="radio"]):is(
    [aria-invalid],
    [aria-invalid="true"],
    [aria-invalid="false"]
  ) {
  background-position: center left 0.75rem;
}

input::placeholder,
input::-webkit-input-placeholder,
textarea::placeholder,
textarea::-webkit-input-placeholder,
select:invalid {
  color: var(--form-element-placeholder-color);
  opacity: 1;
}

input:not([type="checkbox"], [type="radio"]),
select,
textarea {
  margin-bottom: var(--spacing);
}

select::-ms-expand {
  border: 0;
  background-color: transparent;
}
select:not([multiple], [size]) {
  padding-right: calc(var(--form-element-spacing-horizontal) + 1.5rem);
  padding-left: var(--form-element-spacing-horizontal);
  -webkit-padding-start: var(--form-element-spacing-horizontal);
  padding-inline-start: var(--form-element-spacing-horizontal);
  -webkit-padding-end: calc(var(--form-element-spacing-horizontal) + 1.5rem);
  padding-inline-end: calc(var(--form-element-spacing-horizontal) + 1.5rem);
  background-image: var(--icon-chevron);
  background-position: center right 0.75rem;
  background-size: 1rem auto;
  background-repeat: no-repeat;
}

[dir="rtl"] select:not([multiple], [size]) {
  background-position: center left 0.75rem;
}

:where(input, select, textarea) + small {
  display: block;
  width: 100%;
  margin-top: calc(var(--spacing) * -0.75);
  margin-bottom: var(--spacing);
  color: var(--muted-color);
}

label > :where(input, select, textarea) {
  margin-top: calc(var(--spacing) * 0.25);
}

/**
 * Form elements
 * Checkboxes & Radios
 */
[type="checkbox"],
[type="radio"] {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  width: 1.25em;
  height: 1.25em;
  margin-top: -0.125em;
  margin-right: 0.375em;
  margin-left: 0;
  -webkit-margin-start: 0;
  margin-inline-start: 0;
  -webkit-margin-end: 0.375em;
  margin-inline-end: 0.375em;
  border-width: var(--border-width);
  font-size: inherit;
  vertical-align: middle;
  cursor: pointer;
}
[type="checkbox"]::-ms-check,
[type="radio"]::-ms-check {
  display: none;
}
[type="checkbox"]:checked,
[type="checkbox"]:checked:active,
[type="checkbox"]:checked:focus,
[type="radio"]:checked,
[type="radio"]:checked:active,
[type="radio"]:checked:focus {
  --background-color: var(--primary);
  --border-color: var(--primary);
  background-image: var(--icon-checkbox);
  background-position: center;
  background-size: 0.75em auto;
  background-repeat: no-repeat;
}
[type="checkbox"] ~ label,
[type="radio"] ~ label {
  display: inline-block;
  margin-right: 0.375em;
  margin-bottom: 0;
  cursor: pointer;
}

[type="checkbox"]:indeterminate {
  --background-color: var(--primary);
  --border-color: var(--primary);
  background-image: var(--icon-minus);
  background-position: center;
  background-size: 0.75em auto;
  background-repeat: no-repeat;
}

[type="radio"] {
  border-radius: 50%;
}
[type="radio"]:checked,
[type="radio"]:checked:active,
[type="radio"]:checked:focus {
  --background-color: var(--primary-inverse);
  border-width: 0.35em;
  background-image: none;
}

[type="checkbox"][role="switch"] {
  --background-color: var(--switch-background-color);
  --border-color: var(--switch-background-color);
  --color: var(--switch-color);
  width: 2.25em;
  height: 1.25em;
  border: var(--border-width) solid var(--border-color);
  border-radius: 1.25em;
  background-color: var(--background-color);
  line-height: 1.25em;
}
[type="checkbox"][role="switch"]:focus {
  --background-color: var(--switch-background-color);
  --border-color: var(--switch-background-color);
}
[type="checkbox"][role="switch"]:checked {
  --background-color: var(--switch-checked-background-color);
  --border-color: var(--switch-checked-background-color);
}
[type="checkbox"][role="switch"]:before {
  display: block;
  width: calc(1.25em - (var(--border-width) * 2));
  height: 100%;
  border-radius: 50%;
  background-color: var(--color);
  content: "";
  transition: margin 0.1s ease-in-out;
}
[type="checkbox"][role="switch"]:checked {
  background-image: none;
}
[type="checkbox"][role="switch"]:checked::before {
  margin-left: calc(1.125em - var(--border-width));
  -webkit-margin-start: calc(1.125em - var(--border-width));
  margin-inline-start: calc(1.125em - var(--border-width));
}

[type="checkbox"][aria-invalid="false"],
[type="checkbox"]:checked[aria-invalid="false"],
[type="radio"][aria-invalid="false"],
[type="radio"]:checked[aria-invalid="false"],
[type="checkbox"][role="switch"][aria-invalid="false"],
[type="checkbox"][role="switch"]:checked[aria-invalid="false"] {
  --border-color: var(--form-element-valid-border-color);
}
[type="checkbox"][aria-invalid="true"],
[type="checkbox"]:checked[aria-invalid="true"],
[type="radio"][aria-invalid="true"],
[type="radio"]:checked[aria-invalid="true"],
[type="checkbox"][role="switch"][aria-invalid="true"],
[type="checkbox"][role="switch"]:checked[aria-invalid="true"] {
  --border-color: var(--form-element-invalid-border-color);
}

/**
 * Form elements
 * Alternatives input types (Not Checkboxes & Radios)
 */
[type="color"]::-webkit-color-swatch-wrapper {
  padding: 0;
}
[type="color"]::-moz-focus-inner {
  padding: 0;
}
[type="color"]::-webkit-color-swatch {
  border: 0;
  border-radius: calc(var(--border-radius) * 0.5);
}
[type="color"]::-moz-color-swatch {
  border: 0;
  border-radius: calc(var(--border-radius) * 0.5);
}

input:not([type="checkbox"], [type="radio"], [type="range"], [type="file"]):is(
    [type="date"],
    [type="datetime-local"],
    [type="month"],
    [type="time"],
    [type="week"]
  ) {
  --icon-position: 0.75rem;
  --icon-width: 1rem;
  padding-right: calc(var(--icon-width) + var(--icon-position));
  background-image: var(--icon-date);
  background-position: center right var(--icon-position);
  background-size: var(--icon-width) auto;
  background-repeat: no-repeat;
}
input:not(
    [type="checkbox"],
    [type="radio"],
    [type="range"],
    [type="file"]
  )[type="time"] {
  background-image: var(--icon-time);
}

[type="date"]::-webkit-calendar-picker-indicator,
[type="datetime-local"]::-webkit-calendar-picker-indicator,
[type="month"]::-webkit-calendar-picker-indicator,
[type="time"]::-webkit-calendar-picker-indicator,
[type="week"]::-webkit-calendar-picker-indicator {
  width: var(--icon-width);
  margin-right: calc(var(--icon-width) * -1);
  margin-left: var(--icon-position);
  opacity: 0;
}

[dir="rtl"]
  :is(
    [type="date"],
    [type="datetime-local"],
    [type="month"],
    [type="time"],
    [type="week"]
  ) {
  text-align: right;
}

[type="file"] {
  --color: var(--muted-color);
  padding: calc(var(--form-element-spacing-vertical) * 0.5) 0;
  border: 0;
  border-radius: 0;
  background: none;
}
[type="file"]::file-selector-button {
  --background-color: var(--secondary);
  --border-color: var(--secondary);
  --color: var(--secondary-inverse);
  margin-right: calc(var(--spacing) / 2);
  margin-left: 0;
  -webkit-margin-start: 0;
  margin-inline-start: 0;
  -webkit-margin-end: calc(var(--spacing) / 2);
  margin-inline-end: calc(var(--spacing) / 2);
  padding: calc(var(--form-element-spacing-vertical) * 0.5)
    calc(var(--form-element-spacing-horizontal) * 0.5);
  border: var(--border-width) solid var(--border-color);
  border-radius: var(--border-radius);
  outline: none;
  background-color: var(--background-color);
  box-shadow: var(--box-shadow);
  color: var(--color);
  font-weight: var(--font-weight);
  font-size: 1rem;
  line-height: var(--line-height);
  text-align: center;
  cursor: pointer;
  transition: background-color var(--transition), border-color var(--transition),
    color var(--transition), box-shadow var(--transition);
}
[type="file"]::file-selector-button:is(:hover, :active, :focus) {
  --background-color: var(--secondary-hover);
  --border-color: var(--secondary-hover);
}
[type="file"]::-webkit-file-upload-button {
  --background-color: var(--secondary);
  --border-color: var(--secondary);
  --color: var(--secondary-inverse);
  margin-right: calc(var(--spacing) / 2);
  margin-left: 0;
  -webkit-margin-start: 0;
  margin-inline-start: 0;
  -webkit-margin-end: calc(var(--spacing) / 2);
  margin-inline-end: calc(var(--spacing) / 2);
  padding: calc(var(--form-element-spacing-vertical) * 0.5)
    calc(var(--form-element-spacing-horizontal) * 0.5);
  border: var(--border-width) solid var(--border-color);
  border-radius: var(--border-radius);
  outline: none;
  background-color: var(--background-color);
  box-shadow: var(--box-shadow);
  color: var(--color);
  font-weight: var(--font-weight);
  font-size: 1rem;
  line-height: var(--line-height);
  text-align: center;
  cursor: pointer;
  -webkit-transition: background-color var(--transition),
    border-color var(--transition), color var(--transition),
    box-shadow var(--transition);
  transition: background-color var(--transition), border-color var(--transition),
    color var(--transition), box-shadow var(--transition);
}
[type="file"]::-webkit-file-upload-button:is(:hover, :active, :focus) {
  --background-color: var(--secondary-hover);
  --border-color: var(--secondary-hover);
}
[type="file"]::-ms-browse {
  --background-color: var(--secondary);
  --border-color: var(--secondary);
  --color: var(--secondary-inverse);
  margin-right: calc(var(--spacing) / 2);
  margin-left: 0;
  margin-inline-start: 0;
  margin-inline-end: calc(var(--spacing) / 2);
  padding: calc(var(--form-element-spacing-vertical) * 0.5)
    calc(var(--form-element-spacing-horizontal) * 0.5);
  border: var(--border-width) solid var(--border-color);
  border-radius: var(--border-radius);
  outline: none;
  background-color: var(--background-color);
  box-shadow: var(--box-shadow);
  color: var(--color);
  font-weight: var(--font-weight);
  font-size: 1rem;
  line-height: var(--line-height);
  text-align: center;
  cursor: pointer;
  -ms-transition: background-color var(--transition),
    border-color var(--transition), color var(--transition),
    box-shadow var(--transition);
  transition: background-color var(--transition), border-color var(--transition),
    color var(--transition), box-shadow var(--transition);
}
[type="file"]::-ms-browse:is(:hover, :active, :focus) {
  --background-color: var(--secondary-hover);
  --border-color: var(--secondary-hover);
}

[type="range"] {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  width: 100%;
  height: 1.25rem;
  background: none;
}
[type="range"]::-webkit-slider-runnable-track {
  width: 100%;
  height: 0.25rem;
  border-radius: var(--border-radius);
  background-color: var(--range-border-color);
  -webkit-transition: background-color var(--transition),
    box-shadow var(--transition);
  transition: background-color var(--transition), box-shadow var(--transition);
}
[type="range"]::-moz-range-track {
  width: 100%;
  height: 0.25rem;
  border-radius: var(--border-radius);
  background-color: var(--range-border-color);
  -moz-transition: background-color var(--transition),
    box-shadow var(--transition);
  transition: background-color var(--transition), box-shadow var(--transition);
}
[type="range"]::-ms-track {
  width: 100%;
  height: 0.25rem;
  border-radius: var(--border-radius);
  background-color: var(--range-border-color);
  -ms-transition: background-color var(--transition),
    box-shadow var(--transition);
  transition: background-color var(--transition), box-shadow var(--transition);
}
[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 1.25rem;
  height: 1.25rem;
  margin-top: -0.5rem;
  border: 2px solid var(--range-thumb-border-color);
  border-radius: 50%;
  background-color: var(--range-thumb-color);
  cursor: pointer;
  -webkit-transition: background-color var(--transition),
    transform var(--transition);
  transition: background-color var(--transition), transform var(--transition);
}
[type="range"]::-moz-range-thumb {
  -webkit-appearance: none;
  width: 1.25rem;
  height: 1.25rem;
  margin-top: -0.5rem;
  border: 2px solid var(--range-thumb-border-color);
  border-radius: 50%;
  background-color: var(--range-thumb-color);
  cursor: pointer;
  -moz-transition: background-color var(--transition),
    transform var(--transition);
  transition: background-color var(--transition), transform var(--transition);
}
[type="range"]::-ms-thumb {
  -webkit-appearance: none;
  width: 1.25rem;
  height: 1.25rem;
  margin-top: -0.5rem;
  border: 2px solid var(--range-thumb-border-color);
  border-radius: 50%;
  background-color: var(--range-thumb-color);
  cursor: pointer;
  -ms-transition: background-color var(--transition),
    transform var(--transition);
  transition: background-color var(--transition), transform var(--transition);
}
[type="range"]:hover,
[type="range"]:focus {
  --range-border-color: var(--range-active-border-color);
  --range-thumb-color: var(--range-thumb-hover-color);
}
[type="range"]:active {
  --range-thumb-color: var(--range-thumb-active-color);
}
[type="range"]:active::-webkit-slider-thumb {
  transform: scale(1.25);
}
[type="range"]:active::-moz-range-thumb {
  transform: scale(1.25);
}
[type="range"]:active::-ms-thumb {
  transform: scale(1.25);
}

input:not(
    [type="checkbox"],
    [type="radio"],
    [type="range"],
    [type="file"]
  )[type="search"] {
  -webkit-padding-start: calc(var(--form-element-spacing-horizontal) + 1.75rem);
  padding-inline-start: calc(var(--form-element-spacing-horizontal) + 1.75rem);
  border-radius: 5rem;
  background-image: var(--icon-search);
  background-position: center left 1.125rem;
  background-size: 1rem auto;
  background-repeat: no-repeat;
}
input:not(
    [type="checkbox"],
    [type="radio"],
    [type="range"],
    [type="file"]
  )[type="search"][aria-invalid] {
  -webkit-padding-start: calc(
    var(--form-element-spacing-horizontal) + 1.75rem
  ) !important;
  padding-inline-start: calc(
    var(--form-element-spacing-horizontal) + 1.75rem
  ) !important;
  background-position: center left 1.125rem, center right 0.75rem;
}
input:not(
    [type="checkbox"],
    [type="radio"],
    [type="range"],
    [type="file"]
  )[type="search"][aria-invalid="false"] {
  background-image: var(--icon-search), var(--icon-valid);
}
input:not(
    [type="checkbox"],
    [type="radio"],
    [type="range"],
    [type="file"]
  )[type="search"][aria-invalid="true"] {
  background-image: var(--icon-search), var(--icon-invalid);
}

[type="search"]::-webkit-search-cancel-button {
  -webkit-appearance: none;
  display: none;
}

[dir="rtl"]
  :where(input):not(
    [type="checkbox"],
    [type="radio"],
    [type="range"],
    [type="file"]
  )[type="search"] {
  background-position: center right 1.125rem;
}
[dir="rtl"]
  :where(input):not(
    [type="checkbox"],
    [type="radio"],
    [type="range"],
    [type="file"]
  )[type="search"][aria-invalid] {
  background-position: center right 1.125rem, center left 0.75rem;
}

/**
 * Table
 */
:where(table) {
  width: 100%;
  border-collapse: collapse;
  border-spacing: 0;
  text-indent: 0;
}

th,
td {
  padding: calc(var(--spacing) / 2) var(--spacing);
  border-bottom: var(--border-width) solid var(--table-border-color);
  color: var(--color);
  font-weight: var(--font-weight);
  font-size: var(--font-size);
  text-align: left;
  text-align: start;
}

tfoot th,
tfoot td {
  border-top: var(--border-width) solid var(--table-border-color);
  border-bottom: 0;
}

table[role="grid"] tbody tr:nth-child(odd) {
  background-color: var(--table-row-stripped-background-color);
}

/**
 * Code
 */
pre,
code,
kbd,
samp {
  font-size: 0.875em;
  font-family: var(--font-family);
}

pre {
  -ms-overflow-style: scrollbar;
  overflow: auto;
}

pre,
code,
kbd {
  border-radius: var(--border-radius);
  background: var(--code-background-color);
  color: var(--code-color);
  font-weight: var(--font-weight);
  line-height: initial;
}

code,
kbd {
  display: inline-block;
  padding: 0.375rem 0.5rem;
}

pre {
  display: block;
  margin-bottom: var(--spacing);
  overflow-x: auto;
}
pre > code {
  display: block;
  padding: var(--spacing);
  background: none;
  font-size: 14px;
  line-height: var(--line-height);
}

code b {
  color: var(--code-tag-color);
  font-weight: var(--font-weight);
}
code i {
  color: var(--code-property-color);
  font-style: normal;
}
code u {
  color: var(--code-value-color);
  text-decoration: none;
}
code em {
  color: var(--code-comment-color);
  font-style: normal;
}

kbd {
  background-color: var(--code-kbd-background-color);
  color: var(--code-kbd-color);
  vertical-align: baseline;
}

/**
 * Miscs
 */
hr {
  height: 0;
  border: 0;
  border-top: 1px solid var(--muted-border-color);
  color: inherit;
}

[hidden],
template {
  display: none !important;
}

canvas {
  display: inline-block;
}

/**
 * Accordion (<details>)
 */
details {
  display: block;
  margin-bottom: var(--spacing);
  padding-bottom: var(--spacing);
  border-bottom: var(--border-width) solid var(--accordion-border-color);
}
details summary {
  line-height: 1rem;
  list-style-type: none;
  cursor: pointer;
  transition: color var(--transition);
}
details summary:not([role]) {
  color: var(--accordion-close-summary-color);
}
details summary::-webkit-details-marker {
  display: none;
}
details summary::marker {
  display: none;
}
details summary::-moz-list-bullet {
  list-style-type: none;
}
details summary::after {
  display: block;
  width: 1rem;
  height: 1rem;
  -webkit-margin-start: calc(var(--spacing, 1rem) * 0.5);
  margin-inline-start: calc(var(--spacing, 1rem) * 0.5);
  float: right;
  transform: rotate(-90deg);
  background-image: var(--icon-chevron);
  background-position: right center;
  background-size: 1rem auto;
  background-repeat: no-repeat;
  content: "";
  transition: transform var(--transition);
}
details summary:focus {
  outline: none;
}
details summary:focus:not([role="button"]) {
  color: var(--accordion-active-summary-color);
}
details summary[role="button"] {
  width: 100%;
  text-align: left;
}
details summary[role="button"]::after {
  height: calc(1rem * var(--line-height, 1.5));
  background-image: var(--icon-chevron-button);
}
details summary[role="button"]:not(.outline).contrast::after {
  background-image: var(--icon-chevron-button-inverse);
}
details[open] > summary {
  margin-bottom: calc(var(--spacing));
}
details[open] > summary:not([role]):not(:focus) {
  color: var(--accordion-open-summary-color);
}
details[open] > summary::after {
  transform: rotate(0);
}

[dir="rtl"] details summary {
  text-align: right;
}
[dir="rtl"] details summary::after {
  float: left;
  background-position: left center;
}

/**
 * Card (<article>)
 */
article {
  margin: var(--block-spacing-vertical) 0;
  padding: var(--block-spacing-vertical) var(--block-spacing-horizontal);
  border-radius: var(--border-radius);
  background: var(--card-background-color);
  box-shadow: var(--card-box-shadow);
}
article > header,
article > footer {
  margin-right: calc(var(--block-spacing-horizontal) * -1);
  margin-left: calc(var(--block-spacing-horizontal) * -1);
  padding: calc(var(--block-spacing-vertical) * 0.66)
    var(--block-spacing-horizontal);
  background-color: var(--card-sectionning-background-color);
}
article > header {
  margin-top: calc(var(--block-spacing-vertical) * -1);
  margin-bottom: var(--block-spacing-vertical);
  border-bottom: var(--border-width) solid var(--card-border-color);
  border-top-right-radius: var(--border-radius);
  border-top-left-radius: var(--border-radius);
}
article > footer {
  margin-top: var(--block-spacing-vertical);
  margin-bottom: calc(var(--block-spacing-vertical) * -1);
  border-top: var(--border-width) solid var(--card-border-color);
  border-bottom-right-radius: var(--border-radius);
  border-bottom-left-radius: var(--border-radius);
}

/**
 * Modal (<dialog>)
 */
#mount {
  --scrollbar-width: 0px;
}

dialog {
  display: flex;
  z-index: 999;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  align-items: center;
  justify-content: center;
  width: inherit;
  min-width: 100%;
  height: inherit;
  min-height: 100%;
  padding: var(--spacing);
  border: 0;
  -webkit-backdrop-filter: var(--modal-overlay-backdrop-filter);
  backdrop-filter: var(--modal-overlay-backdrop-filter);
  background-color: var(--modal-overlay-background-color);
  color: var(--color);
}
dialog article {
  max-height: calc(100vh - var(--spacing) * 2);
  overflow: auto;
}
@media (min-width: 576px) {
  dialog article {
    max-width: 510px;
  }
}
@media (min-width: 768px) {
  dialog article {
    max-width: 700px;
  }
}
dialog article > header,
dialog article > footer {
  padding: calc(var(--block-spacing-vertical) * 0.5)
    var(--block-spacing-horizontal);
}
dialog article > header .close {
  margin: 0;
  margin-left: var(--spacing);
  float: right;
}
dialog article > footer {
  text-align: right;
}
dialog article > footer [role="button"] {
  margin-bottom: 0;
}
dialog article > footer [role="button"]:not(:first-of-type) {
  margin-left: calc(var(--spacing) * 0.5);
}
dialog article p:last-of-type {
  margin: 0;
}
dialog article .close {
  display: block;
  width: 1rem;
  height: 1rem;
  margin-top: calc(var(--block-spacing-vertical) * -0.5);
  margin-bottom: var(--typography-spacing-vertical);
  margin-left: auto;
  background-image: var(--icon-close);
  background-position: center;
  background-size: auto 1rem;
  background-repeat: no-repeat;
  opacity: 0.5;
  transition: opacity var(--transition);
}
dialog article .close:is([aria-current], :hover, :active, :focus) {
  opacity: 1;
}
dialog:not([open]),
dialog[open="false"] {
  display: none;
}

.modal-is-open {
  padding-right: var(--scrollbar-width, 0px);
  overflow: hidden;
  pointer-events: none;
}
.modal-is-open dialog {
  pointer-events: auto;
}

:where(.modal-is-opening, .modal-is-closing) dialog,
:where(.modal-is-opening, .modal-is-closing) dialog > article {
  animation-duration: 0.2s;
  animation-timing-function: ease-in-out;
  animation-fill-mode: both;
}
:where(.modal-is-opening, .modal-is-closing) dialog {
  animation-duration: 0.8s;
  animation-name: modal-overlay;
}
:where(.modal-is-opening, .modal-is-closing) dialog > article {
  animation-delay: 0.2s;
  animation-name: modal;
}

.modal-is-closing dialog,
.modal-is-closing dialog > article {
  animation-delay: 0s;
  animation-direction: reverse;
}

@keyframes modal-overlay {
  from {
    -webkit-backdrop-filter: none;
    backdrop-filter: none;
    background-color: transparent;
  }
}
@keyframes modal {
  from {
    transform: translateY(-100%);
    opacity: 0;
  }
}
/**
 * Nav
 */
:where(nav li)::before {
  float: left;
  content: "\u200B";
}

nav,
nav ul {
  display: flex;
}

nav {
  justify-content: space-between;
}
nav ol,
nav ul {
  align-items: center;
  margin-bottom: 0;
  padding: 0;
  list-style: none;
}
nav ol:first-of-type,
nav ul:first-of-type {
  margin-left: calc(var(--nav-element-spacing-horizontal) * -1);
}
nav ol:last-of-type,
nav ul:last-of-type {
  margin-right: calc(var(--nav-element-spacing-horizontal) * -1);
}
nav li {
  display: inline-block;
  margin: 0;
  padding: var(--nav-element-spacing-vertical)
    var(--nav-element-spacing-horizontal);
}
nav li > * {
  --spacing: 0;
}
nav :where(a, [role="link"]) {
  display: inline-block;
  margin: calc(var(--nav-link-spacing-vertical) * -1)
    calc(var(--nav-link-spacing-horizontal) * -1);
  padding: var(--nav-link-spacing-vertical) var(--nav-link-spacing-horizontal);
  border-radius: var(--border-radius);
  text-decoration: none;
}
nav :where(a, [role="link"]):is([aria-current], :hover, :active, :focus) {
  text-decoration: none;
}
nav[aria-label="breadcrumb"] {
  align-items: center;
  justify-content: start;
}
nav[aria-label="breadcrumb"] ul li:not(:first-child) {
  -webkit-margin-start: var(--nav-link-spacing-horizontal);
  margin-inline-start: var(--nav-link-spacing-horizontal);
}
nav[aria-label="breadcrumb"] ul li:not(:last-child) ::after {
  position: absolute;
  width: calc(var(--nav-link-spacing-horizontal) * 2);
  -webkit-margin-start: calc(var(--nav-link-spacing-horizontal) / 2);
  margin-inline-start: calc(var(--nav-link-spacing-horizontal) / 2);
  content: "/";
  color: var(--muted-color);
  text-align: center;
}
nav[aria-label="breadcrumb"] a[aria-current] {
  background-color: transparent;
  color: inherit;
  text-decoration: none;
  pointer-events: none;
}
nav [role="button"] {
  margin-right: inherit;
  margin-left: inherit;
  padding: var(--nav-link-spacing-vertical) var(--nav-link-spacing-horizontal);
}

aside nav,
aside ol,
aside ul,
aside li {
  display: block;
}
aside li {
  padding: calc(var(--nav-element-spacing-vertical) * 0.5)
    var(--nav-element-spacing-horizontal);
}
aside li a {
  display: block;
}
aside li [role="button"] {
  margin: inherit;
}

[dir="rtl"] nav[aria-label="breadcrumb"] ul li:not(:last-child) ::after {
  content: "\\\\";
}

/**
 * Progress
 */
progress {
  display: inline-block;
  vertical-align: baseline;
}

progress {
  -webkit-appearance: none;
  -moz-appearance: none;
  display: inline-block;
  appearance: none;
  width: 100%;
  height: 0.5rem;
  margin-bottom: calc(var(--spacing) * 0.5);
  overflow: hidden;
  border: 0;
  border-radius: var(--border-radius);
  background-color: var(--progress-background-color);
  color: var(--progress-color);
}
progress::-webkit-progress-bar {
  border-radius: var(--border-radius);
  background: none;
}
progress[value]::-webkit-progress-value {
  background-color: var(--progress-color);
}
progress::-moz-progress-bar {
  background-color: var(--progress-color);
}
@media (prefers-reduced-motion: no-preference) {
  progress:indeterminate {
    background: var(--progress-background-color)
      linear-gradient(
        to right,
        var(--progress-color) 30%,
        var(--progress-background-color) 30%
      )
      top left/150% 150% no-repeat;
    animation: progress-indeterminate 1s linear infinite;
  }
  progress:indeterminate[value]::-webkit-progress-value {
    background-color: transparent;
  }
  progress:indeterminate::-moz-progress-bar {
    background-color: transparent;
  }
}

@media (prefers-reduced-motion: no-preference) {
  [dir="rtl"] progress:indeterminate {
    animation-direction: reverse;
  }
}

@keyframes progress-indeterminate {
  0% {
    background-position: 200% 0;
  }
  100% {
    background-position: -200% 0;
  }
}
/**
 * Dropdown ([role="list"])
 */
details[role="list"],
li[role="list"] {
  position: relative;
}

details[role="list"] summary + ul,
li[role="list"] > ul {
  display: flex;
  z-index: 99;
  position: absolute;
  top: auto;
  right: 0;
  left: 0;
  flex-direction: column;
  margin: 0;
  padding: 0;
  border: var(--border-width) solid var(--dropdown-border-color);
  border-radius: var(--border-radius);
  border-top-right-radius: 0;
  border-top-left-radius: 0;
  background-color: var(--dropdown-background-color);
  box-shadow: var(--card-box-shadow);
  color: var(--dropdown-color);
  white-space: nowrap;
}
details[role="list"] summary + ul li,
li[role="list"] > ul li {
  width: 100%;
  margin-bottom: 0;
  padding: calc(var(--form-element-spacing-vertical) * 0.5)
    var(--form-element-spacing-horizontal);
  list-style: none;
}
details[role="list"] summary + ul li:first-of-type,
li[role="list"] > ul li:first-of-type {
  margin-top: calc(var(--form-element-spacing-vertical) * 0.5);
}
details[role="list"] summary + ul li:last-of-type,
li[role="list"] > ul li:last-of-type {
  margin-bottom: calc(var(--form-element-spacing-vertical) * 0.5);
}
details[role="list"] summary + ul li a,
li[role="list"] > ul li a {
  display: block;
  margin: calc(var(--form-element-spacing-vertical) * -0.5)
    calc(var(--form-element-spacing-horizontal) * -1);
  padding: calc(var(--form-element-spacing-vertical) * 0.5)
    var(--form-element-spacing-horizontal);
  overflow: hidden;
  color: var(--dropdown-color);
  text-decoration: none;
  text-overflow: ellipsis;
}
details[role="list"] summary + ul li a:hover,
li[role="list"] > ul li a:hover {
  background-color: var(--dropdown-hover-background-color);
}

details[role="list"] summary::after,
li[role="list"] > a::after {
  display: block;
  width: 1rem;
  height: calc(1rem * var(--line-height, 1.5));
  -webkit-margin-start: 0.5rem;
  margin-inline-start: 0.5rem;
  float: right;
  transform: rotate(0deg);
  background-position: right center;
  background-size: 1rem auto;
  background-repeat: no-repeat;
  content: "";
}

details[role="list"] {
  padding: 0;
  border-bottom: none;
}
details[role="list"] summary {
  margin-bottom: 0;
}
details[role="list"] summary:not([role]) {
  height: calc(
    1rem * var(--line-height) + var(--form-element-spacing-vertical) * 2 +
      var(--border-width) * 2
  );
  padding: var(--form-element-spacing-vertical)
    var(--form-element-spacing-horizontal);
  border: var(--border-width) solid var(--form-element-border-color);
  border-radius: var(--border-radius);
  background-color: var(--form-element-background-color);
  color: var(--form-element-placeholder-color);
  line-height: inherit;
  cursor: pointer;
  transition: background-color var(--transition), border-color var(--transition),
    color var(--transition), box-shadow var(--transition);
}
details[role="list"] summary:not([role]):active,
details[role="list"] summary:not([role]):focus {
  border-color: var(--form-element-active-border-color);
  background-color: var(--form-element-active-background-color);
}
details[role="list"] summary:not([role]):focus {
  box-shadow: 0 0 0 var(--outline-width) var(--form-element-focus-color);
}
details[role="list"][open] summary {
  border-bottom-right-radius: 0;
  border-bottom-left-radius: 0;
}
details[role="list"][open] summary::before {
  display: block;
  z-index: 1;
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background: none;
  content: "";
  cursor: default;
}

nav details[role="list"] summary,
nav li[role="list"] a {
  display: flex;
  direction: ltr;
}

nav details[role="list"] summary + ul,
nav li[role="list"] > ul {
  min-width: -moz-fit-content;
  min-width: fit-content;
  border-radius: var(--border-radius);
}
nav details[role="list"] summary + ul li a,
nav li[role="list"] > ul li a {
  border-radius: 0;
}

nav details[role="list"] summary,
nav details[role="list"] summary:not([role]) {
  height: auto;
  padding: var(--nav-link-spacing-vertical) var(--nav-link-spacing-horizontal);
}
nav details[role="list"][open] summary {
  border-radius: var(--border-radius);
}
nav details[role="list"] summary + ul {
  margin-top: var(--outline-width);
  -webkit-margin-start: 0;
  margin-inline-start: 0;
}
nav details[role="list"] summary[role="link"] {
  margin-bottom: calc(var(--nav-link-spacing-vertical) * -1);
  line-height: var(--line-height);
}
nav details[role="list"] summary[role="link"] + ul {
  margin-top: calc(var(--nav-link-spacing-vertical) + var(--outline-width));
  -webkit-margin-start: calc(var(--nav-link-spacing-horizontal) * -1);
  margin-inline-start: calc(var(--nav-link-spacing-horizontal) * -1);
}

li[role="list"]:hover > ul,
li[role="list"] a:active ~ ul,
li[role="list"] a:focus ~ ul {
  display: flex;
}
li[role="list"] > ul {
  display: none;
  margin-top: calc(var(--nav-link-spacing-vertical) + var(--outline-width));
  -webkit-margin-start: calc(
    var(--nav-element-spacing-horizontal) - var(--nav-link-spacing-horizontal)
  );
  margin-inline-start: calc(
    var(--nav-element-spacing-horizontal) - var(--nav-link-spacing-horizontal)
  );
}
li[role="list"] > a::after {
  background-image: var(--icon-chevron);
}

/**
 * Loading ([aria-busy=true])
 */
[aria-busy="true"] {
  cursor: progress;
}

[aria-busy="true"]:not(input, select, textarea)::before {
  display: inline-block;
  width: 1em;
  height: 1em;
  border: 0.1875em solid currentColor;
  border-radius: 1em;
  border-right-color: transparent;
  content: "";
  vertical-align: text-bottom;
  vertical-align: -0.125em;
  animation: spinner 0.75s linear infinite;
  opacity: var(--loading-spinner-opacity);
}
[aria-busy="true"]:not(input, select, textarea):not(:empty)::before {
  margin-right: calc(var(--spacing) * 0.5);
  margin-left: 0;
  -webkit-margin-start: 0;
  margin-inline-start: 0;
  -webkit-margin-end: calc(var(--spacing) * 0.5);
  margin-inline-end: calc(var(--spacing) * 0.5);
}
[aria-busy="true"]:not(input, select, textarea):empty {
  text-align: center;
}

button[aria-busy="true"],
input[type="submit"][aria-busy="true"],
input[type="button"][aria-busy="true"],
input[type="reset"][aria-busy="true"],
a[aria-busy="true"] {
  pointer-events: none;
}

@keyframes spinner {
  to {
    transform: rotate(360deg);
  }
}
/**
 * Tooltip ([data-tooltip])
 */
[data-tooltip] {
  position: relative;
}
[data-tooltip]:not(a, button, input) {
  border-bottom: 1px dotted;
  text-decoration: none;
  cursor: help;
}
[data-tooltip][data-placement="top"]::before,
[data-tooltip][data-placement="top"]::after,
[data-tooltip]::before,
[data-tooltip]::after {
  display: block;
  z-index: 99;
  position: absolute;
  bottom: 100%;
  left: 50%;
  padding: 0.25rem 0.5rem;
  overflow: hidden;
  transform: translate(-50%, -0.25rem);
  border-radius: var(--border-radius);
  background: var(--tooltip-background-color);
  content: attr(data-tooltip);
  color: var(--tooltip-color);
  font-style: normal;
  font-weight: var(--font-weight);
  font-size: 0.875rem;
  text-decoration: none;
  text-overflow: ellipsis;
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
}
[data-tooltip][data-placement="top"]::after,
[data-tooltip]::after {
  padding: 0;
  transform: translate(-50%, 0rem);
  border-top: 0.3rem solid;
  border-right: 0.3rem solid transparent;
  border-left: 0.3rem solid transparent;
  border-radius: 0;
  background-color: transparent;
  content: "";
  color: var(--tooltip-background-color);
}
[data-tooltip][data-placement="bottom"]::before,
[data-tooltip][data-placement="bottom"]::after {
  top: 100%;
  bottom: auto;
  transform: translate(-50%, 0.25rem);
}
[data-tooltip][data-placement="bottom"]:after {
  transform: translate(-50%, -0.3rem);
  border: 0.3rem solid transparent;
  border-bottom: 0.3rem solid;
}
[data-tooltip][data-placement="left"]::before,
[data-tooltip][data-placement="left"]::after {
  top: 50%;
  right: 100%;
  bottom: auto;
  left: auto;
  transform: translate(-0.25rem, -50%);
}
[data-tooltip][data-placement="left"]:after {
  transform: translate(0.3rem, -50%);
  border: 0.3rem solid transparent;
  border-left: 0.3rem solid;
}
[data-tooltip][data-placement="right"]::before,
[data-tooltip][data-placement="right"]::after {
  top: 50%;
  right: auto;
  bottom: auto;
  left: 100%;
  transform: translate(0.25rem, -50%);
}
[data-tooltip][data-placement="right"]:after {
  transform: translate(-0.3rem, -50%);
  border: 0.3rem solid transparent;
  border-right: 0.3rem solid;
}
[data-tooltip]:focus::before,
[data-tooltip]:focus::after,
[data-tooltip]:hover::before,
[data-tooltip]:hover::after {
  opacity: 1;
}
@media (hover: hover) and (pointer: fine) {
  [data-tooltip][data-placement="bottom"]:focus::before,
  [data-tooltip][data-placement="bottom"]:focus::after,
  [data-tooltip][data-placement="bottom"]:hover [data-tooltip]:focus::before,
  [data-tooltip][data-placement="bottom"]:hover [data-tooltip]:focus::after,
  [data-tooltip]:hover::before,
  [data-tooltip]:hover::after {
    animation-duration: 0.2s;
    animation-name: tooltip-slide-top;
  }
  [data-tooltip][data-placement="bottom"]:focus::after,
  [data-tooltip][data-placement="bottom"]:hover [data-tooltip]:focus::after,
  [data-tooltip]:hover::after {
    animation-name: tooltip-caret-slide-top;
  }
  [data-tooltip][data-placement="bottom"]:focus::before,
  [data-tooltip][data-placement="bottom"]:focus::after,
  [data-tooltip][data-placement="bottom"]:hover::before,
  [data-tooltip][data-placement="bottom"]:hover::after {
    animation-duration: 0.2s;
    animation-name: tooltip-slide-bottom;
  }
  [data-tooltip][data-placement="bottom"]:focus::after,
  [data-tooltip][data-placement="bottom"]:hover::after {
    animation-name: tooltip-caret-slide-bottom;
  }
  [data-tooltip][data-placement="left"]:focus::before,
  [data-tooltip][data-placement="left"]:focus::after,
  [data-tooltip][data-placement="left"]:hover::before,
  [data-tooltip][data-placement="left"]:hover::after {
    animation-duration: 0.2s;
    animation-name: tooltip-slide-left;
  }
  [data-tooltip][data-placement="left"]:focus::after,
  [data-tooltip][data-placement="left"]:hover::after {
    animation-name: tooltip-caret-slide-left;
  }
  [data-tooltip][data-placement="right"]:focus::before,
  [data-tooltip][data-placement="right"]:focus::after,
  [data-tooltip][data-placement="right"]:hover::before,
  [data-tooltip][data-placement="right"]:hover::after {
    animation-duration: 0.2s;
    animation-name: tooltip-slide-right;
  }
  [data-tooltip][data-placement="right"]:focus::after,
  [data-tooltip][data-placement="right"]:hover::after {
    animation-name: tooltip-caret-slide-right;
  }
}
@keyframes tooltip-slide-top {
  from {
    transform: translate(-50%, 0.75rem);
    opacity: 0;
  }
  to {
    transform: translate(-50%, -0.25rem);
    opacity: 1;
  }
}
@keyframes tooltip-caret-slide-top {
  from {
    opacity: 0;
  }
  50% {
    transform: translate(-50%, -0.25rem);
    opacity: 0;
  }
  to {
    transform: translate(-50%, 0rem);
    opacity: 1;
  }
}
@keyframes tooltip-slide-bottom {
  from {
    transform: translate(-50%, -0.75rem);
    opacity: 0;
  }
  to {
    transform: translate(-50%, 0.25rem);
    opacity: 1;
  }
}
@keyframes tooltip-caret-slide-bottom {
  from {
    opacity: 0;
  }
  50% {
    transform: translate(-50%, -0.5rem);
    opacity: 0;
  }
  to {
    transform: translate(-50%, -0.3rem);
    opacity: 1;
  }
}
@keyframes tooltip-slide-left {
  from {
    transform: translate(0.75rem, -50%);
    opacity: 0;
  }
  to {
    transform: translate(-0.25rem, -50%);
    opacity: 1;
  }
}
@keyframes tooltip-caret-slide-left {
  from {
    opacity: 0;
  }
  50% {
    transform: translate(0.05rem, -50%);
    opacity: 0;
  }
  to {
    transform: translate(0.3rem, -50%);
    opacity: 1;
  }
}
@keyframes tooltip-slide-right {
  from {
    transform: translate(-0.75rem, -50%);
    opacity: 0;
  }
  to {
    transform: translate(0.25rem, -50%);
    opacity: 1;
  }
}
@keyframes tooltip-caret-slide-right {
  from {
    opacity: 0;
  }
  50% {
    transform: translate(-0.05rem, -50%);
    opacity: 0;
  }
  to {
    transform: translate(-0.3rem, -50%);
    opacity: 1;
  }
}

/**
 * Accessibility & User interaction
 */
[aria-controls] {
  cursor: pointer;
}

[aria-disabled="true"],
[disabled] {
  cursor: not-allowed;
}

[aria-hidden="false"][hidden] {
  display: initial;
}

[aria-hidden="false"][hidden]:not(:focus) {
  clip: rect(0, 0, 0, 0);
  position: absolute;
}

a,
area,
button,
input,
label,
select,
summary,
textarea,
[tabindex] {
  -ms-touch-action: manipulation;
}

[dir="rtl"] {
  direction: rtl;
}

/**
* Reduce Motion Features
*/
@media (prefers-reduced-motion: reduce) {
  *:not([aria-busy="true"]),
  :not([aria-busy="true"])::before,
  :not([aria-busy="true"])::after {
    background-attachment: initial !important;
    animation-duration: 1ms !important;
    animation-delay: -1ms !important;
    animation-iteration-count: 1 !important;
    scroll-behavior: auto !important;
    transition-delay: 0s !important;
    transition-duration: 0s !important;
  }
}

/*# sourceMappingURL=custom.css.map */
`, IMMERSIVE_TRANSLATE_COMMON_CSS: '#mount#mount {\n  /* --primary: rgb(227, 59, 126); */\n  --primary: #ea4c89;\n  --primary-hover: #f082ac;\n}\n\nli.select-link.select-link:hover > ul {\n  display: none;\n}\nli.select-link.select-link > ul {\n  display: none;\n}\nli.select-link.select-link a:focus ~ ul {\n  display: none;\n}\n\nli.select-link.select-link a:active ~ ul {\n  display: none;\n}\nli.select-link-active.select-link-active > ul {\n  display: flex;\n}\nli.select-link-active.select-link-active:hover > ul {\n  display: flex;\n}\n\nli.select-link-active.select-link-active a:focus ~ ul {\n  display: flex;\n}\n\nli.select-link-active.select-link-active a:active ~ ul {\n  display: flex;\n}\nul.select-link-ul.select-link-ul {\n  right: 0px;\n  left: auto;\n}\n\na.select-link-selected {\n  background-color: var(--primary-focus);\n}\n.immersive-translate-no-select {\n  -webkit-touch-callout: none; /* iOS Safari */\n  -webkit-user-select: none; /* Safari */\n  -khtml-user-select: none; /* Konqueror HTML */\n  -moz-user-select: none; /* Old versions of Firefox */\n  -ms-user-select: none; /* Internet Explorer/Edge */\n  user-select: none;\n}\n\n/* li[role="list"].no-arrow > a::after { */\n/*   background-image: none; */\n/*   width: 0; */\n/*   color: var(--color); */\n/* } */\nli[role="list"].no-arrow {\n  margin-left: 8px;\n  padding-right: 0;\n}\nli[role="list"] > a::after {\n  -webkit-margin-start: 0.2rem;\n  margin-inline-start: 0.2rem;\n}\n\nli[role="list"].no-arrow > a,\nli[role="list"].no-arrow > a:link,\nli[role="list"].no-arrow > a:visited {\n  color: var(--secondary);\n}\n\nselect.min-select {\n  --form-element-spacing-horizontal: 0;\n  margin-bottom: 0;\n  max-width: 128px;\n  color: var(--primary);\n  font-size: 14px;\n  border: none;\n  padding: 0;\n  padding-right: 20px;\n  background-position: center right 0;\n  background-size: 16px auto;\n  text-overflow: ellipsis;\n  text-align: right;\n  color: var(--color);\n}\nselect.min-select-secondary {\n  color: var(--color);\n}\nselect.min-select:focus {\n  outline: none;\n  border: none;\n  --box-shadow: none;\n}\nselect.min-select-no-arrow {\n  background-image: none;\n  padding-right: 0;\n}\n\nselect.min-select-left {\n  padding-right: 0px;\n  /* padding-left: 24px; */\n  /* background-position: center left 0; */\n  text-overflow: ellipsis;\n  text-align: left;\n}\n\n.muted {\n  color: var(--muted-color);\n}\n\n.select.button-select {\n  --background-color: var(--secondary-hover);\n  --border-color: var(--secondary-hover);\n  --color: var(--secondary-inverse);\n  cursor: pointer;\n  --box-shadow: var(--button-box-shadow, 0 0 0 rgba(0, 0, 0, 0));\n  padding: var(--form-element-spacing-vertical)\n    var(--form-element-spacing-horizontal);\n  border: var(--border-width) solid var(--border-color);\n  border-radius: var(--border-radius);\n  outline: none;\n  background-color: var(--background-color);\n  box-shadow: var(--box-shadow);\n  color: var(--color);\n  font-weight: var(--font-weight);\n  font-size: 16px;\n  line-height: var(--line-height);\n  text-align: center;\n  cursor: pointer;\n  transition: background-color var(--transition), border-color var(--transition),\n    color var(--transition), box-shadow var(--transition);\n  -webkit-appearance: button;\n  margin: 0;\n  margin-bottom: 0px;\n  overflow: visible;\n  font-family: inherit;\n  text-transform: none;\n}\n', IMMERSIVE_TRANSLATE_POPUP_CSS: 'html {\n  font-size: 17px;\n  --font-size: 17px;\n}\n\nbody {\n  max-width: 100%;\n  padding: 0;\n  margin: 0;\n  min-width: 250px;\n  border-radius: 10px;\n}\n.immersive-translate-popup-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  touch-action: none;\n}\n.immersive-translate-popup-wrapper {\n  background: var(--background-color);\n  border-radius: 10px;\n  border: 1px solid var(--muted-border-color);\n}\n\n#mount#mount {\n  --font-family: system-ui, -apple-system, "Segoe UI", "Roboto", "Ubuntu",\n    "Cantarell", "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji",\n    "Segoe UI Symbol", "Noto Color Emoji";\n  --line-height: 1.5;\n  --font-weight: 400;\n  --font-size: 16px;\n  --border-radius: 4px;\n  --border-width: 1px;\n  --outline-width: 3px;\n  --spacing: 16px;\n  --typography-spacing-vertical: 24px;\n  --block-spacing-vertical: calc(var(--spacing) * 2);\n  --block-spacing-horizontal: var(--spacing);\n  --grid-spacing-vertical: 0;\n  --grid-spacing-horizontal: var(--spacing);\n  --form-element-spacing-vertical: 12px;\n  --form-element-spacing-horizontal: 16px;\n  --nav-element-spacing-vertical: 16px;\n  --nav-element-spacing-horizontal: 8px;\n  --nav-link-spacing-vertical: 8px;\n  --nav-link-spacing-horizontal: 8px;\n  --form-label-font-weight: var(--font-weight);\n  --transition: 0.2s ease-in-out;\n  --modal-overlay-backdrop-filter: blur(4px);\n}\n#mount {\n  min-width: 250px;\n}\n.main-button {\n  font-size: 14px;\n  vertical-align: middle;\n}\n\n.pt-4 {\n  padding-top: 24px;\n}\n.p-2 {\n  padding: 8px;\n}\n.pl-5 {\n  padding-left: 48px;\n}\n.p-0 {\n  padding: 0;\n}\n.pl-2 {\n  padding-left: 8px;\n}\n.pl-4 {\n  padding-left: 24px;\n}\n.pt-2 {\n  padding-top: 8px;\n}\n\n.pb-2 {\n  padding-bottom: 8px;\n}\n\n.pr-5 {\n  padding-right: 48px;\n}\n.text-sm {\n  font-size: 14px;\n}\n\n.flex {\n  display: flex;\n}\n.justify-between {\n  justify-content: space-between;\n}\n\n.mb-2 {\n  margin-bottom: 8px;\n}\n.inline-block {\n  display: inline-block;\n}\n\n.py-2 {\n  padding-top: 8px;\n  padding-bottom: 8px;\n}\n\n.mt-2 {\n  margin-top: 8px;\n}\n.mt-0 {\n  margin-top: 0;\n}\n\n.mb-1 {\n  margin-bottom: 4px;\n}\n.ml-4 {\n  margin-left: 24px;\n}\n.ml-3 {\n  margin-left: 16px;\n}\n.ml-2 {\n  margin-left: 8px;\n}\n.mr-1 {\n  margin-right: 4px;\n}\n.pl-3 {\n  padding-left: 12px;\n}\n.pr-3 {\n  padding-right: 12px;\n}\n.p-3 {\n  padding: 12px;\n}\n.mt-4 {\n  margin-top: 24px;\n}\n.py-0 {\n  padding-top: 0;\n  padding-bottom: 0;\n}\n\n.left-auto {\n  left: auto !important;\n}\n\n.max-h-28 {\n  max-height: 112px;\n}\n.max-h-30 {\n  max-height: 120px;\n}\n.overflow-y-scroll {\n  overflow-y: scroll;\n}\n.text-xs {\n  font-size: 12px;\n}\n\n.flex-1 {\n  flex: 1;\n}\n.flex-3 {\n  flex: 3;\n}\n.flex-4 {\n  flex: 4;\n}\n.flex-2 {\n  flex: 2;\n}\n.mt-3 {\n  margin-top: 16px;\n}\n.items-center {\n  align-items: center;\n}\n.items-end {\n  align-items: flex-end;\n}\n.items-baseline {\n  align-items: baseline;\n}\n\n.my-5 {\n  margin-top: 48px;\n  margin-bottom: 48px;\n}\n.my-4 {\n  margin-top: 24px;\n  margin-bottom: 24px;\n}\n.my-3 {\n  margin-top: 16px;\n  margin-bottom: 16px;\n}\n.pt-3 {\n  padding-top: 12px;\n}\n.px-3 {\n  padding-left: 12px;\n  padding-right: 12px;\n}\n.pt-2 {\n  padding-top: 8px;\n}\n.px-2 {\n  padding-left: 8px;\n  padding-right: 8px;\n}\n.pt-1 {\n  padding-top: 4px;\n}\n.px-1 {\n  padding-left: 4px;\n  padding-right: 4px;\n}\n.pb-2 {\n  padding-bottom: 8px;\n}\n.justify-end {\n  justify-content: flex-end;\n}\n.w-auto {\n  width: auto;\n}\n', IMMERSIVE_TRANSLATE_POPUP_HTML: '<style>\n  html {\n    font-size: 17px;\n  }\n  .immersive-translate-popup-container {\n    position: fixed;\n    padding: 0;\n    z-index: 999999;\n  }\n  .immersive-translate-popup-btn {\n    background-color: #ea4c89;\n    font-size: 18px;\n    opacity: 0.5;\n    width: 36px;\n    height: 36px;\n    border-radius: 9999999px;\n  }\n  .immersive-translate-popup-btn > svg {\n  }\n  #mount#mount {\n    position: absolute;\n    display: none;\n    min-width: 250px;\n    height: auto;\n    border: 1px solid #ccc;\n    border-radius: 5px;\n    --font-size: 17px;\n    font-size: 17px;\n  }\n</style>\n\n<div\n  id="immersive-translate-popup-container"\n  class="immersive-translate-popup-container"\n>\n  <button\n    id="immersive-translate-popup-btn"\n    class="immersive-translate-popup-btn"\n  >\n    <svg\n      xmlns="http://www.w3.org/2000/svg"\n      viewBox="0 0 24 24"\n      width="24"\n      height="24"\n    >\n      <path fill="none" d="M0 0h24v24H0z" />\n      <path\n        d="M5 15v2a2 2 0 0 0 1.85 1.995L7 19h3v2H7a4 4 0 0 1-4-4v-2h2zm13-5l4.4 11h-2.155l-1.201-3h-4.09l-1.199 3h-2.154L16 10h2zm-1 2.885L15.753 16h2.492L17 12.885zM8 2v2h4v7H8v3H6v-3H2V4h4V2h2zm9 1a4 4 0 0 1 4 4v2h-2V7a2 2 0 0 0-2-2h-3V3h3zM6 6H4v3h2V6zm4 0H8v3h2V6z"\n        fill="rgba(255,255,255,1)"\n      />\n    </svg>\n  </button>\n  <div class="immersive-translate-popup-mount" id="mount"></div>\n</div>\n', DEEPL_PROXY_ENDPOINT: "http://localhost:8001/v2/translate", MOCK: "0", DEBUG: "0" };

// https://esm.sh/v106/webextension-polyfill@0.10.0/deno/webextension-polyfill.development.js
var __create = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var require_browser_polyfill = __commonJS({
  "esm-build-3120606719048d5175703f3b3f8812d3453a0d07-9fbf1061/node_modules/webextension-polyfill/dist/browser-polyfill.js"(exports2, module2) {
    (function(global2, factory) {
      if (typeof define === "function" && define.amd) {
        define("webextension-polyfill", ["module"], factory);
      } else if (typeof exports2 !== "undefined") {
        factory(module2);
      } else {
        var mod = {
          exports: {}
        };
        factory(mod);
        global2.browser = mod.exports;
      }
    })(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : exports2, function(module22) {
      "use strict";
      if (!globalThis.chrome?.runtime?.id) {
        throw new Error("This script should only be loaded in a browser extension.");
      }
      if (typeof globalThis.browser === "undefined" || Object.getPrototypeOf(globalThis.browser) !== Object.prototype) {
        const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received.";
        const wrapAPIs = (extensionAPIs) => {
          const apiMetadata = {
            "alarms": {
              "clear": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "clearAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "get": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "getAll": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "bookmarks": {
              "create": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "get": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getChildren": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getRecent": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getSubTree": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getTree": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "move": {
                "minArgs": 2,
                "maxArgs": 2
              },
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeTree": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "search": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "update": {
                "minArgs": 2,
                "maxArgs": 2
              }
            },
            "browserAction": {
              "disable": {
                "minArgs": 0,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "enable": {
                "minArgs": 0,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "getBadgeBackgroundColor": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getBadgeText": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getPopup": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getTitle": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "openPopup": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "setBadgeBackgroundColor": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "setBadgeText": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "setIcon": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "setPopup": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "setTitle": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              }
            },
            "browsingData": {
              "remove": {
                "minArgs": 2,
                "maxArgs": 2
              },
              "removeCache": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeCookies": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeDownloads": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeFormData": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeHistory": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeLocalStorage": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removePasswords": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removePluginData": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "settings": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "commands": {
              "getAll": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "contextMenus": {
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "update": {
                "minArgs": 2,
                "maxArgs": 2
              }
            },
            "cookies": {
              "get": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getAll": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getAllCookieStores": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "set": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "devtools": {
              "inspectedWindow": {
                "eval": {
                  "minArgs": 1,
                  "maxArgs": 2,
                  "singleCallbackArg": false
                }
              },
              "panels": {
                "create": {
                  "minArgs": 3,
                  "maxArgs": 3,
                  "singleCallbackArg": true
                },
                "elements": {
                  "createSidebarPane": {
                    "minArgs": 1,
                    "maxArgs": 1
                  }
                }
              }
            },
            "downloads": {
              "cancel": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "download": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "erase": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getFileIcon": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "open": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "pause": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeFile": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "resume": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "search": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "show": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              }
            },
            "extension": {
              "isAllowedFileSchemeAccess": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "isAllowedIncognitoAccess": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "history": {
              "addUrl": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "deleteAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "deleteRange": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "deleteUrl": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getVisits": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "search": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "i18n": {
              "detectLanguage": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getAcceptLanguages": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "identity": {
              "launchWebAuthFlow": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "idle": {
              "queryState": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "management": {
              "get": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "getSelf": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "setEnabled": {
                "minArgs": 2,
                "maxArgs": 2
              },
              "uninstallSelf": {
                "minArgs": 0,
                "maxArgs": 1
              }
            },
            "notifications": {
              "clear": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "create": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "getAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "getPermissionLevel": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "update": {
                "minArgs": 2,
                "maxArgs": 2
              }
            },
            "pageAction": {
              "getPopup": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getTitle": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "hide": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "setIcon": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "setPopup": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "setTitle": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              },
              "show": {
                "minArgs": 1,
                "maxArgs": 1,
                "fallbackToNoCallback": true
              }
            },
            "permissions": {
              "contains": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getAll": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "request": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "runtime": {
              "getBackgroundPage": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "getPlatformInfo": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "openOptionsPage": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "requestUpdateCheck": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "sendMessage": {
                "minArgs": 1,
                "maxArgs": 3
              },
              "sendNativeMessage": {
                "minArgs": 2,
                "maxArgs": 2
              },
              "setUninstallURL": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "sessions": {
              "getDevices": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "getRecentlyClosed": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "restore": {
                "minArgs": 0,
                "maxArgs": 1
              }
            },
            "storage": {
              "local": {
                "clear": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "get": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getBytesInUse": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "set": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              },
              "managed": {
                "get": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getBytesInUse": {
                  "minArgs": 0,
                  "maxArgs": 1
                }
              },
              "sync": {
                "clear": {
                  "minArgs": 0,
                  "maxArgs": 0
                },
                "get": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "getBytesInUse": {
                  "minArgs": 0,
                  "maxArgs": 1
                },
                "remove": {
                  "minArgs": 1,
                  "maxArgs": 1
                },
                "set": {
                  "minArgs": 1,
                  "maxArgs": 1
                }
              }
            },
            "tabs": {
              "captureVisibleTab": {
                "minArgs": 0,
                "maxArgs": 2
              },
              "create": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "detectLanguage": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "discard": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "duplicate": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "executeScript": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "get": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getCurrent": {
                "minArgs": 0,
                "maxArgs": 0
              },
              "getZoom": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "getZoomSettings": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "goBack": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "goForward": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "highlight": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "insertCSS": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "move": {
                "minArgs": 2,
                "maxArgs": 2
              },
              "query": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "reload": {
                "minArgs": 0,
                "maxArgs": 2
              },
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "removeCSS": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "sendMessage": {
                "minArgs": 2,
                "maxArgs": 3
              },
              "setZoom": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "setZoomSettings": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "update": {
                "minArgs": 1,
                "maxArgs": 2
              }
            },
            "topSites": {
              "get": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "webNavigation": {
              "getAllFrames": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "getFrame": {
                "minArgs": 1,
                "maxArgs": 1
              }
            },
            "webRequest": {
              "handlerBehaviorChanged": {
                "minArgs": 0,
                "maxArgs": 0
              }
            },
            "windows": {
              "create": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "get": {
                "minArgs": 1,
                "maxArgs": 2
              },
              "getAll": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "getCurrent": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "getLastFocused": {
                "minArgs": 0,
                "maxArgs": 1
              },
              "remove": {
                "minArgs": 1,
                "maxArgs": 1
              },
              "update": {
                "minArgs": 2,
                "maxArgs": 2
              }
            }
          };
          if (Object.keys(apiMetadata).length === 0) {
            throw new Error("api-metadata.json has not been included in browser-polyfill");
          }
          class DefaultWeakMap extends WeakMap {
            constructor(createItem, items = void 0) {
              super(items);
              this.createItem = createItem;
            }
            get(key) {
              if (!this.has(key)) {
                this.set(key, this.createItem(key));
              }
              return super.get(key);
            }
          }
          const isThenable = (value) => {
            return value && typeof value === "object" && typeof value.then === "function";
          };
          const makeCallback = (promise, metadata) => {
            return (...callbackArgs) => {
              if (extensionAPIs.runtime.lastError) {
                promise.reject(new Error(extensionAPIs.runtime.lastError.message));
              } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {
                promise.resolve(callbackArgs[0]);
              } else {
                promise.resolve(callbackArgs);
              }
            };
          };
          const pluralizeArguments = (numArgs) => numArgs == 1 ? "argument" : "arguments";
          const wrapAsyncFunction = (name, metadata) => {
            return function asyncFunctionWrapper(target, ...args) {
              if (args.length < metadata.minArgs) {
                throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
              }
              if (args.length > metadata.maxArgs) {
                throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
              }
              return new Promise((resolve, reject) => {
                if (metadata.fallbackToNoCallback) {
                  try {
                    target[name](...args, makeCallback({
                      resolve,
                      reject
                    }, metadata));
                  } catch (cbError) {
                    console.warn(`${name} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `, cbError);
                    target[name](...args);
                    metadata.fallbackToNoCallback = false;
                    metadata.noCallback = true;
                    resolve();
                  }
                } else if (metadata.noCallback) {
                  target[name](...args);
                  resolve();
                } else {
                  target[name](...args, makeCallback({
                    resolve,
                    reject
                  }, metadata));
                }
              });
            };
          };
          const wrapMethod = (target, method, wrapper) => {
            return new Proxy(method, {
              apply(targetMethod, thisObj, args) {
                return wrapper.call(thisObj, target, ...args);
              }
            });
          };
          let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
          const wrapObject = (target, wrappers = {}, metadata = {}) => {
            let cache2 = /* @__PURE__ */ Object.create(null);
            let handlers = {
              has(proxyTarget2, prop) {
                return prop in target || prop in cache2;
              },
              get(proxyTarget2, prop, receiver) {
                if (prop in cache2) {
                  return cache2[prop];
                }
                if (!(prop in target)) {
                  return void 0;
                }
                let value = target[prop];
                if (typeof value === "function") {
                  if (typeof wrappers[prop] === "function") {
                    value = wrapMethod(target, target[prop], wrappers[prop]);
                  } else if (hasOwnProperty(metadata, prop)) {
                    let wrapper = wrapAsyncFunction(prop, metadata[prop]);
                    value = wrapMethod(target, target[prop], wrapper);
                  } else {
                    value = value.bind(target);
                  }
                } else if (typeof value === "object" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {
                  value = wrapObject(value, wrappers[prop], metadata[prop]);
                } else if (hasOwnProperty(metadata, "*")) {
                  value = wrapObject(value, wrappers[prop], metadata["*"]);
                } else {
                  Object.defineProperty(cache2, prop, {
                    configurable: true,
                    enumerable: true,
                    get() {
                      return target[prop];
                    },
                    set(value2) {
                      target[prop] = value2;
                    }
                  });
                  return value;
                }
                cache2[prop] = value;
                return value;
              },
              set(proxyTarget2, prop, value, receiver) {
                if (prop in cache2) {
                  cache2[prop] = value;
                } else {
                  target[prop] = value;
                }
                return true;
              },
              defineProperty(proxyTarget2, prop, desc) {
                return Reflect.defineProperty(cache2, prop, desc);
              },
              deleteProperty(proxyTarget2, prop) {
                return Reflect.deleteProperty(cache2, prop);
              }
            };
            let proxyTarget = Object.create(target);
            return new Proxy(proxyTarget, handlers);
          };
          const wrapEvent = (wrapperMap) => ({
            addListener(target, listener, ...args) {
              target.addListener(wrapperMap.get(listener), ...args);
            },
            hasListener(target, listener) {
              return target.hasListener(wrapperMap.get(listener));
            },
            removeListener(target, listener) {
              target.removeListener(wrapperMap.get(listener));
            }
          });
          const onRequestFinishedWrappers = new DefaultWeakMap((listener) => {
            if (typeof listener !== "function") {
              return listener;
            }
            return function onRequestFinished(req) {
              const wrappedReq = wrapObject(
                req,
                {},
                {
                  getContent: {
                    minArgs: 0,
                    maxArgs: 0
                  }
                }
              );
              listener(wrappedReq);
            };
          });
          const onMessageWrappers = new DefaultWeakMap((listener) => {
            if (typeof listener !== "function") {
              return listener;
            }
            return function onMessage(message, sender, sendResponse) {
              let didCallSendResponse = false;
              let wrappedSendResponse;
              let sendResponsePromise = new Promise((resolve) => {
                wrappedSendResponse = function(response) {
                  didCallSendResponse = true;
                  resolve(response);
                };
              });
              let result;
              try {
                result = listener(message, sender, wrappedSendResponse);
              } catch (err) {
                result = Promise.reject(err);
              }
              const isResultThenable = result !== true && isThenable(result);
              if (result !== true && !isResultThenable && !didCallSendResponse) {
                return false;
              }
              const sendPromisedResult = (promise) => {
                promise.then((msg) => {
                  sendResponse(msg);
                }, (error) => {
                  let message2;
                  if (error && (error instanceof Error || typeof error.message === "string")) {
                    message2 = error.message;
                  } else {
                    message2 = "An unexpected error occurred";
                  }
                  sendResponse({
                    __mozWebExtensionPolyfillReject__: true,
                    message: message2
                  });
                }).catch((err) => {
                  console.error("Failed to send onMessage rejected reply", err);
                });
              };
              if (isResultThenable) {
                sendPromisedResult(result);
              } else {
                sendPromisedResult(sendResponsePromise);
              }
              return true;
            };
          });
          const wrappedSendMessageCallback = ({
            reject,
            resolve
          }, reply) => {
            if (extensionAPIs.runtime.lastError) {
              if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {
                resolve();
              } else {
                reject(new Error(extensionAPIs.runtime.lastError.message));
              }
            } else if (reply && reply.__mozWebExtensionPolyfillReject__) {
              reject(new Error(reply.message));
            } else {
              resolve(reply);
            }
          };
          const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
            if (args.length < metadata.minArgs) {
              throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
            }
            if (args.length > metadata.maxArgs) {
              throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
            }
            return new Promise((resolve, reject) => {
              const wrappedCb = wrappedSendMessageCallback.bind(null, {
                resolve,
                reject
              });
              args.push(wrappedCb);
              apiNamespaceObj.sendMessage(...args);
            });
          };
          const staticWrappers = {
            devtools: {
              network: {
                onRequestFinished: wrapEvent(onRequestFinishedWrappers)
              }
            },
            runtime: {
              onMessage: wrapEvent(onMessageWrappers),
              onMessageExternal: wrapEvent(onMessageWrappers),
              sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
                minArgs: 1,
                maxArgs: 3
              })
            },
            tabs: {
              sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
                minArgs: 2,
                maxArgs: 3
              })
            }
          };
          const settingMetadata = {
            clear: {
              minArgs: 1,
              maxArgs: 1
            },
            get: {
              minArgs: 1,
              maxArgs: 1
            },
            set: {
              minArgs: 1,
              maxArgs: 1
            }
          };
          apiMetadata.privacy = {
            network: {
              "*": settingMetadata
            },
            services: {
              "*": settingMetadata
            },
            websites: {
              "*": settingMetadata
            }
          };
          return wrapObject(extensionAPIs, staticWrappers, apiMetadata);
        };
        module22.exports = wrapAPIs(chrome);
      } else {
        module22.exports = globalThis.browser;
      }
    });
  }
});
var __module = __toESM(require_browser_polyfill());
var { default: __default, ...__rest } = __module;
var mod_default = __default !== void 0 ? __default : __rest;

// browser/import_browser_polyfill.ts
globalThis.immersiveTranslateBrowserAPI = mod_default;

// locales/zh-CN.json
var zh_CN_default = {
  lineBreakMaxTextCount: "\u6362\u884C\u540E\uFF0C\u6BCF\u53E5\u8BDD\u5141\u8BB8\u7684\u6700\u5927\u5B57\u7B26\u6570\u91CF",
  "translate-pdf": "\u70B9\u51FB\u7FFB\u8BD1 PDF",
  "translate-firefox-local-pdf": "\u70B9\u51FB\u53BB\u4E0A\u4F20PDF",
  enableLineBreak: "\u662F\u5426\u5F00\u542F\u957F\u6BB5\u843D\u81EA\u52A8\u6362\u884C",
  sponsorLabel: "$1 \u8D77\u8D5E\u52A9\u5F00\u53D1\u8005",
  help: "\u5E2E\u52A9",
  browserShortcutsNoteForFirefox: "Firefox \u6D4F\u89C8\u5668\u4FEE\u6539\u5FEB\u6377\u952E\u9700\u8981\u6253\u5F00\u6269\u5C55\u7BA1\u7406\u9875\u9762 `about:addons`\uFF0C\u7136\u540E\u70B9\u51FB\u300C\u8BBE\u7F6E\u300D\uFF0C\u518D\u70B9\u51FB\u300C\u7BA1\u7406\u5FEB\u6377\u952E\u300D\u5373\u53EF\u8BBE\u7F6E",
  browserShortcutsNoteForChrome: "\u7C7BChrome \u6D4F\u89C8\u5668\u4FEE\u6539\u5FEB\u6377\u952E\u9700\u8981\u6253\u5F00\u6269\u5C55\u7BA1\u7406\u9875\u9762\uFF0C\u5728`\u7BA1\u7406\u5FEB\u6377\u952E`\u9762\u677F(`chrome://extensions/shortcuts`)\u8BBE\u7F6E\uFF0C\u70B9\u51FB\u4E0B\u65B9\u6309\u94AE\u8DF3\u8F6C\u5230\u5FEB\u6377\u952E\u7BA1\u7406\u9875\u9762\u3002",
  browserShortcutsSucks: "\u4FEE\u6539\u5FEB\u6377\u952E\u8BF7\u624B\u52A8\u8F93\u5165\uFF0C\u683C\u5F0F\u4E3A\uFF1A",
  enableLineBreakDescription: "\u5F00\u542F\u540E\uFF0C\u5C06\u4F1A\u5728\u957F\u6BB5\u843D\u4E2D\u6BCF\u53E5\u8BDD\u7ED3\u675F\u63D2\u5165\u6362\u884C\u7B26\uFF0C\u4EE5\u4FBF\u4E8E\u9605\u8BFB",
  "browser.brandName": "\u6C89\u6D78\u5F0F\u7FFB\u8BD1",
  "browser.brandDescription": "\u6C89\u6D78\u5F0F\u7F51\u9875\u53CC\u8BED\u7FFB\u8BD1\u6269\u5C55\uFF0C\u514D\u8D39\u4F7F\u7528\uFF0C\u652F\u6301 Deepl/Google/\u817E\u8BAF/\u706B\u5C71\u7FFB\u8BD1\u7B49\u591A\u4E2A\u7FFB\u8BD1\u670D\u52A1\uFF0C\u652F\u6301 Firefox/Chrome/\u6CB9\u7334\u811A\u672C\uFF0C\u4EA6\u53EF\u5728 iOS Safari \u4E0A\u4F7F\u7528\u3002",
  "browser.toggleTranslatePage": "\u7FFB\u8BD1\u7F51\u9875/\u663E\u793A\u539F\u6587",
  "browser.toggleTranslateTheWholePage": "\u7FFB\u8BD1\u9875\u9762\u5168\u90E8\u533A\u57DF/\u663E\u793A\u539F\u6587",
  "browser.toggleTranslateToThePageEndImmediately": "\u7ACB\u5373\u7FFB\u8BD1\u5230\u9875\u9762\u5E95\u90E8/\u663E\u793A\u539F\u6587",
  "browser.toggleTranslateTheMainPage": "\u7FFB\u8BD1\u9875\u9762\u4E3B\u8981\u533A\u57DF/\u663E\u793A\u539F\u6587",
  "browser.openOptionsPage": "\u6253\u5F00\u8BBE\u7F6E\u9875",
  "browser.toggleTranslationMask": "\u663E\u793A/\u9690\u85CF\u8BD1\u6587\u6A21\u7CCA\u6548\u679C",
  "browser.translateLocalPdfFile": "\u7FFB\u8BD1\u672C\u5730 PDF \u6587\u4EF6",
  confirmResetConfig: "\u4F60\u786E\u5B9A\u8981\u91CD\u7F6E\u8BBE\u7F6E\u5417\uFF1F",
  translationLineBreakSettingTitle: "\u8BD1\u6587\u6362\u884C\u8BBE\u7F6E",
  smartLineBreak: "\u667A\u80FD\u6362\u884C",
  alwaysLineBreak: "\u603B\u662F\u6362\u884C",
  toggleBeta: "\u5F00\u542F Beta \u6D4B\u8BD5\u7279\u6027",
  betaDescription: "\u5F00\u542F\u540E\u4F1A\u542F\u7528\u4E00\u4E9B\u5B9E\u9A8C\u6027\u529F\u80FD\uFF0C\u4EE5\u53CA\u8FD8\u5728\u6D4B\u8BD5\u4E2D\u7684\u7FFB\u8BD1\u670D\u52A1, \u53EF\u4EE5<1>\u52A0Telegram \u7FA4\u7EC4</1>\u4E86\u89E3",
  translationLineBreakSettingDescription: "\u5BF9\u4E8E\u8BD1\u6587\u7684\u4F4D\u7F6E\uFF1A\u603B\u662F\u6362\u884C(\u66F4\u6574\u9F50)/\u667A\u80FD\u6362\u884C\uFF08\u5F53\u6BB5\u843D\u591A\u4E8E{count}\u4E2A\u5B57\u7B26\u624D\u6362\u884C\u663E\u793A\u8BD1\u6587\uFF0C\u66F4\u7701\u7A7A\u95F4\uFF09",
  tempTranslateDomainTitle: "\u4E34\u65F6\u5F00\u542F\u7F51\u7AD9\u7FFB\u8BD1\u7684\u65F6\u957F",
  tempTranslateDomainDescription: "\u5F53\u624B\u52A8\u7FFB\u8BD1\u67D0\u4E2A\u7F51\u9875\u7684\u65F6\u5019\uFF0C\u4E34\u65F6\u5F00\u542F\u8BE5\u7F51\u7AD9\u4E3A\u81EA\u52A8\u7FFB\u8BD1",
  xMinutes: "{count} \u5206\u949F",
  disabled: "\u7981\u7528",
  changelog: "\u66F4\u65B0\u65E5\u5FD7",
  toggleTranslatePageWhenThreeFingersOnTheScreen: "\u591A\u6307\u540C\u65F6\u89E6\u6478\u5C4F\u5E55\u5219\u7FFB\u8BD1\u7F51\u9875/\u663E\u793A\u539F\u6587",
  toggleTranslationMaskWhenThreeFingersOnTheScreen: "\u591A\u6307\u540C\u65F6\u89E6\u6478\u5219\u663E\u793A/\u9690\u85CF\u8BD1\u6587\u6A21\u7CCA\u6548\u679C",
  addUrlDescription: "\u53EF\u4EE5\u4E3A\u57DF\u540D\uFF0C\u540C\u65F6\u652F\u6301\u901A\u914D\u7B26\uFF0C\u5982\uFF1A*.google.com, google.com/mail/*, https://www.google.com/*",
  general: "\u57FA\u672C\u8BBE\u7F6E",
  clickToExpandConfig: "\u5C55\u5F00\u5F53\u524D\u914D\u7F6E",
  import: "\u4ECE\u6587\u4EF6\u5BFC\u5165",
  export: "\u5BFC\u51FA\u5230\u6587\u4EF6",
  toggleDebug: "\u5728\u63A7\u5236\u53F0\u6253\u5370\u8C03\u8BD5\u65E5\u5FD7",
  "fingers.0": "\u5173\u95ED",
  "fingers.2": "\u53CC\u6307\u89E6\u6478",
  "fingers.3": "\u4E09\u6307\u89E6\u6478",
  "fingers.4": "\u56DB\u6307\u89E6\u6478",
  "fingers.5": "\u4E94\u6307\u89E6\u6478",
  document: "\u6587\u6863",
  resetSuccess: "\u91CD\u7F6E\u6240\u6709\u8BBE\u7F6E\u6210\u529F",
  resetThisSuccess: "\u91CD\u7F6E\u6210\u529F",
  saved: "\u4FDD\u5B58\u6210\u529F",
  successImportConfig: "\u6210\u529F\u5BFC\u5165\u914D\u7F6E",
  goAdvancedSettings: "\u53BB\u8FDB\u9636\u8BBE\u7F6E\u9875",
  goAdvancedInterfaceSettings: "\u53BB\u9AD8\u7EA7\u81EA\u5B9A\u4E49\u8BBE\u7F6E\u9875\u9762",
  advanced: "\u8FDB\u9636\u8BBE\u7F6E",
  advancedDescription: "\u4E00\u4E9B\u96BE\u4EE5\u7406\u89E3\u7684\u8BBE\u7F6E\u9879\uFF08\u4E00\u822C\u65E0\u9700\u8BBE\u7F6E\uFF0C\u4FDD\u6301\u9ED8\u8BA4\u5373\u53EF\uFF09",
  developer: "\u5F00\u53D1\u8005\u8BBE\u7F6E",
  donateCafe: "\u8BF7\u5F00\u53D1\u8005\u559D\u676F\u5496\u5561",
  "translate to the bottom of the page": "\u6253\u5F00\u7F51\u9875\u540E\uFF0C\u662F\u5426\u7ACB\u5373\u7FFB\u8BD1\u5230\u9875\u9762\u5E95\u90E8\uFF1F",
  feedback: "\u95EE\u9898\u53CD\u9988",
  toggleTranslatePage: "\u7FFB\u8BD1\u7F51\u9875/\u663E\u793A\u539F\u6587",
  translateToThePageEndImmediatelyDescription: "\u5F00\u542F\u540E\uFF0C\u5C06\u4F1A\u7ACB\u5373\u7FFB\u8BD1\u7F51\u9875\u4ECE\u9876\u90E8\u5230\u5E95\u90E8\u7684\u5185\u5BB9\uFF0C\u800C\u4E0D\u662F\u8FB9\u770B\u8FB9\u8BD1\u3002\uFF08\u4E0D\u63A8\u8350\u5F00\u542F\uFF09",
  "translate all areas of the page": "\u662F\u5426\u7FFB\u8BD1\u7F51\u9875\u6240\u6709\u533A\u57DF",
  translationAreaDescription: "\u5F00\u542F\u540E\uFF0C\u6574\u4E2A\u7F51\u9875\u7684\u533A\u57DF\u90FD\u4F1A\u88AB\u7FFB\u8BD1\uFF0C\u800C\u4E0D\u662F\u9ED8\u8BA4\u7684\u667A\u80FD\u8BC6\u522B\u4E3B\u8981\u533A\u57DF\u53BB\u7FFB\u8BD1\uFF08\u4E0D\u63A8\u8350\u5F00\u542F\uFF09",
  "the number of characters to be translated first": "\u524D\u591A\u5C11\u4E2A\u5B57\u7B26\u65E0\u9700\u7B49\u5F85\u6EDA\u52A8\u5230\u53EF\u89C6\u533A\u57DF\uFF0C\u76F4\u63A5\u7FFB\u8BD1\uFF1F",
  "interface language": "\u754C\u9762\u8BED\u8A00",
  "display both the original text and the translation": "\u540C\u65F6\u663E\u793A\u539F\u6587\u548C\u8BD1\u6587",
  "keyboard shortcuts": "\u952E\u76D8\u5FEB\u6377\u952E",
  modify: "\u4FEE\u6539\u5FEB\u6377\u952E",
  reset: "\u91CD\u7F6E",
  close: "\u5173\u95ED",
  homepage: "\u4E3B\u9875",
  more: "\u66F4\u591A",
  translateTheWholePage: "\u7FFB\u8BD1\u9875\u9762\u5168\u90E8\u533A\u57DF\uFF08\u533A\u522B\u4E8E\u667A\u80FD\u8BC6\u522B\u4E3B\u8981\u533A\u57DF\uFF09",
  changeToTranslateTheWholePage: "\u5207\u6362\u4E3A\u7FFB\u8BD1\u6240\u6709\u533A\u57DF",
  changeToTranslateTheMainPage: "\u5207\u6362\u4E3A\u7FFB\u8BD1\u4E3B\u8981\u533A\u57DF",
  translateToThePageEndImmediately: "\u7ACB\u5373\u7FFB\u8BD1\u5230\u9875\u9762\u5E95\u90E8",
  translateTheMainPage: "\u667A\u80FD\u7FFB\u8BD1\u4E3B\u8981\u533A\u57DF",
  "The local rules are up to date": "\u672C\u5730\u9002\u914D\u89C4\u5219\u5DF2\u662F\u6700\u65B0:",
  "Successfully synchronized with the latest official rules:": "\u6210\u529F\u540C\u6B65\u6700\u65B0\u5B98\u65B9\u9002\u914D\u89C4\u5219:",
  "Checking for updates": "\u6B63\u5728\u68C0\u67E5\u66F4\u65B0",
  "Rules are being synchronized": "\u6B63\u5728\u540C\u6B65\u9002\u914D\u89C4\u5219",
  localVersionIsTooOld: "\u672C\u5730\u6269\u5C55\u7248\u672C\u8FC7\u65E7\uFF0C\u8BF7\u5347\u7EA7\u6269\u5C55\u5230 {minVersion} \u6216\u4E4B\u540E\u7684\u7248\u672C\u518D\u5C1D\u8BD5\u540C\u6B65",
  badUserscriptBrowser: "\u8BE5\u6D4F\u89C8\u5668\u672A\u6B63\u786E\u5B9E\u73B0\u6CB9\u7334\u7684\u63A5\u53E3\uFF0C\u8BF7\u4F7F\u7528\u5176\u4ED6<1>\u652F\u6301\u6CB9\u7334</1>\u7684\u6D4F\u89C8\u5668\u5982(Firefox Nightly \u7248\u672C)",
  foundNewVersion: "\u53D1\u73B0\u65B0\u7248\u672C",
  theLocalExtensionIsUpToUpdate: "\u5F53\u524D\u6269\u5C55\u5DF2\u662F\u6700\u65B0\u7248\u672C\u3002",
  failToSyncRules: "\u540C\u6B65\u6700\u65B0\u9002\u914D\u89C4\u5219\u5931\u8D25",
  retry: "\u70B9\u6B64\u91CD\u8BD5",
  failedReason: "\u5931\u8D25\u539F\u56E0",
  currentRuleVersion: "\u5F53\u524D\u89C4\u5219\u7248\u672C",
  calculating: "\u8BA1\u7B97\u4E2D",
  unknownError: "\u672A\u77E5\u9519\u8BEF",
  canNotFetchRemoteRule: "\u65E0\u6CD5\u83B7\u53D6\u8FDC\u7A0B\u89C4\u5219",
  enableAlphaSuccess: "\u5DF2\u5F00\u542FAlpha\u529F\u80FD",
  disableAlphaSuccess: "\u5DF2\u5173\u95EDAlpha\u529F\u80FD",
  cacheSize: "\u7F13\u5B58\u5927\u5C0F\uFF1A",
  cleaning: "\u6E05\u7406\u4E2D",
  cleanCache: "\u6E05\u9664\u7F13\u5B58",
  options: "\u8BBE\u7F6E",
  about: "\u5173\u4E8E",
  service: "\u7FFB\u8BD1\u670D\u52A1",
  needAction: "(\u53BB\u8BBE\u7F6E)",
  goSettings: "\u53BB\u8BBE\u7F6E",
  needActionForOptions: "(\u9700\u8BBE\u7F6E)",
  translationEngine: "\u5F15\u64CE\u9009\u9879",
  sourceLanguage: "\u539F\u6587\u8BED\u8A00",
  target: "\u76EE\u6807\u8BED\u8A00",
  popupSourceLanguage: "\u539F\u6587\u8BED\u8A00",
  popupTarget: "\u76EE\u6807\u8BED\u8A00",
  popupService: "\u7FFB\u8BD1\u670D\u52A1",
  forThisSite: "\u9488\u5BF9\u8BE5\u7F51\u7AD9\uFF1A",
  alwaysTranslateSomeLanguage: "\u603B\u662F\u7FFB\u8BD1{language}",
  neverTranslateSomeLanguage: "\u6C38\u4E0D\u7FFB\u8BD1{language}",
  alwaysTranslateSomeSite: "\u603B\u662F\u7FFB\u8BD1 {hostname}",
  neverTranslateSomeSite: "\u6C38\u4E0D\u7FFB\u8BD1 {hostname}",
  add: "\u6DFB\u52A0",
  default: "\u9ED8\u8BA4",
  forThisLanguage: "\u9488\u5BF9\u8BE5\u8BED\u8A00\uFF1A",
  "add url": "\u8F93\u5165URL",
  edit: "\u7F16\u8F91",
  "translate other languages into specific language": "\u5C06\u5176\u4ED6\u8BED\u8A00\u7FFB\u8BD1\u4E3A\u4F60\u8BBE\u7F6E\u7684\u8BED\u8A00",
  "select translation service": "\u9009\u62E9\u4E00\u9879\u7FFB\u8BD1\u670D\u52A1",
  language: "\u8BED\u8A00",
  "show-original": "\u663E\u793A\u539F\u6587",
  translate: "\u7FFB\u8BD1",
  Translated: "\u5DF2\u7FFB\u8BD1",
  Translating: "\u7FFB\u8BD1\u4E2D",
  Error: "\u9519\u8BEF",
  allowCacheTranslations: "\u5F00\u542F\u672C\u5730\u7FFB\u8BD1\u7F13\u5B58\uFF08\u51CF\u5C11\u91CD\u590D\u6BB5\u843D\u7684\u7FFB\u8BD1\u8BF7\u6C42\uFF09",
  "translation display": "\u8BD1\u6587\u663E\u793A\u6837\u5F0F",
  "select diplay style": "\u533A\u5206\u8BD1\u6587\u7684\u6837\u5F0F\uFF0C\u5177\u4F53\u53EF\u53C2\u8003\u4E0B\u5217\u793A\u4F8B",
  interface: "\u754C\u9762\u8BBE\u7F6E",
  import_export: "\u5BFC\u5165/\u5BFC\u51FA",
  import_export_title: "\u5BFC\u5165/\u5BFC\u51FA\u914D\u7F6E",
  syncToGoogleDrive: "\u7ACB\u5373\u4E0E Google Drive \u540C\u6B65",
  previewAllThemes: "\u9884\u89C8\u5168\u90E8\u6837\u5F0F",
  "translationTheme.none": "\u65E0",
  "translationTheme.dashed": "\u865A\u7EBF\u4E0B\u5212\u7EBF",
  "translationTheme.dotted": "\u70B9\u72B6\u4E0B\u5212\u7EBF",
  "translationTheme.dashedBorder": "\u865A\u7EBF\u8FB9\u6846",
  "translationTheme.underline": "\u76F4\u7EBF\u4E0B\u5212\u7EBF",
  "translationTheme.mask": "\u6A21\u7CCA\u6548\u679C",
  "translationTheme.paper": "\u767D\u7EB8\u9634\u5F71\u6548\u679C",
  "translationTheme.dividingLine": "\u5206\u5272\u7EBF",
  "translationTheme.highlight": "\u9AD8\u4EAE",
  "translationTheme.marker": "\u9A6C\u514B\u7B14",
  "translationTheme.blockquote": "\u5F15\u7528\u6837\u5F0F",
  "translationTheme.weakening": "\u5F31\u5316",
  "translationTheme.italic": "\u659C\u4F53",
  "translationTheme.bold": "\u52A0\u7C97",
  "translationTheme.thinDashed": "\u7EC6\u865A\u7EBF\u4E0B\u5212\u7EBF",
  "translationTheme.nativeDashed": "\u7CFB\u7EDF\u81EA\u5E26\u865A\u7EBF\u4E0B\u5212\u7EBF",
  "translationTheme.nativeDotted": "\u7CFB\u7EDF\u81EA\u5E26\u70B9\u72B6\u4E0B\u5212\u7EBF",
  "translationTheme.nativeUnderline": "\u7CFB\u7EDF\u81EA\u5E26\u76F4\u7EBF\u4E0B\u5212\u7EBF",
  "translationTheme.wavy": "\u6CE2\u6D6A\u7EBF",
  "translationServices.tencent": "\u817E\u8BAF\u7FFB\u8BD1\u541B",
  "translationServices.google": "\u8C37\u6B4C\u7FFB\u8BD1",
  "translationServices.bai": "\u767E\u5EA6(Alpha)",
  "translationServices.baidu": "\u767E\u5EA6\u7FFB\u8BD1",
  "translationServices.aliyun": "\u963F\u91CC\u4E91\u7FFB\u8BD1",
  "translationServices.volc": "\u706B\u5C71\u7FFB\u8BD1",
  "translationServices.deeplx": "DeeplX(Beta)",
  "translationServices.bing": "\u5FC5\u5E94\u7FFB\u8BD1",
  "translationServices.deepl": "Deepl",
  "translationServices.wechat": "\u5FAE\u4FE1\u7FFB\u8BD1",
  "translationServices.azure": "\u5FAE\u8F6F\u7FFB\u8BD1",
  "translationServices.ibm": "IBM Watson",
  "translationServices.aws": "\u4E9A\u9A6C\u900A\u7FFB\u8BD1",
  "translationServices.mock": "\u6A21\u62DF\u7FFB\u8BD1",
  "translationServices.mock2": "\u6A21\u62DF\u7FFB\u8BD12",
  "translationServices.caiyun": "\u5F69\u4E91\u5C0F\u8BD1",
  "translationServices.volcAlpha": "\u706B\u5C71 (Alpha)",
  "translationServices.openl": "OpenL",
  "translationServices.youdao": "\u6709\u9053\u7FFB\u8BD1",
  "translationServices.transmart": "\u817E\u8BAF\u4EA4\u4E92\u7FFB\u8BD1",
  "translationServices.niu": "\u5C0F\u725B\u7FFB\u8BD1",
  "translationServices.d": "D (Alpha)",
  "translationServices.dpro": "D Pro (Canary)",
  "translate title": "\u7FFB\u8BD1\u9875\u9762\u6807\u9898",
  "always languages": "\u603B\u662F\u7FFB\u8BD1\u7684\u8BED\u8A00",
  neverTranslateLanguagesLabel: "\u6C38\u4E0D\u7FFB\u8BD1\u7684\u8BED\u8A00",
  neverTranslateTheFollowingLanguagesDescription: "\u5F53\u9875\u9762\u4E2D\u67D0\u4E00\u6BB5\u843D\u7684\u8BED\u8A00\u4E3A\u4E0B\u5217\u8BED\u8A00\u65F6\uFF0C\u4F1A\u81EA\u52A8\u8DF3\u8FC7\u7FFB\u8BD1\u8BE5\u6BB5\u843D",
  enableUserscriptPagePopup: "\u603B\u662F\u5728\u9875\u9762\u4E0A\u5C55\u793A Popup \u6D6E\u7A97",
  enableUserscriptPagePopupDescription: "\u5173\u95ED\u6D6E\u7A97\u540E\uFF0C\u53EF\u4EE5\u7528\u5FEB\u6377\u952E/{touch}\u5524\u8D77\u3002\u4E3A\u9632\u6B62\u4E0D\u614E\u5173\u95ED\u8BE5\u9009\u9879\u540E\u627E\u4E0D\u5230\u6D6E\u7A97\uFF0C\u5F3A\u70C8\u5EFA\u8BAE\u6536\u85CF\u672C\u8BBE\u7F6E\u9875",
  "always translate the following languages": "\u5F53\u9875\u9762\u8BED\u8A00\u4E3A\u4E0B\u5217\u8BED\u8A00\u65F6\uFF0C\u4F1A\u81EA\u52A8\u7FFB\u8BD1\u4E3A\u76EE\u6807\u8BED\u8A00",
  "always sites": "\u603B\u662F\u7FFB\u8BD1\u7684\u7F51\u5740",
  "always translate the following sites": "\u5F53\u7F51\u7AD9\u4E3A\u4E0B\u5217\u57DF\u540D\u65F6\uFF0C\u4F1A\u81EA\u52A8\u7FFB\u8BD1\u4E3A\u76EE\u6807\u8BED\u8A00",
  "never sites": "\u6C38\u4E0D\u7FFB\u8BD1\u7684\u7F51\u5740",
  "never translate the following sites": "\u5F53\u7F51\u7AD9\u4E3A\u4E0B\u5217\u57DF\u540D\u65F6\uFF0C\u5C06\u4E0D\u4F1A\u8FDB\u884C\u7FFB\u8BD1",
  "please refer to": "\u9700\u8981\u586B\u5199\u5BC6\u94A5\u540E\u624D\u53EF\u7528\uFF0C\u8BE6\u60C5\u53C2\u8003",
  KeyAndConfigurationTutorial: "\u300A\u5BC6\u94A5\u7533\u8BF7\u548C\u914D\u7F6E\u6559\u7A0B\u300B",
  useAboveStyleForTheseSites: "\u5F53\u524D\u9ED8\u8BA4\u8BD1\u6587\u6837\u5F0F\u4E3A\u300C{theme}\u300D\uFF0C\u4F60\u4E5F\u53EF\u4EE5\u8BBE\u7F6E\u4E3A\u8BA9\u67D0\u4E9B\u7F51\u7AD9\u4F7F\u7528\u8BE5\u6837\u5F0F\uFF0C\u70B9\u51FB\u53F3\u8FB9\u7684\u6309\u94AE\u6DFB\u52A0\u540E\uFF0C\u518D\u5207\u6362\u5230\u53E6\u4E00\u79CD\u9ED8\u8BA4\u8BD1\u6587\u6837\u5F0F\uFF0C\u8FD9\u6837\u5373\u53EF\u5B9E\u73B0\u4E0D\u540C\u7F51\u7AD9\u4F7F\u7528\u4E0D\u540C\u7684\u8BD1\u6587\u6837\u5F0F\u3002",
  currentUrl: "\u5F53\u524D\u7F51\u5740",
  confirm: "\u4FDD\u5B58",
  cancel: "\u53D6\u6D88",
  delete: "\u5220\u9664",
  "languages.auto": "\u81EA\u52A8\u68C0\u6D4B\u8BED\u8A00",
  syncToCloud: "\u540C\u6B65\u5230\u4E91\u7AEF",
  syncToCloudDescription: "\u5F00\u542F\u540E\u53EF\u4EE5\u5728\u4E0D\u540C\u7684\u6D4F\u89C8\u5668/\u6CB9\u7334\u811A\u672C\u4E4B\u95F4\u540C\u6B65\u914D\u7F6E,\u4EE5\u6700\u540E\u4FEE\u6539\u65F6\u95F4\u4E3A\u51C6\u3002",
  authFail: "\u6388\u6743\u5931\u8D25",
  syncTitle: "\u624B\u52A8\u5907\u4EFD\u7BA1\u7406",
  import_hint: "\u5BFC\u5165",
  upload: "\u4E0A\u4F20",
  revokeAuth: "\u64A4\u9500\u6388\u6743",
  uploadFail: "\u4E0A\u4F20\u5931\u8D25",
  download: "\u4E0B\u8F7D",
  importSuccess: "\u5BFC\u5165\u6210\u529F",
  importFail: "\u5BFC\u5165\u5931\u8D25",
  deleteFail: "\u5220\u9664\u5931\u8D25",
  isShowContextMenu: "\u521B\u5EFA\u53F3\u952E\u83DC\u5355",
  backupToCloud: "\u624B\u52A8\u7BA1\u7406\u5907\u4EFD\u6587\u4EF6",
  create_new_backup: "\u65B0\u589E\u5907\u4EFD\u8282\u70B9",
  maxBackupFiles: "\u6700\u591A\u53EF\u4EE5\u5907\u4EFD{count}\u4E2A\u4E0D\u540C\u7684\u8282\u70B9, \u8BF7\u5220\u9664\u4E0D\u9700\u8981\u7684\u8282\u70B9",
  backupToCloudDescription: "\u624B\u52A8\u4E0A\u4F20\u6216\u6062\u590D\u5907\u4EFD\u6587\u4EF6\uFF0C\u6700\u591A\u5141\u8BB83\u4E2A\u4E0D\u540C\u7684\u5907\u4EFD",
  successSyncConfig: "\u6210\u529F\u4E0E\u4E91\u7AEF\u4FDD\u6301\u540C\u6B65",
  syncFail: "\u540C\u6B65\u5931\u8D25",
  updatedAt: "\u66F4\u65B0\u4E8E {date}",
  lastSyncedAt: "\u4E0A\u6B21\u68C0\u67E5\u4E8E {date}",
  downloadFail: "\u4E0B\u8F7D\u5931\u8D25",
  clickToDownload: "\u70B9\u51FB\u4E0B\u8F7D",
  aboutLabel: "\u5173\u4E8E - \u53CD\u9988 - \u8D5E\u52A9",
  "browser.openAboutPage": "\u5173\u4E8E/\u53CD\u9988/\u8D5E\u52A9",
  aboutIntro: "\u8BE5\u6269\u5C55\u514D\u8D39\u4F7F\u7528\uFF0C\u5E0C\u671B\u6211\u4EEC\u90FD\u80FD\u66F4\u52A0\u5BB9\u6613\u4E14\u6109\u60A6\u5730\u83B7\u53D6\u4E92\u8054\u7F51\u4E0A\u5DE8\u5927\u7684\u5916\u8BED\u4FE1\u606F \u2764\uFE0F <br/><br/>\u611F\u8C22\u8FD9\u4E9B<1>\u8D5E\u52A9\u8005\u4EEC</1>, \u7531\u4E8E\u4ED6/\u5979\u4EEC\u7684\u652F\u6301\uFF0C\u66F4\u591A\u7684\u4EBA\u53EF\u4EE5\u514D\u8D39\u5730\u4F7F\u7528\u8FD9\u4E2A\u5DE5\u5177\u3002\u5982\u679C\u6709\u4F59\u529B\uFF0C\u4F60\u53EF\u4EE5<2>\u70B9\u51FB\u8FD9\u91CC\u8D5E\u52A9</2> \u6211\u7684\u5DE5\u4F5C\uFF0C\u4F60\u8FD8\u53EF\u4EE5\u5173\u6CE8\u6211\u7684<3>\u63A8\u7279</3>\uFF0C<4>Telegram \u9891\u9053</4>\u4EE5\u53CA\u4E0B\u65B9\u7684\u90AE\u4EF6\u8BA2\u9605\u8FFD\u8E2A\u66F4\u65B0\u3002",
  projectHomepage: "\u9879\u76EE\u4E3B\u9875",
  joinTelegramGroup: "\u52A0\u5165 Telegram \u7FA4\u53C2\u4E0E\u529F\u80FD\u8BA8\u8BBA",
  joinTelegramChannel: "\u5173\u6CE8 Telegram \u9891\u9053\u83B7\u53D6\u6700\u65B0\u66F4\u65B0",
  feedbackAndJoin: "\u95EE\u9898\u53CD\u9988/\u52A0\u7FA4",
  autoSync: "\u81EA\u52A8\u5B9A\u65F6\u540C\u6B65",
  loadingThemeTitle: "Loading \u6837\u5F0F",
  loadingThemeDescription: "\u8BBE\u7F6E\u7B49\u5F85\u8BD1\u6587\u52A0\u8F7D\u65F6\u7684\u6837\u5F0F",
  "loadingTheme.spinner": "\u8F6C\u5708\u52A8\u753B Spinner",
  "loadingTheme.text": "\u9759\u6001\u6587\u5B57 ... ",
  "loadingTheme.none": "\u4E0D\u663E\u793A",
  developerDescription: "\u53EF\u4EE5\u70B9\u51FB<1>\u8FD9\u91CC</1>\u67E5\u770B\u9AD8\u7EA7\u81EA\u5B9A\u4E49\u76F8\u5173\u7684\u6587\u6863",
  successSyncButNoChange: "\u5F53\u524D\u914D\u7F6E\u4E0E\u4E91\u7AEF\u4E00\u81F4"
};

// locales/zh-TW.json
var zh_TW_default = {
  lineBreakMaxTextCount: "\u63DB\u884C\u5F8C\uFF0C\u6BCF\u53E5\u8A71\u5141\u8A31\u7684\u6700\u5927\u5B57\u7B26\u6578\u91CF",
  "translate-pdf": "\u9EDE\u64CA\u7FFB\u8B6FPDF",
  "translate-firefox-local-pdf": "\u9EDE\u64CA\u4E0A\u50B3PDF",
  enableLineBreak: "\u662F\u5426\u958B\u5553\u9577\u6BB5\u843D\u81EA\u52D5\u63DB\u884C",
  sponsorLabel: "$1 \u8D77\u8D5E\u52A9\u5F00\u53D1\u8005 (\u6309\u6708\u6216\u4E00\u6B21\u6027\u5747\u53EF)",
  help: "\u5E6B\u52A9",
  browserShortcutsNoteForFirefox: "Firefox\u700F\u89BD\u5668\u4FEE\u6539\u5FEB\u6377\u9375\u9700\u8981\u6253\u958B\u64F4\u5C55\u7BA1\u7406\u9801\u9762`about:addons`\uFF0C\u7136\u5F8C\u9EDE\u64CA\u300C\u8A2D\u7F6E\u300D\uFF0C\u518D\u9EDE\u64CA\u300C\u7BA1\u7406\u5FEB\u6377\u9375\u300D\u5373\u53EF\u8A2D\u7F6E",
  browserShortcutsNoteForChrome: "\u985EChrome\u700F\u89BD\u5668\u4FEE\u6539\u5FEB\u7D50\u75C2\u9700\u8981\u6253\u958B\u64F4\u5C55\u7BA1\u7406\u9801\u9762\uFF0C\u5728\u2019\u7BA1\u7406\u5FEB\u6377\u9375\u2018\u9762\u677F\uFF08\u2019chrome://extensions/shortcuts\u2018\uFF09\u8A2D\u7F6E\uFF0C\u9EDE\u64CA\u4E0B\u65B9\u6309\u9215\u8DF3\u8F49\u5230\u5FEB\u6377\u9375\u7BA1\u7406\u9801\u9762\u3002",
  browserShortcutsSucks: "\u4FEE\u6539\u5FEB\u6377\u9375\u8ACB\u624B\u52D5\u8F38\u5165\uFF0C\u683C\u5F0F\u7232\uFF1A",
  enableLineBreakDescription: "\u958B\u5553\u5F8C\uFF0C\u8B1B\u6703\u5728\u9577\u77ED\u843D\u4E2D\u6BCF\u53E5\u8A71\u7D50\u675F\u63D2\u5165\u63DB\u884C\u7B26\uFF0C\u4EE5\u4FBF\u65BC\u95B1\u8B80",
  "browser.brandName": "\u6C89\u6D78\u5F0F\u7FFB\u8B6F",
  "browser.brandDescription": "\u6C89\u6D78\u5F0F\u7DB2\u9801\u96D9\u8A9E\u7FFB\u8B6F\u64F4\u5C55\uFF0C\u5B8C\u5168\u514D\u8CBB\u4F7F\u7528\uFF0C\u652F\u6301 Deepl/Google/\u9A30\u8A0A/\u706B\u5C71\u7FFB\u8B6F\u7B49\u591A\u500B\u7FFB\u8B6F\u670D\u52D9\uFF0C\u652F\u6301 Firefox/Chrome/\u6CB9\u7334\u8173\u672C\uFF0C\u4EA6\u53EF\u5728 iOS Safari \u4E0A\u4F7F\u7528\u3002",
  "browser.toggleTranslatePage": "\u7FFB\u8B6F\u7DB2\u9801/\u986F\u793A\u539F\u6587",
  "browser.toggleTranslateTheWholePage": "\u7FFB\u8B6F\u9801\u9762\u5168\u90E8\u5340\u57DF/\u986F\u793A\u539F\u6587",
  "browser.toggleTranslateToThePageEndImmediately": "\u7ACB\u5373\u7FFB\u8B6F\u5230\u9801\u9762\u5E95\u90E8/\u986F\u793A\u539F\u6587",
  "browser.toggleTranslateTheMainPage": "\u7FFB\u8B6F\u9801\u9762\u4E3B\u8981\u5340\u57DF/\u986F\u793A\u539F\u6587",
  "browser.openOptionsPage": "\u6253\u958B\u8A2D\u7F6E\u9801",
  "browser.toggleTranslationMask": "\u663E\u793A/\u9690\u85CF\u8BD1\u6587\u6A21\u7CCA\u6548\u679C",
  "browser.translateLocalPdfFile": "\u7FFB\u8B6F\u672C\u5730 PDF \u6587\u4EF6",
  confirmResetConfig: "\u4F60\u78BA\u5B9A\u8981\u91CD\u8F09\u8A2D\u7F6E\u55CE?",
  translationLineBreakSettingTitle: "\u8BD1\u6587\u6362\u884C\u8BBE\u7F6E",
  smartLineBreak: "\u667A\u80FD\u6362\u884C",
  alwaysLineBreak: "\u603B\u662F\u6362\u884C",
  toggleBeta: "\u5F00\u542F Beta \u6D4B\u8BD5\u7279\u6027",
  betaDescription: "\u5F00\u542F\u540E\u4F1A\u542F\u7528\u4E00\u4E9B\u5B9E\u9A8C\u6027\u529F\u80FD\uFF0C\u4EE5\u53CA\u8FD8\u5728\u6D4B\u8BD5\u4E2D\u7684\u7FFB\u8BD1\u670D\u52A1, \u53EF\u4EE5<1>\u52A0Telegram \u7FA4\u7EC4</1>\u4E86\u89E3\u66F4\u591A\u5185\u6D4B\u7684\u7279\u6027\u3002",
  translationLineBreakSettingDescription: "\u5BF9\u4E8E\u8BD1\u6587\u7684\u4F4D\u7F6E\uFF1A\u603B\u662F\u6362\u884C/\u667A\u80FD\u6362\u884C\uFF08\u5F53\u6BB5\u843D\u591A\u4E8E{count}\u4E2A\u5B57\u7B26\u624D\u6362\u884C\u663E\u793A\u8BD1\u6587\uFF09",
  tempTranslateDomainTitle: "\u4E34\u65F6\u5F00\u542F\u7F51\u7AD9\u7FFB\u8BD1\u7684\u65F6\u957F",
  tempTranslateDomainDescription: "\u5F53\u624B\u52A8\u7FFB\u8BD1\u67D0\u4E2A\u7F51\u9875\u7684\u65F6\u5019\uFF0C\u4E34\u65F6\u5F00\u542F\u8BE5\u7F51\u7AD9\u4E3A\u81EA\u52A8\u7FFB\u8BD1",
  xMinutes: "{count} \u5206\u949F",
  disabled: "\u505C\u7528",
  changelog: "\u66F4\u65B0\u65E5\u8A8C",
  toggleTranslatePageWhenThreeFingersOnTheScreen: "\u4E09\u6307\u540C\u65F6\u89E6\u6478\u5C4F\u5E55\u7FFB\u8BD1\u7F51\u9875/\u663E\u793A\u539F\u6587",
  addUrlDescription: "\u53EF\u4EE5\u4E3A\u57DF\u540D\uFF0C\u540C\u65F6\u652F\u6301\u901A\u914D\u7B26\uFF0C\u5982\uFF1A*.google.com, google.com/mail/*, https://www.google.com/*",
  general: "\u57FA\u672C\u8A2D\u7F6E",
  clickToExpandConfig: "\u5C55\u5F00\u5F53\u524D\u914D\u7F6E",
  import: "\u4ECE\u6587\u4EF6\u5BFC\u5165\u914D\u7F6E",
  export: "\u5BFC\u51FA\u5230\u6587\u4EF6",
  toggleDebug: "\u5728\u63A7\u5236\u6AAF\u6253\u5370\u8ABF\u8A66\u65E5\u8A8C",
  "fingers.0": "\u5173\u95ED",
  "fingers.2": "\u53CC\u6307\u89E6\u6478",
  "fingers.3": "\u4E09\u6307\u89E6\u6478",
  "fingers.4": "\u56DB\u6307\u89E6\u6478",
  "fingers.5": "\u4E94\u6307\u89E6\u6478",
  document: "\u6587\u6A94",
  resetSuccess: "\u885D\u7F6E\u6240\u6709\u8A2D\u7F6E\u6210\u529F",
  saved: "\u6210\u529F\u5132\u5B58",
  successImportConfig: "\u6210\u529F\u532F\u5165\u8A2D\u5B9A",
  goAdvancedSettings: "\u53BB\u9032\u968E\u8A2D\u7F6E\u9801",
  goAdvancedInterfaceSettings: "\u53BB\u9AD8\u7EA7\u81EA\u5B9A\u4E49\u8BBE\u7F6E\u9875\u9762",
  advanced: "\u9032\u968E\u8A2D\u7F6E",
  advancedDescription: "\u4E00\u4E9B\u96E3\u4EE5\u7406\u89E3\u7684\u8A2D\u7F6E\u9805\uFF08\u4E00\u822C\u7121\u9700\u8A2D\u7F6E\uFF0C\u4FDD\u6301\u9ED8\u8A8D\u5373\u53EF\uFF09",
  developer: "\u958B\u767C\u8005\u8A2D\u7F6E",
  donateCafe: "\u8ACB\u958B\u767C\u8005\u559D\u676F\u5496\u5561",
  "translate to the bottom of the page": "\u6253\u958B\u7DB2\u9801\u5F8C\uFF0C\u662F\u5426\u7ACB\u5373\u7FFB\u8B6F\u5230\u9801\u9762\u5E95\u90E8\uFF1F",
  feedback: "\u554F\u984C\u53CD\u994B",
  toggleTranslatePage: "\u7FFB\u8B6F\u7DB2\u9801/\u986F\u793A\u539F\u6587",
  translateToThePageEndImmediatelyDescription: "\u958B\u5553\u5F8C\uFF0C\u5C07\u6703\u7ACB\u5373\u7FFB\u8B6F\u7DB2\u9801\u5F9E\u9802\u90E8\u5230\u5E95\u90E8\u7684\u5167\u5BB9\uFF0C\u800C\u4E0D\u662F\u908A\u770B\u908A\u8B6F\u3002\uFF08\u4E0D\u63A8\u85A6\u958B\u5553\uFF09",
  "translate all areas of the page": "\u662F\u5426\u7FFB\u8B6F\u7DB2\u9801\u6240\u6709\u5340\u57DF",
  translationAreaDescription: "\u958B\u5553\u5F8C\uFF0C\u6574\u500B\u7DB2\u9801\u7684\u5340\u57DF\u90FD\u6703\u88AB\u7FFB\u8B6F\uFF0C\u800C\u4E0D\u662F\u9ED8\u8A8D\u7684\u667A\u80FD\u8B58\u5225\u4E3B\u8981\u5340\u57DF\u53BB\u7FFB\u8B6F\uFF08\u4E0D\u63A8\u85A6\u958B\u5553\uFF09",
  "the number of characters to be translated first": "\u524D\u591A\u5C11\u500B\u5B57\u7B26\u7121\u9700\u7B49\u5F85\u6EFE\u52D5\u5230\u53EF\u8996\u5340\u57DF\uFF0C\u76F4\u63A5\u7FFB\u8B6F\uFF1F",
  "interface language": "\u754C\u9762\u8A9E\u8A00",
  "display both the original text and the translation": "\u540C\u6642\u986F\u793A\u539F\u6587\u548C\u8B6F\u6587",
  "keyboard shortcuts": "\u9375\u76E4\u5FEB\u6377\u9375",
  modify: "\u4FEE\u6539\u5FEB\u6377\u9375",
  reset: "\u91CD\u8A2D",
  close: "\u95DC\u9589",
  homepage: "\u4E3B\u9801",
  more: "\u66F4\u591A",
  translateTheWholePage: "\u7FFB\u8B6F\u9801\u9762\u5168\u90E8\u5340\u57DF\uFF08\u5340\u5206\u65BC\u53EA\u7FFB\u8B6F\u4E3B\u8981\u5340\u57DF\uFF09",
  changeToTranslateTheWholePage: "\u5207\u6362\u4E3A\u7FFB\u8BD1\u9875\u9762\u6240\u6709\u533A\u57DF",
  changeToTranslateTheMainPage: "\u5207\u6362\u4E3A\u667A\u80FD\u7FFB\u8BD1\u4E3B\u8981\u533A\u57DF",
  translateToThePageEndImmediately: "\u7ACB\u5373\u7FFB\u8B6F\u5230\u5E95\u90E8\uFF08\u5340\u5206\u65BC\u770B\u54EA\u8B6F\u54EA\uFF09",
  translateTheMainPage: "\u667A\u80FD\u7FFB\u8B6F\u4E3B\u8981\u5340\u57DF",
  "The local rules are up to date": "\u672C\u5730\u9069\u914D\u898F\u5247\u5DF2\u662F\u6700\u65B0\uFF1A",
  "Successfully synchronized with the latest official rules:": "\u6210\u529F\u540C\u6B65\u6700\u65B0\u5B98\u65B9\u9069\u914D\u898F\u5247\uFF1A",
  "Checking for updates": "\u6B63\u5728\u6AA2\u67E5\u66F4\u65B0",
  "Rules are being synchronized": "\u6B63\u5728\u540C\u6B65\u9069\u914D\u898F\u5247",
  localVersionIsTooOld: "\u672C\u5730\u64F4\u5C55\u7248\u672C\u904E\u820A\uFF0C\u8ACB\u5347\u7D1A\u64F4\u5C55\u5230{minVersion} \u6216\u4E4B\u5F8C\u7684\u7248\u672C\u5F8C\u518D\u5617\u8A66\u540C\u6B65",
  badUserscriptBrowser: "\u8BE5\u6D4F\u89C8\u5668\u672A\u6B63\u786E\u5B9E\u73B0\u6CB9\u7334\u7684\u63A5\u53E3\uFF0C\u8BF7\u4F7F\u7528\u5176\u4ED6<1>\u652F\u6301\u6CB9\u7334</1>\u7684\u6D4F\u89C8\u5668\u5982(Firefox Nightly \u7248\u672C)",
  foundNewVersion: "\u767C\u73FE\u65B0\u7248\u672C",
  theLocalExtensionIsUpToUpdate: "\u7576\u524D\u64F4\u5C55\u5DF2\u662F\u6700\u65B0\u7248\u672C",
  failToSyncRules: "\u540C\u6B65\u6700\u65B0\u9069\u914D\u898F\u5247\u5931\u6557",
  retry: "\u9EDE\u6B64\u885D\u8A66",
  failedReason: "\u5931\u6557\u539F\u56E0",
  currentRuleVersion: "\u7576\u524D\u898F\u5247\u7248\u672C",
  calculating: "\u8A08\u7B97\u4E2D",
  unknownError: "\u672A\u77E5\u932F\u8AA4",
  canNotFetchRemoteRule: "\u7121\u6CD5\u7372\u53D6\u9060\u7A0B\u898F\u5247",
  enableAlphaSuccess: "\u5DF2\u958B\u5553Alpha\u529F\u80FD",
  disableAlphaSuccess: "\u5DF2\u95DC\u9589Alpha\u529F\u80FD",
  cacheSize: "\u7DE9\u5B58\u5927\u5C0F\uFF1A",
  cleaning: "\u6E05\u7406\u4E2D",
  cleanCache: "\u6E05\u9664\u7DE9\u5B58",
  options: "\u9078\u9805",
  about: "\u95DC\u65BC",
  service: "\u7FFB\u8B6F\u670D\u52D9",
  needAction: "\uFF08\u53BB\u8A2D\u7F6E\uFF09",
  goSettings: "\u53BB\u8A2D\u7F6E",
  needActionForOptions: "\uFF08\u53BB\u8A2D\u7F6E\uFF09",
  translationEngine: "\u5F15\u64CE\u9078\u9805",
  sourceLanguage: "\u539F\u6587\u8A9E\u8A00",
  target: "\u76EE\u6A19\u8A9E\u8A00",
  popupSourceLanguage: "\u539F\u6587\u8A9E\u8A00",
  popupTarget: "\u76EE\u6A19\u8A9E\u8A00",
  popupService: "\u7FFB\u8B6F\u670D\u52D9",
  forThisSite: "\u5C0D\u65BC\u8A72\u7DB2\u7AD9\uFF1A",
  alwaysTranslateSomeLanguage: "\u7E3D\u662F\u7FFB\u8B6F{language}",
  neverTranslateSomeLanguage: "\u6C38\u4E0D\u7FFB\u8B6F{language}",
  alwaysTranslateSomeSite: "\u7E3D\u662F\u7FFB\u8B6F {hostname}",
  neverTranslateSomeSite: "\u6C38\u4E0D\u7FFB\u8B6F {hostname}",
  add: "\u589E\u52A0",
  default: "\u9ED8\u8A8D",
  forThisLanguage: "\u5C0D\u65BC\u8A72\u8A9E\u8A00\uFF1A",
  "add url": "\u8F38\u5165URL",
  edit: "\u7DE8\u8F2F",
  "translate other languages into specific language": "\u5C07\u5176\u4ED6\u8A9E\u8A00\u7FFB\u8B6F\u70BA\u4F60\u8A2D\u7F6E\u7684\u8A9E\u8A00",
  "select translation service": "\u9078\u64C7\u4E00\u9805\u7FFB\u8B6F\u670D\u52D9",
  language: "\u8A9E\u8A00",
  "show-original": "\u986F\u793A\u539F\u6587",
  translate: "\u7FFB\u8B6F",
  Translated: "\u5DF2\u7FFB\u8B6F",
  Translating: "\u7FFB\u8B6F\u4E2D",
  Error: "\u932F\u8AA4",
  allowCacheTranslations: "\u958B\u555F\u672C\u5730\u7FFB\u8B6F\u7DE9\u5B58\uFF08\u6E1B\u5C11\u91CD\u8907\u6BB5\u843D\u7684\u7FFB\u8B6F\u8ACB\u6C42\uFF09",
  "translation display": "\u8B6F\u6587\u986F\u793A\u6A23\u5F0F",
  "select diplay style": "\u5340\u5206\u8B6F\u6587\u7684\u6A23\u5F0F\uFF0C\u5177\u9AD4\u53EF\u53C3\u8003\u4E0B\u5217\u793A\u4F8B",
  interface: "\u754C\u9762\u8A2D\u7F6E",
  import_export: "\u5C0E\u5165/\u5C0E\u51FA",
  import_export_title: "\u5C0E\u5165/\u5C0E\u51FA",
  syncToGoogleDrive: "\u7ACB\u5373\u4E0E Google Drive \u540C\u6B65",
  previewAllThemes: "\u9810\u89BD\u5168\u90E8\u6A23\u5F0F",
  "translationTheme.none": "\u7121",
  "translationTheme.dashed": "\u865B\u7DDA\u4E0B\u5283\u7DDA",
  "translationTheme.dotted": "\u9EDE\u72C0\u4E0B\u5283\u7DDA",
  "translationTheme.dashedBorder": "\u865B\u7DDA\u908A\u6846",
  "translationTheme.underline": "\u76F4\u7DDA\u4E0B\u5283\u7DDA",
  "translationTheme.mask": "\u6A21\u7CCA\u6548\u679C",
  "translationTheme.paper": "\u767D\u7D19\u9670\u5F71\u6548\u679C",
  "translationTheme.dividingLine": "\u5206\u5272\u7DDA",
  "translationTheme.highlight": "\u9AD8\u4EAE",
  "translationTheme.marker": "\u99AC\u514B\u7B46",
  "translationTheme.blockquote": "\u5F15\u7528\u6A23\u5F0F",
  "translationTheme.weakening": "\u5F31\u5316",
  "translationTheme.italic": "\u659C\u9AD4",
  "translationTheme.bold": "\u7C97\u9AD4",
  "translationTheme.thinDashed": "\u7D30\u865B\u7DDA\u4E0B\u5283\u7DDA",
  "translationTheme.nativeDashed": "\u7CFB\u7EDF\u81EA\u5E26\u865A\u7EBF\u4E0B\u5212\u7EBF",
  "translationTheme.nativeDotted": "\u7CFB\u7EDF\u81EA\u5E26\u70B9\u72B6\u4E0B\u5212\u7EBF",
  "translationTheme.nativeUnderline": "\u7CFB\u7EDF\u81EA\u5E26\u76F4\u7EBF\u4E0B\u5212\u7EBF",
  "translationTheme.wavy": "\u6CE2\u6D6A\u7DDA",
  "translationServices.tencent": "\u9A30\u8A0A\u7FFB\u8B6F\u541B",
  "translationServices.google": "\u8C37\u6B4C\u7FFB\u8B6F",
  "translationServices.bai": "\u767E\u5EA6\uFF08Alpha\uFF09",
  "translationServices.baidu": "\u767E\u5EA6\u7FFB\u8B6F",
  "translationServices.aliyun": "\u963F\u91CC\u96F2\u7FFB\u8B6F",
  "translationServices.volc": "\u706B\u5C71\u7FFB\u8B6F",
  "translationServices.deeplx": "DeeplX(Alpha)",
  "translationServices.bing": "\u5FC5\u61C9\u7FFB\u8B6F",
  "translationServices.deepl": "Deepl",
  "translationServices.wechat": "\u5FAE\u4FE1\u7FFB\u8B6F",
  "translationServices.azure": "\u5FAE\u8EDF\u7FFB\u8B6F",
  "translationServices.ibm": "IBM Watson",
  "translationServices.aws": "\u4E9E\u99AC\u905C\u7FFB\u8B6F",
  "translationServices.mock": "\u6A21\u64EC\u7FFB\u8B6F",
  "translationServices.mock2": "\u6A21\u64EC\u7FFB\u8B6F2",
  "translationServices.caiyun": "\u5F69\u96F2\u5C0F\u8B6F",
  "translationServices.volcAlpha": "\u706B\u5C71\u7FFB\u8B6F(Alpha)",
  "translationServices.openl": "OpenL",
  "translationServices.youdao": "\u6709\u9053\u7FFB\u8B6F",
  "translationServices.transmart": "\u9A30\u8A0A\u4EA4\u4E92\u7FFB\u8B6F",
  "translationServices.niu": "\u5C0F\u725B\u7FFB\u8B6F",
  "translationServices.d": "Deepl(Alpha)",
  "translate title": "\u7FFB\u8B6F\u9801\u9762\u6A19\u984C",
  "always languages": "\u7E3D\u662F\u7FFB\u8B6F\u7684\u8A9E\u8A00",
  neverTranslateLanguagesLabel: "\u6C38\u4E0D\u7FFB\u8B6F\u7684\u7DB2\u5740",
  neverTranslateTheFollowingLanguagesDescription: "\u5F53\u9875\u9762\u4E2D\u67D0\u4E00\u6BB5\u843D\u7684\u8BED\u8A00\u4E3A\u4E0B\u5217\u8BED\u8A00\u65F6\uFF0C\u4F1A\u81EA\u52A8\u8DF3\u8FC7\u7FFB\u8BD1\u8BE5\u6BB5\u843D",
  enableUserscriptPagePopup: "\u603B\u662F\u5728\u9875\u9762\u4E0A\u5C55\u793A Popup \u6D6E\u7A97",
  enableUserscriptPagePopupDescription: "\u5173\u95ED\u6D6E\u7A97\u540E\uFF0C\u53EF\u4EE5\u7528\u5FEB\u6377\u952E/\u4E09\u6307\u89E6\u5C4F\u5524\u8D77\u3002\u4E3A\u9632\u6B62\u4E0D\u614E\u5173\u95ED\u8BE5\u9009\u9879\u540E\u627E\u4E0D\u5230\u6D6E\u7A97\uFF0C\u5F3A\u70C8\u5EFA\u8BAE\u6536\u85CF\u672C\u8BBE\u7F6E\u9875",
  "always translate the following languages": "\u7576\u9801\u9762\u8A9E\u8A00\u70BA\u4E0B\u5217\u8A9E\u8A00\u6642\uFF0C\u6703\u81EA\u52D5\u7FFB\u8B6F\u70BA\u76EE\u6A19\u8A9E\u8A00",
  "always sites": "\u7E3D\u662F\u7FFB\u8B6F\u7684\u7DB2\u5740",
  "always translate the following sites": "\u7576\u7DB2\u7AD9\u70BA\u4E0B\u5217\u57DF\u540D\u6642\uFF0C\u6703\u81EA\u52D5\u7FFB\u8B6F\u70BA\u76EE\u6A19\u8A9E\u8A00",
  "never sites": "\u6C38\u4E0D\u7FFB\u8B6F\u7684\u7DB2\u5740",
  "never translate the following sites": "\u7576\u7DB2\u7AD9\u70BA\u4E0B\u5217\u57DF\u540D\u6642\uFF0C\u5C07\u4E0D\u6703\u9032\u884C\u7FFB\u8B6F",
  "please refer to": "\u9700\u8981\u586B\u5BEB\u5BC6\u9470\u5F8C\u624D\u53EF\u7528\uFF0C\u8A73\u60C5\u53C3\u8003",
  KeyAndConfigurationTutorial: "\u300A\u5BC6\u9470\u7533\u8ACB\u548C\u914D\u7F6E\u6559\u7A0B\u300B",
  useAboveStyleForTheseSites: "\u7576\u524D\u9ED8\u8A8D\u8B6F\u6587\u6A23\u5F0F\u70BA\u300C{theme}\u300D\uFF0C\u4F60\u4E5F\u53EF\u4EE5\u8A2D\u7F6E\u70BA\u8B93\u67D0\u4E9B\u7DB2\u7AD9\u4F7F\u7528\u8A72\u6A23\u5F0F\uFF0C\u9EDE\u64CA\u53F3\u908A\u7684\u6309\u9215\u6DFB\u52A0\u5F8C\uFF0C\u518D\u5207\u63DB\u5230\u53E6\u4E00\u7A2E\u9ED8\u8A8D\u8B6F\u6587\u6A23\u5F0F\uFF0C\u9019\u6A23\u5373\u53EF\u5BE6\u73FE\u4E0D\u540C\u7DB2\u7AD9\u4F7F\u7528\u4E0D\u540C\u7684\u8B6F\u6587\u6A23\u5F0F\u3002",
  currentUrl: "\u7576\u524D\u7DB2\u5740",
  confirm: "\u5132\u5B58",
  cancel: "\u53D6\u6D88",
  delete: "\u522A\u9664",
  "languages.auto": "\u81EA\u52D5\u5075\u6E2C\u8A9E\u8A00",
  isShowContextMenu: "\u5275\u5EFA\u53F3\u9375\u83DC\u55AE",
  syncToCloud: "\u540C\u6B65\u5230\u96F2\u7AEF",
  syncToCloudDescription: "\u540C\u6B65\u65F6\u4F1A\u6BD4\u8F83\u672C\u5730\u548C\u4E91\u7AEF\u914D\u7F6E\u7684\u6700\u540E\u4FEE\u6539\u65F6\u95F4\uFF0C\u4EE5\u6700\u540E\u4FEE\u6539\u65F6\u95F4\u4E3A\u51C6\u3002",
  authFail: "\u6388\u6B0A\u5931\u6557",
  syncTitle: "\u8ACB\u9078\u64C7\u6587\u4EF6\u64CD\u4F5C",
  import_hint: "\u5C0E\u5165",
  upload: "\u4E0A\u50B3",
  revokeAuth: "\u64A4\u92B7\u6388\u6B0A",
  uploadFail: "\u4E0A\u50B3\u5931\u6557",
  download: "\u4E0B\u8F09",
  importSuccess: "\u5C0E\u5165\u6210\u529F",
  importFail: "\u5C0E\u5165\u5931\u6557",
  deleteFail: "\u522A\u9664\u5931\u6557",
  backupToCloud: "\u624B\u52D5\u7BA1\u7406\u5099\u4EFD\u6587\u4EF6",
  create_new_backup: "\u65B0\u589E\u5099\u4EFD\u7BC0\u9EDE",
  maxBackupFiles: "\u6700\u591A\u53EF\u4EE5\u5099\u4EFD{count}\u500B\u4E0D\u540C\u7684\u7BC0\u9EDE, \u8ACB\u522A\u9664\u4E0D\u9700\u8981\u7684\u7BC0\u9EDE",
  backupToCloudDescription: "\u624B\u52D5\u4E0A\u50B3\u6216\u6062\u5FA9\u5099\u4EFD\u6587\u4EF6\uFF0C\u6700\u591A\u5141\u8A313\u500B\u4E0D\u540C\u7684\u5099\u4EFD",
  successSyncConfig: "\u6210\u529F\u8207\u96F2\u7AEF\u4FDD\u6301\u540C\u6B65",
  syncFail: "\u540C\u6B65\u5931\u6557",
  updatedAt: "\u66F4\u65B0\u65BC {date}",
  lastSyncedAt: "\u4E0A\u6B21\u6AA2\u67E5\u65BC {date}",
  downloadFail: "\u4E0B\u8F09\u5931\u6557",
  clickToDownload: "\u9EDE\u64CA\u4E0B\u8F09",
  aboutLabel: "\u95DC\u65BC - \u53CD\u994B - \u8D0A\u52A9",
  "browser.openAboutPage": "\u95DC\u65BC/\u53CD\u994B/\u8D0A\u52A9",
  aboutIntro: "\u8A72\u64F4\u5C55\u5B8C\u5168\u514D\u8CBB\u4F7F\u7528\uFF0C\u5E0C\u671B\u6211\u5011\u90FD\u80FD\u66F4\u52A0\u5BB9\u6613\u4E14\u6109\u6085\u5730\u7372\u53D6\u4E92\u806F\u7DB2\u4E0A\u5DE8\u5927\u7684\u5916\u8A9E\u4FE1\u606F \u2764\uFE0F <br/><br/>\u611F\u8B1D\u9019\u4E9B<1>\u8D0A\u52A9\u8005\u5011</1>, \u7531\u65BC\u4ED6/\u5979\u5011\u7684\u652F\u6301\uFF0C\u66F4\u591A\u7684\u4EBA\u53EF\u4EE5\u5B8C\u5168\u514D\u8CBB\u5730\u4F7F\u7528\u9019\u500B\u5DE5\u5177\u3002\u5982\u679C\u6709\u9918\u529B\uFF0C\u4F60\u53EF\u4EE5<2>\u9EDE\u64CA\u9019\u88E1\u8D0A\u52A9</2> \u6211\u7684\u5DE5\u4F5C\uFF0C\u4F60\u9084\u53EF\u4EE5\u95DC\u6CE8\u6211\u7684<3>\u63A8\u7279</3>\u548C<4>Telegram \u983B\u9053</4>\u7372\u53D6\u6700\u65B0\u66F4\u65B0\u3002",
  projectHomepage: "\u9805\u76EE\u4E3B\u9801",
  joinTelegramGroup: "\u52A0\u5165 Telegram \u7FA4\u53C3\u8207\u529F\u80FD\u8A0E\u8AD6",
  feedbackAndJoin: "\u554F\u984C\u53CD\u994B/\u52A0\u7FA4",
  autoSync: "\u81EA\u52D5\u5B9A\u6642\u540C\u6B65",
  loadingThemeTitle: "Loading \u6A23\u5F0F",
  loadingThemeDescription: "\u8A2D\u7F6E\u7B49\u5F85\u8B6F\u6587\u52A0\u8F09\u6642\u7684\u6A23\u5F0F",
  "loadingTheme.spinner": "\u8F49\u5708\u52D5\u756B Spinner",
  "loadingTheme.text": "\u975C\u614B\u6587\u5B57 ... ",
  "loadingTheme.none": "\u4E0D\u986F\u793A",
  developerDescription: "\u53EF\u4EE5\u70B9\u51FB<1>\u8FD9\u91CC</1>\u67E5\u770B\u9AD8\u7EA7\u81EA\u5B9A\u4E49\u76F8\u5173\u7684\u6587\u6863"
};

// locales/en.json
var en_default = {
  lineBreakMaxTextCount: "Maximum number of characters allowed per sentence after line break",
  "translate-pdf": "Click to translate PDF",
  "translate-firefox-local-pdf": "Click to upload Pdf",
  enableLineBreak: "Whether to turn on automatic line wrapping for long paragraphs",
  sponsorLabel: "Sponsoring developers from $1 (monthly or one-time)",
  help: "Help",
  browserShortcutsNoteForFirefox: `To modify the shortcut key in Firefox browser, you need to open the extension management page 'about: addons', then click "Settings", and then click "Management shortcut key" to set it`,
  browserShortcutsNoteForChrome: "To modify the shortcut key in Chrome browser, you need to open the extension management page` chrome://extensions/shortcuts `) Settings, click the button below to jump to the shortcut key management page.",
  browserShortcutsSucks: "Please enter the shortcut key manually in the format:",
  enableLineBreakDescription: "After opening, a line break will be inserted at the end of each sentence in a long paragraph for easy reading",
  "browser.brandName": "Immersive Translate",
  "browser.brandDescription": "Web bilingual translation, completely free to use, supports Deepl/Google/Bing/Tencent/Youdao, etc. it also works on iOS Safari.",
  "browser.toggleTranslatePage": "Toggle translate webpage ",
  "browser.toggleTranslateTheWholePage": "Toggle translate the whole page",
  "browser.toggleTranslateToThePageEndImmediately": "Toggle translate to the bottom of the page immediately",
  "browser.toggleTranslateTheMainPage": "Toggle translate the main page",
  "browser.openOptionsPage": "Open Settings Page",
  "browser.toggleTranslationMask": "Toggle translation mask style",
  "browser.translateLocalPdfFile": "Translate local PDF files",
  confirmResetConfig: "Are you sure you want to reset the settings?",
  translationLineBreakSettingTitle: "Line break setting",
  smartLineBreak: "Smart Wrap",
  alwaysLineBreak: "Always Wrap",
  toggleBeta: "\u5F00\u542F Beta \u6D4B\u8BD5\u7279\u6027",
  betaDescription: "\u5F00\u542F\u540E\u4F1A\u542F\u7528\u4E00\u4E9B\u5B9E\u9A8C\u6027\u529F\u80FD\uFF0C\u4EE5\u53CA\u8FD8\u5728\u6D4B\u8BD5\u4E2D\u7684\u7FFB\u8BD1\u670D\u52A1, \u53EF\u4EE5<1>\u52A0Telegram \u7FA4\u7EC4</1>\u4E86\u89E3\u66F4\u591A\u5185\u6D4B\u7684\u7279\u6027\u3002",
  translationLineBreakSettingDescription: "The position of the translation\uFF1AAlways wrap / smart wrap (the translation is displayed only when the paragraph is more than {count} characters)",
  tempTranslateDomainTitle: "Open the translation time temporarily",
  tempTranslateDomainDescription: "When a page is translated manually, turn it temporarily on as automatic translation",
  xMinutes: "{count} minutes",
  disabled: "Disable",
  changelog: "Change Log",
  toggleTranslatePageWhenThreeFingersOnTheScreen: "\u4E09\u6307\u540C\u65F6\u89E6\u6478\u5C4F\u5E55\u7FFB\u8BD1\u7F51\u9875/\u663E\u793A\u539F\u6587",
  addUrlDescription: "The domain name is available and wildcard is supported e.g.\uFF1A*.google.com, google.com/mail/*, https://www.google.com/*",
  general: "General",
  clickToExpandConfig: "Expand current configuration",
  import: "Import configuration from file",
  export: "Export to file",
  toggleDebug: "Print debug logs on the console",
  "fingers.0": "Close",
  "fingers.2": "Two-finger touch",
  "fingers.3": "Three-finger touch",
  "fingers.4": "Four-finger touch",
  "fingers.5": "Five-finger touch",
  document: "Document",
  resetSuccess: "All settings reset successful",
  saved: "Saved successfully",
  successImportConfig: "Configuration imported successfully",
  goAdvancedSettings: "Go to Advanced Settings Page",
  goAdvancedInterfaceSettings: "Go to Advanced Custom Settings Page",
  advanced: "Advanced",
  advancedDescription: "Some unintelligible settings (normally set without setting to default)",
  developer: "Developer settings",
  donateCafe: "Buy Me a Coffee",
  "translate to the bottom of the page": "Whether translate to the bottom of the page once you open the page?",
  feedback: "Feedback",
  toggleTranslatePage: "Toggle Translate",
  translateToThePageEndImmediatelyDescription: "When turned on, it will immediately translate the page from the top to the bottom, instead of translating as you read. (Not recommended to turn on)",
  "translate all areas of the page": "Whether to translate all areas of the web page",
  translationAreaDescription: "When enabled, the entire area of the page will be translated, not the default intelligent recognition main area to translate ( not recommended)",
  "the number of characters to be translated first": "How many characters are translated directly without waiting to scroll to the visible area for the first few characters?",
  "interface language": "Interface language",
  "display both the original text and the translation": "Display both the original text and the translation",
  "keyboard shortcuts": "Keyboard shortcuts",
  modify: "Edit",
  reset: "Reset",
  close: "Close",
  homepage: "Home Page",
  more: "More",
  translateTheWholePage: "Translate the whole page area (different from only the main area)",
  changeToTranslateTheWholePage: "\u5207\u6362\u4E3A\u7FFB\u8BD1\u9875\u9762\u6240\u6709\u533A\u57DF",
  changeToTranslateTheMainPage: "\u5207\u6362\u4E3A\u667A\u80FD\u7FFB\u8BD1\u4E3B\u8981\u533A\u57DF",
  translateToThePageEndImmediately: "Immediately translate to the bottom (different from translating the current visible area)",
  translateTheMainPage: "Main areas of intelligent translation",
  "The local rules are up to date": "Local  rules are up to date:",
  "Successfully synchronized with the latest official rules:": "Successfully synced latest official rules:",
  "Checking for updates": "Checking for update",
  "Rules are being synchronized": "Syncing official rules",
  localVersionIsTooOld: "The local extension is too old. Please upgrade to {minVersion} or then try syncing again",
  badUserscriptBrowser: "This browser does not correctly implement the interface of Tampermonkey. Please use other < 1 > browsers that support Tampermonkey < / 1 >, such as (Firefox Nightly version)",
  foundNewVersion: "New version available",
  theLocalExtensionIsUpToUpdate: "The current extension version is up to date.",
  failToSyncRules: "Failed to sync latest adaptive rules",
  retry: "Retry",
  failedReason: "Failure reason",
  currentRuleVersion: "Current Rule Version",
  calculating: "Calculating",
  unknownError: "Unknown Error",
  canNotFetchRemoteRule: "Unable to fetch remote rule",
  enableAlphaSuccess: "Alpha enabled successfully",
  disableAlphaSuccess: "Alpha has been disabled",
  cacheSize: "Cache size:",
  cleaning: "Cleaning",
  cleanCache: "Clear cache",
  options: "Options",
  about: "About",
  service: "Translation Service",
  needAction: "(to set up)",
  goSettings: "to set up",
  needActionForOptions: "(need to set)",
  translationEngine: "Engine Options",
  sourceLanguage: "Original language",
  target: "Target Language",
  popupSourceLanguage: "Source",
  popupTarget: "Target",
  popupService: "Service",
  forThisSite: "For This Site:",
  alwaysTranslateSomeLanguage: "Always translate {language}",
  neverTranslateSomeLanguage: "Never translate {language}",
  alwaysTranslateSomeSite: "Always translate {hostname}",
  neverTranslateSomeSite: "Never translate {hostname}",
  add: "Add",
  default: "Default",
  forThisLanguage: "For This Language:",
  "add url": "Add URL",
  edit: "Edit",
  "translate other languages into specific language": "Translate other languages into the language you set",
  "select translation service": "Select a translation service",
  language: "Language",
  "show-original": "Show Original",
  translate: "Translate",
  Translated: "Translated",
  Translating: "Translating",
  Error: "Error",
  allowCacheTranslations: "Enable local translation caching (reduce translation requests for duplicate paragraphs)",
  "translation display": "Translation display style",
  "select diplay style": "Please refer to the following examples",
  interface: "Interface Settings",
  import_export: "Import/Export",
  import_export_title: "Import/Export Configuration",
  syncToGoogleDrive: "Sync Now with Google Drive",
  previewAllThemes: "Preview all themes",
  "translationTheme.none": "None",
  "translationTheme.dashed": "Dashed underline",
  "translationTheme.dotted": "Dotted Underline",
  "translationTheme.dashedBorder": "Dashed Border",
  "translationTheme.underline": "Straight underline",
  "translationTheme.mask": "Blur effect",
  "translationTheme.paper": "White paper shadow effect",
  "translationTheme.dividingLine": "Dividing line",
  "translationTheme.highlight": "Highlight",
  "translationTheme.marker": "Maker",
  "translationTheme.blockquote": "quote style",
  "translationTheme.weakening": "Weakening",
  "translationTheme.italic": "Italic",
  "translationTheme.bold": "Bold",
  "translationTheme.thinDashed": "Thin dashed underline",
  "translationTheme.nativeDashed": "System Dash Underline",
  "translationTheme.nativeDotted": "System Dotted Underline",
  "translationTheme.nativeUnderline": "System Straight Line Underline",
  "translationTheme.wavy": "Squiggle",
  "translationServices.tencent": "Tencent Translator",
  "translationServices.google": "Google Translate",
  "translationServices.bai": "Baidu (Alpha)",
  "translationServices.baidu": "Baidu translation",
  "translationServices.aliyun": "Aliyun Translator",
  "translationServices.volc": "Volcano Translation",
  "translationServices.deeplx": "DeeplX (Alpha)",
  "translationServices.bing": "Bing translate",
  "translationServices.deepl": "DeepL",
  "translationServices.wechat": "Wechat translation",
  "translationServices.azure": "Microsoft Translator",
  "translationServices.ibm": "IBM Watson",
  "translationServices.aws": "Amazon Translate",
  "translationServices.mock": "Mock translation",
  "translationServices.mock2": "Mock Translation2",
  "translationServices.caiyun": "Caiyun Translation",
  "translationServices.volcAlpha": "Volcano Translation (Alpha)",
  "translationServices.openl": "OpenL",
  "translationServices.youdao": "Youdao Translation",
  "translationServices.transmart": "Tencent Smart Translation",
  "translationServices.niu": "Niu Translation",
  "translationServices.d": "DeeplX (Alpha)",
  "translate title": "Translate page title",
  "always languages": "Always translate the following languages",
  neverTranslateLanguagesLabel: "Never Translated Languages",
  neverTranslateTheFollowingLanguagesDescription: "Automatically skip translating the paragraph when languages are the followings",
  enableUserscriptPagePopup: "Always show Popup windows on the page",
  enableUserscriptPagePopupDescription: "\u5173\u95ED\u6D6E\u7A97\u540E\uFF0C\u53EF\u4EE5\u7528\u5FEB\u6377\u952E/\u4E09\u6307\u89E6\u5C4F\u5524\u8D77\u3002\u4E3A\u9632\u6B62\u4E0D\u614E\u5173\u95ED\u8BE5\u9009\u9879\u540E\u627E\u4E0D\u5230\u6D6E\u7A97\uFF0C\u5F3A\u70C8\u5EFA\u8BAE\u6536\u85CF\u672C\u8BBE\u7F6E\u9875",
  "always translate the following languages": "The following languages will always be translated",
  "always sites": "Always translate the following sites",
  "always translate the following sites": "The following sites will always be translated",
  "never sites": "Never translate the following sites",
  "never translate the following sites": "The following sites will never be translated",
  "please refer to": "It can only be used after filling in the key. For details, please refer to",
  KeyAndConfigurationTutorial: "Key Application and Configuration Tutorial",
  useAboveStyleForTheseSites: "The current default translation style is \u300C{theme}\u300D, you can also set it to let some websites use this style, click the button on the right to add it, and then switch to another default translation style, so that you can use different translation styles for different websites.",
  currentUrl: "Current URL",
  confirm: "Save",
  cancel: "Cancel",
  delete: "Delete",
  "languages.auto": "Detect Language",
  isShowContextMenu: "Create right button menu",
  syncToCloud: "Sync to cloud",
  syncToCloudDescription: "When syncing it will compare the last modification time of the local and cloud configurations, whichever is the last.",
  authFail: "Authorization Failed",
  syncTitle: "Please select a file operation",
  import_hint: "Import",
  upload: "Upload",
  revokeAuth: "Revoke Authorization",
  uploadFail: "Upload Failed",
  download: "Download",
  importSuccess: "Upload Success",
  importFail: "Import Failed",
  deleteFail: "Delete Failed",
  backupToCloud: "Manage backup files manually",
  create_new_backup: "Add backup node",
  maxBackupFiles: "Up to{count}different nodes can be backed up. Please delete unneeded nodes",
  backupToCloudDescription: "Upload or restore backup files manually, up to 3 different backups",
  successSyncConfig: "Successfully synced with cloud",
  syncFail: "Synchronization failed",
  updatedAt: "Updated at {date}",
  lastSyncedAt: "Last checked at {date}",
  downloadFail: "Download failed",
  clickToDownload: "Click to download",
  aboutLabel: "About - Feedback - Sponsor",
  "browser.openAboutPage": "About / Feedback/Sponsor",
  aboutIntro: "This extension is completely free. I hope we can get foreign information on the Internet more easily and happily. Thanks to these <1>sponsors</1>, more people can use this tool completely free of charge because of their support. \nIf you have spare time, you can click here to <2>sponsor</2> my work, and you can follow my <3>Twitter</3> and <4>Telegram channels </4> for the latest updates.",
  projectHomepage: "Project Homepage",
  joinTelegramGroup: "Join Telegram group for feature discussion",
  feedbackAndJoin: "Issue feedback/group",
  autoSync: "Auto-Time Sync",
  loadingThemeTitle: "Loading Style",
  loadingThemeDescription: "Set the style of waiting for the translation to load",
  "loadingTheme.spinner": "Animate Spinner",
  "loadingTheme.text": "Static Text... ",
  "loadingTheme.none": "Disabled",
  developerDescription: "\u53EF\u4EE5\u70B9\u51FB<1>\u8FD9\u91CC</1>\u67E5\u770B\u9AD8\u7EA7\u81EA\u5B9A\u4E49\u76F8\u5173\u7684\u6587\u6863"
};

// constant.ts
var interfaceTranslations = [
  {
    code: "zh-CN",
    messages: zh_CN_default
  },
  {
    code: "zh-TW",
    messages: zh_TW_default
  },
  {
    code: "en",
    messages: en_default
  }
];
var translations = {};
for (const translation of interfaceTranslations) {
  translations[translation.code] = translation.messages;
}
var brandName = "Immersive Translate";
var brandId = "immersive-translate";
var brandIdForJs = "immersiveTranslate";
var GOOGLE_ACCESS_TOKEN_KEY = brandIdForJs + "GoogleAccessToken";
var AUTH_FLOW_FLAG = brandIdForJs + "AuthFlow";
var AUTH_STATE_FLAG = brandIdForJs + "AuthState";
var iframeMessageIdentifier = brandIdForJs + "IframeMessage";
var targetContainerElementAttributeName = `${brandIdForJs}Container`;
var specifiedTargetContainerElementAttributeName = `${brandIdForJs}SpecifiedContainer`;
var buildinConfigStorageKey = "buildinConfig";
var localConfigStorageKey = "localConfig";
var contextOpenOptionsMenuId = `openOptionsPage`;
var contextOpenAboutMenuId = `openAboutPage`;
var pageTranslatedStatusEventName = `${brandIdForJs}PageTranslatedStatus`;
var pageUrlChangedEventName = `${brandIdForJs}PageUrlChanged`;
var userscriptCommandEventName = `${brandIdForJs}ReceiveCommand`;
var popupReceiveMessageEventName = `${brandIdForJs}PopupReceiveMessage`;
var hostname = "immersive-translate.owenyoung.com";
var homepage = `https://${hostname}/`;
var buildinConfigSyncUrl = `https://${hostname}/buildin_config.json`;
var sourceElementMarkAttributeName = `${brandIdForJs}Mark`;
var sourceElementEffectAttributeNameForJs = `immersiveTranslateEffect`;
var elementMarkRootKey = `${brandIdForJs}Root`;
var sourceElementEffectAttributeName = `data-${brandId}-effect`;
var sourceElementTranslatedMarkAttributeName = `${brandIdForJs}TranslatedMark`;
var sourceElementParagraphAttributeName = `${brandIdForJs}ParagraphId`;
var sourceAtomicBlockElementMarkAttributeName = `${brandIdForJs}AtomicBlockMark`;
var sourceElementExcludeAttributeName = `${brandIdForJs}ExcludeMark`;
var sourceElementExcludeAttributeNameForSelector = `data-${brandId}-exclude-mark`;
var sourceElementStayOriginalAttributeName = `${brandIdForJs}StayOriginalMark`;
var sourcePreWhitespaceMarkAttributeName = `${brandIdForJs}PreWhitespaceMark`;
var sourceInlineElementMarkAttributeName = `${brandIdForJs}InlineMark`;
var sourceBlockElementMarkAttributeName = `${brandIdForJs}BlockMark`;
var sourceElementLeft = `${brandIdForJs}Left`;
var sourceElementRight = `${brandIdForJs}Right`;
var sourceElementWidth = `${brandIdForJs}Width`;
var sourceElementHeight = `${brandIdForJs}Height`;
var sourceElementTop = `${brandIdForJs}Top`;
var sourceElementFontSize = `${brandIdForJs}FontSize`;
var lastRunTimeStorageKey = "lastRunTime";
var sourceElementWithGlobalStyleMarkAttributeName = `${brandIdForJs}GlobalStyleMark`;
var defaultPlaceholderDelimiters = ["@", "#"];
var titleDelimiters = " --- ";
var translationTextSeparator = "\n";
var translationTargetElementWrapperClass = `${brandId}-target-wrapper`;
var translationPdfTargetContainerClass = `${brandId}-pdf-target-container`;
var translationTargetInnerElementWrapperClass = `${brandId}-target-inner`;
var translationSourceElementsWrapperClass = `${brandId}-source-wrapper`;
var translationTargetTranslationElementBlockWrapperClass = `${brandId}-target-translation-block-wrapper`;
var translationFrameRootThemeAttributeName = `${brandId}-root-translation-theme`;
var translationFrameRootThemeAttributeNameForJs = `${brandIdForJs}RootTranslationTheme`;
var translationTargetTranslationElementVerticalBlockClass = `${brandId}-target-translation-vertical-block-wrapper`;
var translationTargetTranslationPdfElementBlockWrapperClass = `${brandId}-target-translation-pdf-block-wrapper`;
var translationTargetTranslationElementPreWhitespaceWrapperClass = `${brandId}-target-translation-pre-whitespace`;
var translationTargetTranslationElementInlineWrapperClass = `${brandId}-target-translation-inline-wrapper`;
var languages = [
  "auto",
  "en",
  "zh-CN",
  "zh-TW",
  "ja",
  "af",
  "am",
  "ar",
  "az",
  "be",
  "bg",
  "bn",
  "bs",
  "ca",
  "ceb",
  "co",
  "cs",
  "cy",
  "da",
  "de",
  "el",
  "eo",
  "es",
  "et",
  "eu",
  "fa",
  "fi",
  "fil",
  "fj",
  "fr",
  "fy",
  "ga",
  "gd",
  "gl",
  "gu",
  "ha",
  "haw",
  "he",
  "hi",
  "hmn",
  "hr",
  "ht",
  "hu",
  "hy",
  "id",
  "ig",
  "is",
  "it",
  "jw",
  "ka",
  "kk",
  "km",
  "kn",
  "ko",
  "ku",
  "ky",
  "la",
  "lb",
  "lo",
  "lt",
  "lv",
  "mg",
  "mi",
  "mk",
  "ml",
  "mn",
  "mr",
  "ms",
  "mt",
  "mww",
  "my",
  "ne",
  "nl",
  "no",
  "ny",
  "otq",
  "pa",
  "pl",
  "ps",
  "pt",
  "ro",
  "ru",
  "sd",
  "si",
  "sk",
  "sl",
  "sm",
  "sn",
  "so",
  "sq",
  "sr",
  "sr-Cyrl",
  "sr-Latn",
  "st",
  "su",
  "sv",
  "sw",
  "ta",
  "te",
  "tg",
  "th",
  "tlh",
  "tlh-Qaak",
  "to",
  "tr",
  "ty",
  "ug",
  "uk",
  "ur",
  "uz",
  "vi",
  "wyw",
  "xh",
  "yi",
  "yo",
  "yua",
  "yue",
  "zu"
];
var langMap = {
  "af": "Afrikaans",
  "am": "Amharic",
  "ar": "Arabic",
  "auto": "Detect Language",
  "az": "Azerbaijani",
  "be": "Belarusian",
  "bg": "Bulgarian",
  "tn": "Zana",
  "bn": "Bengali",
  "bs": "Bosnian",
  "ca": "Catalan",
  "ceb": "Cebuano",
  "co": "Corsican",
  "cs": "Czech",
  "cy": "Welsh",
  "da": "Danish",
  "de": "German",
  "el": "Greek",
  "en": "English",
  "eo": "Esperanto",
  "es": "Spanish",
  "et": "Estonian",
  "eu": "Basque",
  "fa": "Farsi",
  "fi": "Finnish",
  "fil": "Filipino",
  "fj": "Fijian",
  "fr": "French",
  "fy": "Frisian",
  "ga": "Irish",
  "gd": "Scottish Gaelic",
  "gl": "Galician",
  "gu": "Gujarati",
  "ha": "Hausa",
  "haw": "Hawaiian",
  "he": "Hebrew",
  "hi": "Hindi",
  "hmn": "Hmong",
  "hr": "Croatian",
  "ht": "Haitian Creole",
  "hu": "Hungarian",
  "hy": "Armenian",
  "id": "Indonesian",
  "ig": "Igbo",
  "is": "Icelandic",
  "it": "Italian",
  "ja": "\u65E5\u672C\u8A9E",
  "jw": "Javanese",
  "ka": "Georgian",
  "kk": "Kazakh",
  "km": "Khmer",
  "kn": "Kannada",
  "ko": "Korean",
  "ku": "Kurdish",
  "ky": "Kyrgyz",
  "la": "Latin",
  "lb": "Luxembourgish",
  "lo": "Lao",
  "lt": "Lithuanian",
  "lv": "Latvian",
  "mg": "Malagash",
  "mi": "Maori",
  "mk": "Macedonian",
  "ml": "Malayalam",
  "mn": "Mongolian",
  "mr": "Marathi",
  "ms": "Malay",
  "mt": "Maltese",
  "mww": "Bai Miao",
  "my": "Burmese",
  "ne": "Nepali",
  "nl": "Dutch",
  "no": "Norwegian",
  "ny": "Nyanza (Chichewa)",
  "otq": "Quer\xE9taro Otomi",
  "pa": "Punjabi",
  "pl": "Polish",
  "ps": "Pashto",
  "pt": "Portuguese (Portugal, Brazil)",
  "ro": "Romanian",
  "ru": "Russian",
  "sd": "Sindhi",
  "si": "Sinhala",
  "sk": "Slovak",
  "sl": "Slovenian",
  "sm": "Samoan",
  "sn": "Shona",
  "so": "Somali",
  "sq": "Albanian",
  "sr": "Serbian",
  "sr-Cyrl": "Serbian (Cyrillic)",
  "sr-Latn": "Serbian (Latin)",
  "st": "Sesotho",
  "su": "Sundanese",
  "sv": "Swedish",
  "sw": "Swahili",
  "ta": "Tamil",
  "te": "Telugu",
  "tg": "Tajik",
  "th": "Thai",
  "tlh": "Klingon",
  "tlh-Qaak": "Klingon (piqaD)",
  "to": "Tongan",
  "tr": "Turkish",
  "ty": "Tahiti",
  "ug": "Uyghur",
  "uk": "Ukrainian",
  "ur": "Urdu",
  "uz": "Uzbek",
  "vi": "Vietnamese",
  "wyw": "Classical Chinese",
  "xh": "Bantu",
  "yi": "Yiddish",
  "yo": "Yoruba",
  "yua": "Yucatan Mayan",
  "yue": "Cantonese (Traditional)",
  "zh-CN": "\u7B80\u4F53\u4E2D\u6587",
  "zh-TW": "\u7E41\u9AD4\u4E2D\u6587",
  "zu": "Zulu"
};
var buildinExcludeUrls = [
  "https://immersive-translate.owenyoung.com/options/",
  "https://immersive-translate.owenyoung.com/auth-done/",
  "http://localhost:8000/dist/userscript/options/",
  "http://localhost:8000/auth-done/",
  "http://192.168.50.9:8000/dist/userscript/options/",
  "https://www.deepl.com/translator",
  "translate.google.com"
];
var fallbackLanguage = "zh-CN";

// env.ts
function getEnv() {
  if (typeof process === "undefined") {
    if (typeof Deno !== "undefined") {
      const denoEnv = Deno.env.toObject();
      return denoEnv;
    }
  }
  const injectEnv = define_process_env_default;
  return injectEnv;
}
var env = getEnv();
function isMonkey() {
  return env.IMMERSIVE_TRANSLATE_USERSCRIPT === "1";
}
function isDeno() {
  return typeof Deno !== "undefined";
}

// utils/iframe.ts
function getIsInIframe() {
  try {
    return globalThis.self !== globalThis.top;
  } catch (_e3) {
    return true;
  }
}

// dom/util.ts
var env2 = getEnv();
var isProd = env2.PROD === "1";
function duplicatedElements(root2, array, rule) {
  const allHeaders = root2.querySelectorAll("header");
  const main3 = root2.querySelectorAll("main");
  const headers2 = [];
  for (const header of allHeaders) {
    const isInMain = main3.length > 0 && main3[0].contains(header);
    if (!isInMain) {
      headers2.push(header);
    }
  }
  for (let i2 = 0; i2 < array.length; i2++) {
    const a4 = array[i2].element;
    for (let j5 = i2 + 1; j5 < array.length; j5++) {
      const b4 = array[j5].element;
      if (a4.contains(b4)) {
        array.splice(j5, 1);
        j5--;
      } else if (b4.contains(a4)) {
        array.splice(i2, 1);
        i2--;
        break;
      } else if (a4 === b4) {
        array.splice(j5, 1);
        j5--;
      }
    }
  }
  const finalArray = array.filter((container) => {
    const element = container.element;
    if (container.reserve) {
      return true;
    }
    let isHeader = false;
    for (const header of headers2) {
      if (isMatchTags(element.nodeName, ["H1"])) {
        continue;
      }
      const h1Container = header.querySelector("h1");
      if (h1Container && isValidTextByCount(
        h1Container.textContent || "",
        rule.paragraphMinTextCount,
        rule.paragraphMinWordCount
      )) {
        continue;
      }
      if (element === header || header.contains(element)) {
        isHeader = true;
        break;
      }
    }
    if (isHeader) {
      return false;
    }
    return true;
  });
  return finalArray.map((container) => container.element);
}
function getLastHTMLElement(elements) {
  for (let i2 = elements.length - 1; i2 >= 0; i2--) {
    const element = elements[i2].element || elements[i2];
    if (typeof element !== "string") {
      return element;
    }
  }
  return null;
}
function getHTMLElements(elements) {
  const result = [];
  for (let i2 = elements.length - 1; i2 >= 0; i2--) {
    const element = elements[i2].element || elements[i2];
    if (typeof element !== "string" || element !== " ") {
      result.push(element);
    }
  }
  return result;
}
function getFirstHTMLElement(elements) {
  for (let i2 = 0; i2 < elements.length; i2++) {
    const element = elements[i2];
    if (typeof element !== "string") {
      return element;
    }
  }
  return null;
}
function getWhitespace(nextNode, isPreWhitespace) {
  if (nextNode && nextNode.nodeType === Node.TEXT_NODE && nextNode.textContent && nextNode.textContent?.length > 0) {
    if (isPreWhitespace) {
      return nextNode.textContent;
    } else {
      return " ";
    }
  } else {
    return null;
  }
}
function getElementsBySelectors(root2, selectors) {
  const elements = [];
  for (const selector of selectors) {
    const nodes = root2.querySelectorAll(selector);
    for (const node of nodes) {
      elements.push(node);
    }
  }
  return elements;
}
function isInlineElementByTreeWalker(element, rule) {
  const filterInlineElement = function(node) {
    if (node.nodeType === Node.ELEMENT_NODE || node.nodeType === Node.TEXT_NODE) {
      if (node.nodeType === Node.ELEMENT_NODE) {
        if (isExcludeElement(node, rule, true)) {
          return NodeFilter.FILTER_REJECT;
        }
      }
      return NodeFilter.FILTER_ACCEPT;
    } else {
      return NodeFilter.FILTER_REJECT;
    }
  };
  const treeWalker = document.createTreeWalker(
    element,
    NodeFilter.SHOW_ELEMENT,
    filterInlineElement
  );
  let isInline = true;
  while (treeWalker.nextNode()) {
    const node = treeWalker.currentNode;
    if (node.nodeType === Node.ELEMENT_NODE) {
      const isHasInlineElement = isMarked(
        node,
        sourceInlineElementMarkAttributeName
      );
      if (isHasInlineElement) {
        if (isInline === true) {
          return true;
        } else {
          continue;
        }
      }
      const isBlockElement = !isMatchTags(node.nodeName, rule.inlineTags);
      if (isBlockElement) {
        return false;
      }
    }
  }
  return true;
}
function isInlineElement(element, rule) {
  const inlineTags = rule.inlineTags;
  if (element.nodeType === Node.ELEMENT_NODE) {
    if (isMatchTags(element.nodeName, inlineTags)) {
      if (isMarked(
        element,
        sourceBlockElementMarkAttributeName
      )) {
        return false;
      }
      if (isMatchTags(element.nodeName, ["BR"])) {
        return false;
      }
      if (isMarked(element, sourceInlineElementMarkAttributeName)) {
        return true;
      }
      return isInlineElementByTreeWalker(element, rule);
    } else {
      return isMarked(
        element,
        sourceInlineElementMarkAttributeName
      );
    }
  }
  return false;
}
function isDuplicateElement(element, elements) {
  for (const e3 of elements) {
    if (e3 === element) {
      return true;
    }
  }
  return false;
}
function isMetaElement(element, rule) {
  if (isMatchTags(element.nodeName, rule.metaTags)) {
    return true;
  }
  return false;
}
function isExcludeElement(element, rule, includeStayElements) {
  if (!(element.nodeType === Node.ELEMENT_NODE || element.nodeType === Node.TEXT_NODE)) {
    return true;
  }
  const { stayOriginalTags, excludeTags } = rule;
  let finalExcludeTags = [];
  if (includeStayElements && excludeTags && excludeTags.length > 0) {
    finalExcludeTags = excludeTags || [];
  } else {
    finalExcludeTags = excludeTags.filter((tag) => {
      return !stayOriginalTags.includes(tag);
    });
  }
  if (element.nodeType === Node.ELEMENT_NODE && element.isContentEditable) {
    return true;
  }
  if (element.nodeType === Node.ELEMENT_NODE) {
    if (element.getAttribute("translate") === "no") {
      return true;
    }
    if (element.classList.contains("notranslate")) {
      return true;
    }
    if (isMarked(element, sourceElementExcludeAttributeName, true)) {
      return true;
    }
  }
  if (element.nodeType === Node.ELEMENT_NODE && isMarked(
    element,
    specifiedTargetContainerElementAttributeName
  )) {
    return false;
  }
  if (isMatchTags(element.nodeName, finalExcludeTags)) {
    return true;
  }
  return false;
}
function isNeedToTranslate(item, minTextCount, minWordCount, ctx) {
  const delimiters = getPlaceholderDelimiters(ctx);
  const stayInOriginalRegex = new RegExp(
    `^${delimiters[0]}(\\d+)${delimiters[1]}$`
  );
  const text = item.text;
  const trimedText = text.trim();
  if (trimedText === "" || trimedText.length === 1 && trimedText.charCodeAt(0) === 8203 || /^\d+(,\d+)*(\.\d+)?$/.test(text)) {
    return false;
  }
  if (trimedText.includes("</style>") || trimedText.includes("< styles>")) {
    return false;
  }
  if (isAtTag(trimedText)) {
    return false;
  }
  if (isUrl(trimedText)) {
    return false;
  }
  if (isHashTag(trimedText)) {
    return false;
  }
  if (stayInOriginalRegex.test(trimedText)) {
    return false;
  }
  return isValidTextByCount(text, minTextCount, minWordCount);
}
function isValidTextByCount(rawText, minTextCount, minWordCount) {
  const text = rawText.trim();
  if (text.length >= minTextCount) {
    return true;
  }
  if (text.split(" ").length >= minWordCount) {
    return true;
  }
  return false;
}
function isUrl(text) {
  if (text && text.includes("://")) {
    try {
      new URL(text);
      return true;
    } catch (_e3) {
      return false;
    }
  } else {
    return false;
  }
}
function isHashTag(text) {
  if (text && text.startsWith("#")) {
    if (text.indexOf(" ") === -1) {
      return true;
    }
  }
  return false;
}
function isAtTag(text) {
  if (text && text.startsWith("@")) {
    if (text.indexOf(" ") === -1) {
      return true;
    }
  }
  return false;
}
function isStockTag(text) {
  if (text && text.startsWith("$")) {
    if (text.indexOf(" ") === -1) {
      return true;
    }
  }
  return false;
}
function isMarked(element, markedAttribute, explicit = false) {
  return isMarkedWith(element, markedAttribute, "1", explicit);
}
function isMarkedWith(element, markedAttribute, value, explicit = false) {
  if (isProd && !explicit) {
    if (!element[elementMarkRootKey]) {
      return false;
    }
    if (
      // @ts-ignore: it's ok
      element[elementMarkRootKey] && // @ts-ignore: it's ok
      element[elementMarkRootKey][markedAttribute] === value
    ) {
      return true;
    } else {
      return false;
    }
  } else {
    return element.dataset[markedAttribute] === value;
  }
}
function hasMark(element, markedAttribute, explicit = false) {
  if (isProd && !explicit) {
    if (!element[elementMarkRootKey]) {
      return false;
    }
    if (
      // @ts-ignore: it's ok
      element[elementMarkRootKey] && // @ts-ignore: it's ok
      element[elementMarkRootKey][markedAttribute]
    ) {
      return true;
    } else {
      return false;
    }
  } else {
    return element.dataset[markedAttribute] !== void 0;
  }
}
function getMainText(root2) {
  const bodyText = root2.innerText || root2.textContent || "";
  return bodyText.trim();
}
function isMatchSelectors(selectors) {
  if (!selectors) {
    return false;
  }
  if (typeof selectors === "string") {
    return document.querySelector(selectors) !== null;
  }
  return selectors.some((selector) => {
    return document.querySelector(selector);
  });
}
function setAttribute(element, name, value, explicit = false) {
  if (!element.isContentEditable) {
    if (isProd && !explicit) {
      if (!element.dataset[sourceElementEffectAttributeNameForJs]) {
        element.dataset[sourceElementEffectAttributeNameForJs] = "1";
      }
      if (!element[elementMarkRootKey]) {
        element[elementMarkRootKey] = {};
      }
      if (!element[elementMarkRootKey][name]) {
        element[elementMarkRootKey][name] = value;
      }
    } else {
      if (!element.dataset[sourceElementEffectAttributeNameForJs]) {
        element.dataset[sourceElementEffectAttributeNameForJs] = "1";
      }
      if (element.dataset[name] !== value) {
        element.dataset[name] = value;
      }
    }
  }
}
function removeAttribute(element, name, explicit = false) {
  if (isProd && !explicit) {
    if (!element[elementMarkRootKey]) {
      return void 0;
    }
    if (!element[elementMarkRootKey][name]) {
      return void 0;
    }
    delete element[elementMarkRootKey][name];
  } else {
    delete element.dataset[name];
  }
}
function getAttribute(element, name, explicit = false) {
  if (isProd && !explicit) {
    if (!element[elementMarkRootKey]) {
      return void 0;
    }
    if (!element[elementMarkRootKey][name]) {
      return void 0;
    }
    return element[elementMarkRootKey][name];
  } else {
    return element.dataset[name];
  }
}
function isStayOriginalElement(element, rule) {
  let isStayOriginal = false;
  if (isMatchTags(element.nodeName, rule.stayOriginalTags)) {
    isStayOriginal = true;
  } else if (isMarked(element, sourceElementStayOriginalAttributeName)) {
    isStayOriginal = true;
  }
  return isStayOriginal;
}
function isUnknowTag(element, rule) {
  const allKnowTags = rule.allBlockTags.concat(rule.inlineTags).concat(
    rule.excludeTags
  );
  return !isMatchTags(element.nodeName, allKnowTags);
}
function getPlaceholderDelimiters(ctx) {
  const { config } = ctx;
  let delimiters = defaultPlaceholderDelimiters;
  if (config.translationServices[ctx.translationService] && config.translationServices[ctx.translationService].placeholderDelimiters) {
    delimiters = config.translationServices[ctx.translationService].placeholderDelimiters;
  }
  return delimiters;
}
function isContainsSelectors(element, selectors) {
  if (!selectors) {
    return false;
  }
  if (!Array.isArray(selectors)) {
    selectors = [selectors];
  }
  for (const selector of selectors) {
    if (element.querySelector(selector)) {
      return true;
    }
  }
  return false;
}
function getTheLastTextNodeParentElement(element) {
  const treeWalker = document.createTreeWalker(
    element,
    NodeFilter.SHOW_TEXT,
    (node) => {
      if (node.textContent && node.textContent.trim()) {
        return NodeFilter.FILTER_ACCEPT;
      }
      return NodeFilter.FILTER_REJECT;
    }
  );
  let lastTextNode = null;
  while (treeWalker.nextNode()) {
    lastTextNode = treeWalker.currentNode;
  }
  if (lastTextNode) {
    return lastTextNode.parentElement;
  }
  return null;
}
function getRealUrl() {
  const isInIframe = getIsInIframe();
  if (!isInIframe) {
    return globalThis.location.href;
  }
  try {
    const currentUrl = globalThis.location.href;
    const currentUrlObj = new URL(currentUrl);
    if (currentUrlObj.protocol === "about:") {
      if (globalThis.location.ancestorOrigins && globalThis.location.ancestorOrigins.length > 0) {
        return globalThis.location.ancestorOrigins[0];
      }
      let href = "";
      try {
        href = globalThis.parent.location.href;
      } catch (_e3) {
      }
      if (href) {
        return href;
      }
      const realUrl = globalThis.location != globalThis.parent.location ? document.referrer : document.location.href;
      return realUrl;
    } else {
      return currentUrl;
    }
  } catch (_e3) {
  }
  return globalThis.location.href;
}
function injectCSS(rootDocument, css) {
  rootDocument.head.appendChild(rootDocument.createElement("style")).innerHTML = css;
}
function isInlineIframe(frame) {
  const src = frame.getAttribute("src");
  if (src) {
    return false;
  }
  const srcdoc = frame.getAttribute("srcdoc");
  if (srcdoc && frame.contentDocument && frame.contentDocument.body) {
    return true;
  }
  return false;
}
function isMatchTags(nodeName, tags) {
  if (!nodeName) {
    return false;
  }
  if (!tags) {
    return false;
  }
  if (!Array.isArray(tags)) {
    tags = [tags];
  }
  nodeName = nodeName.toUpperCase();
  for (const tag of tags) {
    if (nodeName === tag) {
      return true;
    }
  }
  return false;
}

// dom/mark_containers.ts
function markContainers(container, rule) {
  const {
    excludeSelectors,
    additionalExcludeSelectors,
    extraInlineSelectors,
    additionalInlineSelectors,
    extraBlockSelectors,
    atomicBlockSelectors,
    atomicBlockTags,
    globalStyles,
    stayOriginalTags,
    stayOriginalSelectors,
    globalAttributes
  } = rule;
  const globalStyleSelectors = Object.keys(globalStyles);
  if (globalStyleSelectors.length > 0) {
    for (const selector of globalStyleSelectors) {
      const elements = getElementsBySelectors(container, [selector]);
      for (const element of elements) {
        if (!isMarked(element, sourceElementWithGlobalStyleMarkAttributeName)) {
          setAttribute(
            element,
            sourceElementWithGlobalStyleMarkAttributeName,
            "1"
          );
          const cssText = globalStyles[selector];
          element.style.cssText += cssText;
        }
      }
    }
  }
  const globalAttributesSelectors = Object.keys(globalAttributes);
  if (globalAttributesSelectors.length > 0) {
    for (const selector of globalAttributesSelectors) {
      const attributes = globalAttributes[selector];
      const attributesKeys = Object.keys(attributes);
      const elements = getElementsBySelectors(container, [selector]);
      for (const element of elements) {
        for (const key of attributesKeys) {
          const value = attributes[key];
          const currentValue = element.getAttribute(key);
          if (currentValue !== value) {
            if (value === null) {
              element.removeAttribute(key);
            } else {
              element.setAttribute(key, value);
            }
          }
        }
      }
    }
  }
  const allExcludeSelectors = [
    ...excludeSelectors,
    ...additionalExcludeSelectors
  ];
  const allInlineSelectors = [
    ...extraInlineSelectors,
    ...additionalInlineSelectors
  ];
  const allAtomicBlockSelectors = [...atomicBlockSelectors];
  const allAtomicBlockTagsSelectors = atomicBlockTags.map(
    (item) => item.toLowerCase()
  );
  const allBlockSelectos = extraBlockSelectors;
  const excludeElements = getElementsBySelectors(
    container,
    allExcludeSelectors
  );
  excludeElements.forEach((element) => {
    if (!isMarked(element, sourceElementExcludeAttributeName, true)) {
      setAttribute(element, sourceElementExcludeAttributeName, "1", true);
    }
  });
  let atomicBlockElements = [];
  if (allAtomicBlockSelectors.length > 0) {
    atomicBlockElements = getElementsBySelectors(
      container,
      allAtomicBlockSelectors
    ).filter((element) => !isMarked(element, sourceAtomicBlockElementMarkAttributeName));
  }
  if (allAtomicBlockTagsSelectors.length > 0) {
    const stayOriginalTagsHTMLStringArr = stayOriginalTags.reduce(
      (arr, item) => {
        const tagLower = item.toLowerCase();
        arr.push(`<${tagLower}>`, `</${tagLower}>`, `<${tagLower} />`);
        return arr;
      },
      []
    );
    const httpLinkTags = [">http://", ">https://"];
    stayOriginalTagsHTMLStringArr.push(...httpLinkTags);
    const atomicBlockTagsElements = getElementsBySelectors(
      container,
      allAtomicBlockTagsSelectors
    ).filter((element) => {
      const isMark = isMarked(
        element,
        sourceAtomicBlockElementMarkAttributeName
      );
      if (isMark) {
        return false;
      } else {
        const htmlString = element.innerHTML;
        const isStayOriginal = stayOriginalTagsHTMLStringArr.some(
          (item) => htmlString.includes(item)
        );
        return !isStayOriginal;
      }
    });
    atomicBlockElements.push(...atomicBlockTagsElements);
  }
  atomicBlockElements.forEach((element) => {
    if (!isMarked(element, sourceAtomicBlockElementMarkAttributeName)) {
      setAttribute(element, sourceAtomicBlockElementMarkAttributeName, "1");
    }
  });
  const extraInlineElements = [];
  if (allInlineSelectors.length > 0) {
    extraInlineElements.push(
      ...getElementsBySelectors(container, allInlineSelectors)
    );
  }
  extraInlineElements.forEach((element) => {
    setAttribute(element, sourceInlineElementMarkAttributeName, "1");
  });
  const extraBlockElements = [];
  if (allBlockSelectos.length > 0) {
    extraBlockElements.push(
      ...getElementsBySelectors(container, allBlockSelectos)
    );
  }
  extraBlockElements.forEach((element) => {
    setAttribute(element, sourceBlockElementMarkAttributeName, "1");
  });
  const stayOriginalElements = [];
  if (stayOriginalSelectors.length > 0) {
    stayOriginalElements.push(
      ...getElementsBySelectors(container, stayOriginalSelectors)
    );
  }
  stayOriginalElements.forEach((element) => {
    setAttribute(element, sourceElementStayOriginalAttributeName, "1");
  });
}

// utils/language_match.ts
function isMatchLanguage(lang, matchPattern) {
  let matches = matchPattern.matches || [];
  if (matches && !Array.isArray(matches)) {
    matches = [matches];
  }
  if (matches.length === 0) {
    return false;
  }
  if (matches.length > 0) {
    if (matches.includes(lang)) {
      return true;
    } else {
      for (const match of matches) {
        if (match.includes("*")) {
          const reg = new RegExp(match);
          if (reg.test(lang)) {
            return true;
          }
        }
      }
    }
  }
  return false;
}

// utils/format_language.ts
function formatLanguage(rawLangCode) {
  if (typeof rawLangCode !== "string")
    return "auto";
  let lowerCaseLangCode = rawLangCode.toLowerCase();
  if (lowerCaseLangCode === "zh" || lowerCaseLangCode === "zh-hans") {
    return "zh-CN";
  } else if (lowerCaseLangCode === "zh-hant" || lowerCaseLangCode === "zh-hk") {
    return "zh-TW";
  } else if (lowerCaseLangCode === "iw") {
    return "he";
  } else if (lowerCaseLangCode === "jv") {
    return "jw";
  }
  const lowerCaseLanguages = languages.map((lang) => lang.toLowerCase());
  const indexOfLanguages = lowerCaseLanguages.indexOf(
    lowerCaseLangCode
  );
  if (indexOfLanguages === -1) {
    if (lowerCaseLangCode.indexOf("-") >= 0) {
      lowerCaseLangCode = lowerCaseLangCode.split("-")[0];
      const firstPartIndex = lowerCaseLanguages.indexOf(lowerCaseLangCode);
      if (firstPartIndex === -1) {
        return "auto";
      } else {
        return languages[firstPartIndex];
      }
    } else {
      return "auto";
    }
  } else {
    return languages[indexOfLanguages];
  }
}

// https://deno.land/std@0.171.0/async/deferred.ts
function deferred() {
  let methods;
  let state = "pending";
  const promise = new Promise((resolve, reject) => {
    methods = {
      async resolve(value) {
        await value;
        state = "fulfilled";
        resolve(value);
      },
      // deno-lint-ignore no-explicit-any
      reject(reason) {
        state = "rejected";
        reject(reason);
      }
    };
  });
  Object.defineProperty(promise, "state", { get: () => state });
  return Object.assign(promise, methods);
}

// https://deno.land/std@0.171.0/async/deadline.ts
var DeadlineError = class extends Error {
  constructor() {
    super("Deadline");
    this.name = "DeadlineError";
  }
};
function deadline(p6, delay2) {
  const d3 = deferred();
  const t4 = setTimeout(() => d3.reject(new DeadlineError()), delay2);
  return Promise.race([p6, d3]).finally(() => clearTimeout(t4));
}

// https://deno.land/std@0.171.0/async/delay.ts
function delay(ms, options2 = {}) {
  const { signal, persistent } = options2;
  if (signal?.aborted) {
    return Promise.reject(new DOMException("Delay was aborted.", "AbortError"));
  }
  return new Promise((resolve, reject) => {
    const abort = () => {
      clearTimeout(i2);
      reject(new DOMException("Delay was aborted.", "AbortError"));
    };
    const done = () => {
      signal?.removeEventListener("abort", abort);
      resolve();
    };
    const i2 = setTimeout(done, ms);
    signal?.addEventListener("abort", abort, { once: true });
    if (persistent === false) {
      try {
        Deno.unrefTimer(i2);
      } catch (error) {
        if (!(error instanceof ReferenceError)) {
          throw error;
        }
        console.error("`persistent` option is only available in Deno");
      }
    }
  });
}

// https://deno.land/std@0.171.0/async/mux_async_iterator.ts
var MuxAsyncIterator = class {
  #iteratorCount = 0;
  #yields = [];
  // deno-lint-ignore no-explicit-any
  #throws = [];
  #signal = deferred();
  add(iterable) {
    ++this.#iteratorCount;
    this.#callIteratorNext(iterable[Symbol.asyncIterator]());
  }
  async #callIteratorNext(iterator) {
    try {
      const { value, done } = await iterator.next();
      if (done) {
        --this.#iteratorCount;
      } else {
        this.#yields.push({ iterator, value });
      }
    } catch (e3) {
      this.#throws.push(e3);
    }
    this.#signal.resolve();
  }
  async *iterate() {
    while (this.#iteratorCount > 0) {
      await this.#signal;
      for (let i2 = 0; i2 < this.#yields.length; i2++) {
        const { iterator, value } = this.#yields[i2];
        yield value;
        this.#callIteratorNext(iterator);
      }
      if (this.#throws.length) {
        for (const e3 of this.#throws) {
          throw e3;
        }
        this.#throws.length = 0;
      }
      this.#yields.length = 0;
      this.#signal = deferred();
    }
  }
  [Symbol.asyncIterator]() {
    return this.iterate();
  }
};

// https://deno.land/std@0.167.0/fmt/colors.ts
var colors_exports = {};
__export(colors_exports, {
  bgBlack: () => bgBlack,
  bgBlue: () => bgBlue,
  bgBrightBlack: () => bgBrightBlack,
  bgBrightBlue: () => bgBrightBlue,
  bgBrightCyan: () => bgBrightCyan,
  bgBrightGreen: () => bgBrightGreen,
  bgBrightMagenta: () => bgBrightMagenta,
  bgBrightRed: () => bgBrightRed,
  bgBrightWhite: () => bgBrightWhite,
  bgBrightYellow: () => bgBrightYellow,
  bgCyan: () => bgCyan,
  bgGreen: () => bgGreen,
  bgMagenta: () => bgMagenta,
  bgRed: () => bgRed,
  bgRgb24: () => bgRgb24,
  bgRgb8: () => bgRgb8,
  bgWhite: () => bgWhite,
  bgYellow: () => bgYellow,
  black: () => black,
  blue: () => blue,
  bold: () => bold,
  brightBlack: () => brightBlack,
  brightBlue: () => brightBlue,
  brightCyan: () => brightCyan,
  brightGreen: () => brightGreen,
  brightMagenta: () => brightMagenta,
  brightRed: () => brightRed,
  brightWhite: () => brightWhite,
  brightYellow: () => brightYellow,
  cyan: () => cyan,
  dim: () => dim,
  getColorEnabled: () => getColorEnabled,
  gray: () => gray,
  green: () => green,
  hidden: () => hidden,
  inverse: () => inverse,
  italic: () => italic,
  magenta: () => magenta,
  red: () => red,
  reset: () => reset,
  rgb24: () => rgb24,
  rgb8: () => rgb8,
  setColorEnabled: () => setColorEnabled,
  strikethrough: () => strikethrough,
  stripColor: () => stripColor,
  underline: () => underline,
  white: () => white,
  yellow: () => yellow
});
var { Deno: Deno2 } = globalThis;
var noColor = typeof Deno2?.noColor === "boolean" ? Deno2.noColor : true;
var enabled = !noColor;
function setColorEnabled(value) {
  if (noColor) {
    return;
  }
  enabled = value;
}
function getColorEnabled() {
  return enabled;
}
function code(open, close) {
  return {
    open: `\x1B[${open.join(";")}m`,
    close: `\x1B[${close}m`,
    regexp: new RegExp(`\\x1b\\[${close}m`, "g")
  };
}
function run(str, code2) {
  return enabled ? `${code2.open}${str.replace(code2.regexp, code2.open)}${code2.close}` : str;
}
function reset(str) {
  return run(str, code([0], 0));
}
function bold(str) {
  return run(str, code([1], 22));
}
function dim(str) {
  return run(str, code([2], 22));
}
function italic(str) {
  return run(str, code([3], 23));
}
function underline(str) {
  return run(str, code([4], 24));
}
function inverse(str) {
  return run(str, code([7], 27));
}
function hidden(str) {
  return run(str, code([8], 28));
}
function strikethrough(str) {
  return run(str, code([9], 29));
}
function black(str) {
  return run(str, code([30], 39));
}
function red(str) {
  return run(str, code([31], 39));
}
function green(str) {
  return run(str, code([32], 39));
}
function yellow(str) {
  return run(str, code([33], 39));
}
function blue(str) {
  return run(str, code([34], 39));
}
function magenta(str) {
  return run(str, code([35], 39));
}
function cyan(str) {
  return run(str, code([36], 39));
}
function white(str) {
  return run(str, code([37], 39));
}
function gray(str) {
  return brightBlack(str);
}
function brightBlack(str) {
  return run(str, code([90], 39));
}
function brightRed(str) {
  return run(str, code([91], 39));
}
function brightGreen(str) {
  return run(str, code([92], 39));
}
function brightYellow(str) {
  return run(str, code([93], 39));
}
function brightBlue(str) {
  return run(str, code([94], 39));
}
function brightMagenta(str) {
  return run(str, code([95], 39));
}
function brightCyan(str) {
  return run(str, code([96], 39));
}
function brightWhite(str) {
  return run(str, code([97], 39));
}
function bgBlack(str) {
  return run(str, code([40], 49));
}
function bgRed(str) {
  return run(str, code([41], 49));
}
function bgGreen(str) {
  return run(str, code([42], 49));
}
function bgYellow(str) {
  return run(str, code([43], 49));
}
function bgBlue(str) {
  return run(str, code([44], 49));
}
function bgMagenta(str) {
  return run(str, code([45], 49));
}
function bgCyan(str) {
  return run(str, code([46], 49));
}
function bgWhite(str) {
  return run(str, code([47], 49));
}
function bgBrightBlack(str) {
  return run(str, code([100], 49));
}
function bgBrightRed(str) {
  return run(str, code([101], 49));
}
function bgBrightGreen(str) {
  return run(str, code([102], 49));
}
function bgBrightYellow(str) {
  return run(str, code([103], 49));
}
function bgBrightBlue(str) {
  return run(str, code([104], 49));
}
function bgBrightMagenta(str) {
  return run(str, code([105], 49));
}
function bgBrightCyan(str) {
  return run(str, code([106], 49));
}
function bgBrightWhite(str) {
  return run(str, code([107], 49));
}
function clampAndTruncate(n3, max = 255, min = 0) {
  return Math.trunc(Math.max(Math.min(n3, max), min));
}
function rgb8(str, color) {
  return run(str, code([38, 5, clampAndTruncate(color)], 39));
}
function bgRgb8(str, color) {
  return run(str, code([48, 5, clampAndTruncate(color)], 49));
}
function rgb24(str, color) {
  if (typeof color === "number") {
    return run(
      str,
      code(
        [38, 2, color >> 16 & 255, color >> 8 & 255, color & 255],
        39
      )
    );
  }
  return run(
    str,
    code(
      [
        38,
        2,
        clampAndTruncate(color.r),
        clampAndTruncate(color.g),
        clampAndTruncate(color.b)
      ],
      39
    )
  );
}
function bgRgb24(str, color) {
  if (typeof color === "number") {
    return run(
      str,
      code(
        [48, 2, color >> 16 & 255, color >> 8 & 255, color & 255],
        49
      )
    );
  }
  return run(
    str,
    code(
      [
        48,
        2,
        clampAndTruncate(color.r),
        clampAndTruncate(color.g),
        clampAndTruncate(color.b)
      ],
      49
    )
  );
}
var ANSI_PATTERN = new RegExp(
  [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
  ].join("|"),
  "g"
);
function stripColor(string) {
  return string.replace(ANSI_PATTERN, "");
}

// https://deno.land/std@0.167.0/async/debounce.ts
function debounce(fn, wait) {
  let timeout = null;
  let flush = null;
  const debounced = (...args) => {
    debounced.clear();
    flush = () => {
      debounced.clear();
      fn.call(debounced, ...args);
    };
    timeout = setTimeout(flush, wait);
  };
  debounced.clear = () => {
    if (typeof timeout === "number") {
      clearTimeout(timeout);
      timeout = null;
      flush = null;
    }
  };
  debounced.flush = () => {
    flush?.();
  };
  Object.defineProperty(debounced, "pending", {
    get: () => typeof timeout === "number"
  });
  return debounced;
}

// https://deno.land/std@0.170.0/async/retry.ts
var RetryError = class extends Error {
  constructor(cause, count2) {
    super(`Exceeded max retry count (${count2})`);
    this.name = "RetryError";
    this.cause = cause;
  }
};
var defaultRetryOptions = {
  multiplier: 2,
  maxTimeout: 6e4,
  maxAttempts: 5,
  minTimeout: 1e3
};
async function retry(fn, opts) {
  const options2 = {
    ...defaultRetryOptions,
    ...opts
  };
  if (options2.maxTimeout >= 0 && options2.minTimeout > options2.maxTimeout) {
    throw new RangeError("minTimeout is greater than maxTimeout");
  }
  let timeout = options2.minTimeout;
  let error;
  for (let i2 = 0; i2 < options2.maxAttempts; i2++) {
    try {
      return await fn();
    } catch (err) {
      await new Promise((r) => setTimeout(r, timeout));
      timeout *= options2.multiplier;
      timeout = Math.max(timeout, options2.minTimeout);
      if (options2.maxTimeout >= 0) {
        timeout = Math.min(timeout, options2.maxTimeout);
      }
      error = err;
    }
  }
  throw new RetryError(error, options2.maxAttempts);
}

// https://esm.sh/stable/preact@10.11.0/deno/preact.js
var P;
var d;
var $;
var Y;
var S;
var F;
var B;
var T = {};
var V = [];
var Z = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function k(e3, t4) {
  for (var _2 in t4)
    e3[_2] = t4[_2];
  return e3;
}
function j(e3) {
  var t4 = e3.parentNode;
  t4 && t4.removeChild(e3);
}
function ee(e3, t4, _2) {
  var r, l2, o3, s4 = {};
  for (o3 in t4)
    o3 == "key" ? r = t4[o3] : o3 == "ref" ? l2 = t4[o3] : s4[o3] = t4[o3];
  if (arguments.length > 2 && (s4.children = arguments.length > 3 ? P.call(arguments, 2) : _2), typeof e3 == "function" && e3.defaultProps != null)
    for (o3 in e3.defaultProps)
      s4[o3] === void 0 && (s4[o3] = e3.defaultProps[o3]);
  return w(e3, s4, r, l2, null);
}
function w(e3, t4, _2, r, l2) {
  var o3 = { type: e3, props: t4, key: _2, ref: r, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: l2 ?? ++$ };
  return l2 == null && d.vnode != null && d.vnode(o3), o3;
}
function L(e3) {
  return e3.children;
}
function U(e3, t4) {
  this.props = e3, this.context = t4;
}
function C(e3, t4) {
  if (t4 == null)
    return e3.__ ? C(e3.__, e3.__.__k.indexOf(e3) + 1) : null;
  for (var _2; t4 < e3.__k.length; t4++)
    if ((_2 = e3.__k[t4]) != null && _2.__e != null)
      return _2.__e;
  return typeof e3.type == "function" ? C(e3) : null;
}
function z(e3) {
  var t4, _2;
  if ((e3 = e3.__) != null && e3.__c != null) {
    for (e3.__e = e3.__c.base = null, t4 = 0; t4 < e3.__k.length; t4++)
      if ((_2 = e3.__k[t4]) != null && _2.__e != null) {
        e3.__e = e3.__c.base = _2.__e;
        break;
      }
    return z(e3);
  }
}
function M(e3) {
  (!e3.__d && (e3.__d = true) && S.push(e3) && !D.__r++ || F !== d.debounceRendering) && ((F = d.debounceRendering) || setTimeout)(D);
}
function D() {
  for (var e3; D.__r = S.length; )
    e3 = S.sort(function(t4, _2) {
      return t4.__v.__b - _2.__v.__b;
    }), S = [], e3.some(function(t4) {
      var _2, r, l2, o3, s4, f4;
      t4.__d && (s4 = (o3 = (_2 = t4).__v).__e, (f4 = _2.__P) && (r = [], (l2 = k({}, o3)).__v = o3.__v + 1, W(f4, o3, l2, _2.__n, f4.ownerSVGElement !== void 0, o3.__h != null ? [s4] : null, r, s4 ?? C(o3), o3.__h), K(r, o3), o3.__e != s4 && z(o3)));
    });
}
function G(e3, t4, _2, r, l2, o3, s4, f4, p6, a4) {
  var n3, h3, c3, i2, u3, b4, v2, y3 = r && r.__k || V, g5 = y3.length;
  for (_2.__k = [], n3 = 0; n3 < t4.length; n3++)
    if ((i2 = _2.__k[n3] = (i2 = t4[n3]) == null || typeof i2 == "boolean" ? null : typeof i2 == "string" || typeof i2 == "number" || typeof i2 == "bigint" ? w(null, i2, null, null, i2) : Array.isArray(i2) ? w(L, { children: i2 }, null, null, null) : i2.__b > 0 ? w(i2.type, i2.props, i2.key, i2.ref ? i2.ref : null, i2.__v) : i2) != null) {
      if (i2.__ = _2, i2.__b = _2.__b + 1, (c3 = y3[n3]) === null || c3 && i2.key == c3.key && i2.type === c3.type)
        y3[n3] = void 0;
      else
        for (h3 = 0; h3 < g5; h3++) {
          if ((c3 = y3[h3]) && i2.key == c3.key && i2.type === c3.type) {
            y3[h3] = void 0;
            break;
          }
          c3 = null;
        }
      W(e3, i2, c3 = c3 || T, l2, o3, s4, f4, p6, a4), u3 = i2.__e, (h3 = i2.ref) && c3.ref != h3 && (v2 || (v2 = []), c3.ref && v2.push(c3.ref, null, i2), v2.push(h3, i2.__c || u3, i2)), u3 != null ? (b4 == null && (b4 = u3), typeof i2.type == "function" && i2.__k === c3.__k ? i2.__d = p6 = q(i2, p6, e3) : p6 = J(e3, i2, c3, y3, u3, p6), typeof _2.type == "function" && (_2.__d = p6)) : p6 && c3.__e == p6 && p6.parentNode != e3 && (p6 = C(c3));
    }
  for (_2.__e = b4, n3 = g5; n3--; )
    y3[n3] != null && (typeof _2.type == "function" && y3[n3].__e != null && y3[n3].__e == _2.__d && (_2.__d = C(r, n3 + 1)), X(y3[n3], y3[n3]));
  if (v2)
    for (n3 = 0; n3 < v2.length; n3++)
      Q(v2[n3], v2[++n3], v2[++n3]);
}
function q(e3, t4, _2) {
  for (var r, l2 = e3.__k, o3 = 0; l2 && o3 < l2.length; o3++)
    (r = l2[o3]) && (r.__ = e3, t4 = typeof r.type == "function" ? q(r, t4, _2) : J(_2, r, r, l2, r.__e, t4));
  return t4;
}
function J(e3, t4, _2, r, l2, o3) {
  var s4, f4, p6;
  if (t4.__d !== void 0)
    s4 = t4.__d, t4.__d = void 0;
  else if (_2 == null || l2 != o3 || l2.parentNode == null)
    e:
      if (o3 == null || o3.parentNode !== e3)
        e3.appendChild(l2), s4 = null;
      else {
        for (f4 = o3, p6 = 0; (f4 = f4.nextSibling) && p6 < r.length; p6 += 2)
          if (f4 == l2)
            break e;
        e3.insertBefore(l2, o3), s4 = o3;
      }
  return s4 !== void 0 ? s4 : l2.nextSibling;
}
function _e(e3, t4, _2, r, l2) {
  var o3;
  for (o3 in _2)
    o3 === "children" || o3 === "key" || o3 in t4 || N(e3, o3, null, _2[o3], r);
  for (o3 in t4)
    l2 && typeof t4[o3] != "function" || o3 === "children" || o3 === "key" || o3 === "value" || o3 === "checked" || _2[o3] === t4[o3] || N(e3, o3, t4[o3], _2[o3], r);
}
function I(e3, t4, _2) {
  t4[0] === "-" ? e3.setProperty(t4, _2) : e3[t4] = _2 == null ? "" : typeof _2 != "number" || Z.test(t4) ? _2 : _2 + "px";
}
function N(e3, t4, _2, r, l2) {
  var o3;
  e:
    if (t4 === "style")
      if (typeof _2 == "string")
        e3.style.cssText = _2;
      else {
        if (typeof r == "string" && (e3.style.cssText = r = ""), r)
          for (t4 in r)
            _2 && t4 in _2 || I(e3.style, t4, "");
        if (_2)
          for (t4 in _2)
            r && _2[t4] === r[t4] || I(e3.style, t4, _2[t4]);
      }
    else if (t4[0] === "o" && t4[1] === "n")
      o3 = t4 !== (t4 = t4.replace(/Capture$/, "")), t4 = t4.toLowerCase() in e3 ? t4.toLowerCase().slice(2) : t4.slice(2), e3.l || (e3.l = {}), e3.l[t4 + o3] = _2, _2 ? r || e3.addEventListener(t4, o3 ? R : O, o3) : e3.removeEventListener(t4, o3 ? R : O, o3);
    else if (t4 !== "dangerouslySetInnerHTML") {
      if (l2)
        t4 = t4.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if (t4 !== "href" && t4 !== "list" && t4 !== "form" && t4 !== "tabIndex" && t4 !== "download" && t4 in e3)
        try {
          e3[t4] = _2 ?? "";
          break e;
        } catch {
        }
      typeof _2 == "function" || (_2 != null && (_2 !== false || t4[0] === "a" && t4[1] === "r") ? e3.setAttribute(t4, _2) : e3.removeAttribute(t4));
    }
}
function O(e3) {
  this.l[e3.type + false](d.event ? d.event(e3) : e3);
}
function R(e3) {
  this.l[e3.type + true](d.event ? d.event(e3) : e3);
}
function W(e3, t4, _2, r, l2, o3, s4, f4, p6) {
  var a4, n3, h3, c3, i2, u3, b4, v2, y3, g5, x5, H7, E3, m4 = t4.type;
  if (t4.constructor !== void 0)
    return null;
  _2.__h != null && (p6 = _2.__h, f4 = t4.__e = _2.__e, t4.__h = null, o3 = [f4]), (a4 = d.__b) && a4(t4);
  try {
    e:
      if (typeof m4 == "function") {
        if (v2 = t4.props, y3 = (a4 = m4.contextType) && r[a4.__c], g5 = a4 ? y3 ? y3.props.value : a4.__ : r, _2.__c ? b4 = (n3 = t4.__c = _2.__c).__ = n3.__E : ("prototype" in m4 && m4.prototype.render ? t4.__c = n3 = new m4(v2, g5) : (t4.__c = n3 = new U(v2, g5), n3.constructor = m4, n3.render = oe), y3 && y3.sub(n3), n3.props = v2, n3.state || (n3.state = {}), n3.context = g5, n3.__n = r, h3 = n3.__d = true, n3.__h = []), n3.__s == null && (n3.__s = n3.state), m4.getDerivedStateFromProps != null && (n3.__s == n3.state && (n3.__s = k({}, n3.__s)), k(n3.__s, m4.getDerivedStateFromProps(v2, n3.__s))), c3 = n3.props, i2 = n3.state, h3)
          m4.getDerivedStateFromProps == null && n3.componentWillMount != null && n3.componentWillMount(), n3.componentDidMount != null && n3.__h.push(n3.componentDidMount);
        else {
          if (m4.getDerivedStateFromProps == null && v2 !== c3 && n3.componentWillReceiveProps != null && n3.componentWillReceiveProps(v2, g5), !n3.__e && n3.shouldComponentUpdate != null && n3.shouldComponentUpdate(v2, n3.__s, g5) === false || t4.__v === _2.__v) {
            n3.props = v2, n3.state = n3.__s, t4.__v !== _2.__v && (n3.__d = false), n3.__v = t4, t4.__e = _2.__e, t4.__k = _2.__k, t4.__k.forEach(function(A5) {
              A5 && (A5.__ = t4);
            }), n3.__h.length && s4.push(n3);
            break e;
          }
          n3.componentWillUpdate != null && n3.componentWillUpdate(v2, n3.__s, g5), n3.componentDidUpdate != null && n3.__h.push(function() {
            n3.componentDidUpdate(c3, i2, u3);
          });
        }
        if (n3.context = g5, n3.props = v2, n3.__v = t4, n3.__P = e3, x5 = d.__r, H7 = 0, "prototype" in m4 && m4.prototype.render)
          n3.state = n3.__s, n3.__d = false, x5 && x5(t4), a4 = n3.render(n3.props, n3.state, n3.context);
        else
          do
            n3.__d = false, x5 && x5(t4), a4 = n3.render(n3.props, n3.state, n3.context), n3.state = n3.__s;
          while (n3.__d && ++H7 < 25);
        n3.state = n3.__s, n3.getChildContext != null && (r = k(k({}, r), n3.getChildContext())), h3 || n3.getSnapshotBeforeUpdate == null || (u3 = n3.getSnapshotBeforeUpdate(c3, i2)), E3 = a4 != null && a4.type === L && a4.key == null ? a4.props.children : a4, G(e3, Array.isArray(E3) ? E3 : [E3], t4, _2, r, l2, o3, s4, f4, p6), n3.base = t4.__e, t4.__h = null, n3.__h.length && s4.push(n3), b4 && (n3.__E = n3.__ = null), n3.__e = false;
      } else
        o3 == null && t4.__v === _2.__v ? (t4.__k = _2.__k, t4.__e = _2.__e) : t4.__e = ne(_2.__e, t4, _2, r, l2, o3, s4, p6);
    (a4 = d.diffed) && a4(t4);
  } catch (A5) {
    t4.__v = null, (p6 || o3 != null) && (t4.__e = f4, t4.__h = !!p6, o3[o3.indexOf(f4)] = null), d.__e(A5, t4, _2);
  }
}
function K(e3, t4) {
  d.__c && d.__c(t4, e3), e3.some(function(_2) {
    try {
      e3 = _2.__h, _2.__h = [], e3.some(function(r) {
        r.call(_2);
      });
    } catch (r) {
      d.__e(r, _2.__v);
    }
  });
}
function ne(e3, t4, _2, r, l2, o3, s4, f4) {
  var p6, a4, n3, h3 = _2.props, c3 = t4.props, i2 = t4.type, u3 = 0;
  if (i2 === "svg" && (l2 = true), o3 != null) {
    for (; u3 < o3.length; u3++)
      if ((p6 = o3[u3]) && "setAttribute" in p6 == !!i2 && (i2 ? p6.localName === i2 : p6.nodeType === 3)) {
        e3 = p6, o3[u3] = null;
        break;
      }
  }
  if (e3 == null) {
    if (i2 === null)
      return document.createTextNode(c3);
    e3 = l2 ? document.createElementNS("http://www.w3.org/2000/svg", i2) : document.createElement(i2, c3.is && c3), o3 = null, f4 = false;
  }
  if (i2 === null)
    h3 === c3 || f4 && e3.data === c3 || (e3.data = c3);
  else {
    if (o3 = o3 && P.call(e3.childNodes), a4 = (h3 = _2.props || T).dangerouslySetInnerHTML, n3 = c3.dangerouslySetInnerHTML, !f4) {
      if (o3 != null)
        for (h3 = {}, u3 = 0; u3 < e3.attributes.length; u3++)
          h3[e3.attributes[u3].name] = e3.attributes[u3].value;
      (n3 || a4) && (n3 && (a4 && n3.__html == a4.__html || n3.__html === e3.innerHTML) || (e3.innerHTML = n3 && n3.__html || ""));
    }
    if (_e(e3, c3, h3, l2, f4), n3)
      t4.__k = [];
    else if (u3 = t4.props.children, G(e3, Array.isArray(u3) ? u3 : [u3], t4, _2, r, l2 && i2 !== "foreignObject", o3, s4, o3 ? o3[0] : _2.__k && C(_2, 0), f4), o3 != null)
      for (u3 = o3.length; u3--; )
        o3[u3] != null && j(o3[u3]);
    f4 || ("value" in c3 && (u3 = c3.value) !== void 0 && (u3 !== e3.value || i2 === "progress" && !u3 || i2 === "option" && u3 !== h3.value) && N(e3, "value", u3, h3.value, false), "checked" in c3 && (u3 = c3.checked) !== void 0 && u3 !== e3.checked && N(e3, "checked", u3, h3.checked, false));
  }
  return e3;
}
function Q(e3, t4, _2) {
  try {
    typeof e3 == "function" ? e3(t4) : e3.current = t4;
  } catch (r) {
    d.__e(r, _2);
  }
}
function X(e3, t4, _2) {
  var r, l2;
  if (d.unmount && d.unmount(e3), (r = e3.ref) && (r.current && r.current !== e3.__e || Q(r, null, t4)), (r = e3.__c) != null) {
    if (r.componentWillUnmount)
      try {
        r.componentWillUnmount();
      } catch (o3) {
        d.__e(o3, t4);
      }
    r.base = r.__P = null, e3.__c = void 0;
  }
  if (r = e3.__k)
    for (l2 = 0; l2 < r.length; l2++)
      r[l2] && X(r[l2], t4, typeof e3.type != "function");
  _2 || e3.__e == null || j(e3.__e), e3.__ = e3.__e = e3.__d = void 0;
}
function oe(e3, t4, _2) {
  return this.constructor(e3, _2);
}
function re(e3, t4, _2) {
  var r, l2, o3;
  d.__ && d.__(e3, t4), l2 = (r = typeof _2 == "function") ? null : _2 && _2.__k || t4.__k, o3 = [], W(t4, e3 = (!r && _2 || t4).__k = ee(L, null, [e3]), l2 || T, T, t4.ownerSVGElement !== void 0, !r && _2 ? [_2] : l2 ? null : t4.firstChild ? P.call(t4.childNodes) : null, o3, !r && _2 ? _2 : l2 ? l2.__e : t4.firstChild, r), K(o3, e3);
}
function ce(e3, t4) {
  var _2 = { __c: t4 = "__cC" + B++, __: e3, Consumer: function(r, l2) {
    return r.children(l2);
  }, Provider: function(r) {
    var l2, o3;
    return this.getChildContext || (l2 = [], (o3 = {})[t4] = this, this.getChildContext = function() {
      return o3;
    }, this.shouldComponentUpdate = function(s4) {
      this.props.value !== s4.value && l2.some(M);
    }, this.sub = function(s4) {
      l2.push(s4);
      var f4 = s4.componentWillUnmount;
      s4.componentWillUnmount = function() {
        l2.splice(l2.indexOf(s4), 1), f4 && f4.call(s4);
      };
    }), r.children;
  } };
  return _2.Provider.__ = _2.Consumer.contextType = _2;
}
P = V.slice, d = { __e: function(e3, t4, _2, r) {
  for (var l2, o3, s4; t4 = t4.__; )
    if ((l2 = t4.__c) && !l2.__)
      try {
        if ((o3 = l2.constructor) && o3.getDerivedStateFromError != null && (l2.setState(o3.getDerivedStateFromError(e3)), s4 = l2.__d), l2.componentDidCatch != null && (l2.componentDidCatch(e3, r || {}), s4 = l2.__d), s4)
          return l2.__E = l2;
      } catch (f4) {
        e3 = f4;
      }
  throw e3;
} }, $ = 0, Y = function(e3) {
  return e3 != null && e3.constructor === void 0;
}, U.prototype.setState = function(e3, t4) {
  var _2;
  _2 = this.__s != null && this.__s !== this.state ? this.__s : this.__s = k({}, this.state), typeof e3 == "function" && (e3 = e3(k({}, _2), this.props)), e3 && k(_2, e3), e3 != null && this.__v && (t4 && this.__h.push(t4), M(this));
}, U.prototype.forceUpdate = function(e3) {
  this.__v && (this.__e = true, e3 && this.__h.push(e3), M(this));
}, U.prototype.render = L, S = [], D.__r = 0, B = 0;

// https://esm.sh/stable/preact@10.11.0/deno/hooks.js
var i;
var n;
var d2;
var N2;
var f = 0;
var q2 = [];
var l = [];
var V2 = d.__b;
var g = d.__r;
var b = d.diffed;
var C2 = d.__c;
var A = d.unmount;
function a(_2, t4) {
  d.__h && d.__h(n, _2, f || t4), f = 0;
  var u3 = n.__H || (n.__H = { __: [], __h: [] });
  return _2 >= u3.__.length && u3.__.push({ __V: l }), u3.__[_2];
}
function P2(_2) {
  return f = 1, B2(D2, _2);
}
function B2(_2, t4, u3) {
  var o3 = a(i++, 2);
  if (o3.t = _2, !o3.__c && (o3.__ = [u3 ? u3(t4) : D2(void 0, t4), function(v2) {
    var s4 = o3.__N ? o3.__N[0] : o3.__[0], h3 = o3.t(s4, v2);
    s4 !== h3 && (o3.__N = [h3, o3.__[1]], o3.__c.setState({}));
  }], o3.__c = n, !n.u)) {
    n.u = true;
    var r = n.shouldComponentUpdate;
    n.shouldComponentUpdate = function(v2, s4, h3) {
      if (!o3.__c.__H)
        return true;
      var y3 = o3.__c.__H.__.filter(function(c3) {
        return c3.__c;
      });
      if (y3.every(function(c3) {
        return !c3.__N;
      }))
        return !r || r.call(this, v2, s4, h3);
      var E3 = false;
      return y3.forEach(function(c3) {
        if (c3.__N) {
          var k4 = c3.__[0];
          c3.__ = c3.__N, c3.__N = void 0, k4 !== c3.__[0] && (E3 = true);
        }
      }), !!E3 && (!r || r.call(this, v2, s4, h3));
    };
  }
  return o3.__N || o3.__;
}
function j2(_2, t4) {
  var u3 = a(i++, 3);
  !d.__s && H(u3.__H, t4) && (u3.__ = _2, u3.i = t4, n.__H.__h.push(u3));
}
function w2(_2) {
  return f = 5, x(function() {
    return { current: _2 };
  }, []);
}
function x(_2, t4) {
  var u3 = a(i++, 7);
  return H(u3.__H, t4) ? (u3.__V = _2(), u3.i = t4, u3.__h = _2, u3.__V) : u3.__;
}
function L2(_2, t4) {
  return f = 8, x(function() {
    return _2;
  }, t4);
}
function M2(_2) {
  var t4 = n.context[_2.__c], u3 = a(i++, 9);
  return u3.c = _2, t4 ? (u3.__ == null && (u3.__ = true, t4.sub(n)), t4.props.value) : _2.__;
}
function R2() {
  for (var _2; _2 = q2.shift(); )
    if (_2.__P && _2.__H)
      try {
        _2.__H.__h.forEach(m), _2.__H.__h.forEach(p), _2.__H.__h = [];
      } catch (t4) {
        _2.__H.__h = [], d.__e(t4, _2.__v);
      }
}
d.__b = function(_2) {
  typeof _2.type != "function" || _2.o || _2.type === L ? _2.o || (_2.o = _2.__ && _2.__.o ? _2.__.o : "") : _2.o = (_2.__ && _2.__.o ? _2.__.o : "") + (_2.__ && _2.__.__k ? _2.__.__k.indexOf(_2) : 0), n = null, V2 && V2(_2);
}, d.__r = function(_2) {
  g && g(_2), i = 0;
  var t4 = (n = _2.__c).__H;
  t4 && (d2 === n ? (t4.__h = [], n.__h = [], t4.__.forEach(function(u3) {
    u3.__N && (u3.__ = u3.__N), u3.__V = l, u3.__N = u3.i = void 0;
  })) : (t4.__h.forEach(m), t4.__h.forEach(p), t4.__h = [])), d2 = n;
}, d.diffed = function(_2) {
  b && b(_2);
  var t4 = _2.__c;
  t4 && t4.__H && (t4.__H.__h.length && (q2.push(t4) !== 1 && N2 === d.requestAnimationFrame || ((N2 = d.requestAnimationFrame) || S2)(R2)), t4.__H.__.forEach(function(u3) {
    u3.i && (u3.__H = u3.i), u3.__V !== l && (u3.__ = u3.__V), u3.i = void 0, u3.__V = l;
  })), d2 = n = null;
}, d.__c = function(_2, t4) {
  t4.some(function(u3) {
    try {
      u3.__h.forEach(m), u3.__h = u3.__h.filter(function(o3) {
        return !o3.__ || p(o3);
      });
    } catch (o3) {
      t4.some(function(r) {
        r.__h && (r.__h = []);
      }), t4 = [], d.__e(o3, u3.__v);
    }
  }), C2 && C2(_2, t4);
}, d.unmount = function(_2) {
  A && A(_2);
  var t4, u3 = _2.__c;
  u3 && u3.__H && (u3.__H.__.forEach(function(o3) {
    try {
      m(o3);
    } catch (r) {
      t4 = r;
    }
  }), u3.__H = void 0, t4 && d.__e(t4, u3.__v));
};
var F2 = typeof requestAnimationFrame == "function";
function S2(_2) {
  var t4, u3 = function() {
    clearTimeout(o3), F2 && cancelAnimationFrame(t4), setTimeout(_2);
  }, o3 = setTimeout(u3, 100);
  F2 && (t4 = requestAnimationFrame(u3));
}
function m(_2) {
  var t4 = n, u3 = _2.__c;
  typeof u3 == "function" && (_2.__c = void 0, u3()), n = t4;
}
function p(_2) {
  var t4 = n;
  _2.__c = _2.__(), n = t4;
}
function H(_2, t4) {
  return !_2 || _2.length !== t4.length || t4.some(function(u3, o3) {
    return u3 !== _2[o3];
  });
}
function D2(_2, t4) {
  return typeof t4 == "function" ? t4(_2) : t4;
}

// https://esm.sh/v106/memoize-one@6.0.0/deno/memoize-one.js
var s = Number.isNaN || function(r) {
  return typeof r == "number" && r !== r;
};

// https://esm.sh/v106/p-throttle@5.0.0/deno/p-throttle.js
var a2 = class extends Error {
  constructor() {
    super("Throttled function aborted"), this.name = "AbortError";
  }
};
function m2({ limit: i2, interval: s4, strict: f4 }) {
  if (!Number.isFinite(i2))
    throw new TypeError("Expected `limit` to be a finite number");
  if (!Number.isFinite(s4))
    throw new TypeError("Expected `interval` to be a finite number");
  let r = /* @__PURE__ */ new Map(), u3 = 0, c3 = 0;
  function p6() {
    let e3 = Date.now();
    return e3 - u3 > s4 ? (c3 = 1, u3 = e3, 0) : (c3 < i2 ? c3++ : (u3 += s4, c3 = 1), u3 - e3);
  }
  let n3 = [];
  function h3() {
    let e3 = Date.now();
    if (n3.length < i2)
      return n3.push(e3), 0;
    let t4 = n3.shift() + s4;
    return e3 >= t4 ? (n3.push(e3), 0) : (n3.push(t4), t4 - e3);
  }
  let w4 = f4 ? h3 : p6;
  return (e3) => {
    let t4 = function(...o3) {
      if (!t4.isEnabled)
        return (async () => e3.apply(this, o3))();
      let l2;
      return new Promise((d3, b4) => {
        l2 = setTimeout(() => {
          d3(e3.apply(this, o3)), r.delete(l2);
        }, w4()), r.set(l2, b4);
      });
    };
    return t4.abort = () => {
      for (let o3 of r.keys())
        clearTimeout(o3), r.get(o3)(new a2());
      r.clear(), n3.splice(0, n3.length);
    }, t4.isEnabled = true, t4;
  };
}

// https://esm.sh/v106/lodash.throttle@4.1.1/deno/lodash.throttle.js
var __global$ = globalThis || (typeof window !== "undefined" ? window : self);
var A2 = Object.create;
var h = Object.defineProperty;
var B3 = Object.getOwnPropertyDescriptor;
var F3 = Object.getOwnPropertyNames;
var R3 = Object.getPrototypeOf;
var P3 = Object.prototype.hasOwnProperty;
var D3 = (e3, n3) => () => (n3 || e3((n3 = { exports: {} }).exports, n3), n3.exports);
var G2 = (e3, n3, t4, f4) => {
  if (n3 && typeof n3 == "object" || typeof n3 == "function")
    for (let i2 of F3(n3))
      !P3.call(e3, i2) && i2 !== t4 && h(e3, i2, { get: () => n3[i2], enumerable: !(f4 = B3(n3, i2)) || f4.enumerable });
  return e3;
};
var H2 = (e3, n3, t4) => (t4 = e3 != null ? A2(R3(e3)) : {}, G2(n3 || !e3 || !e3.__esModule ? h(t4, "default", { value: e3, enumerable: true }) : t4, e3));
var L3 = D3((ce4, k4) => {
  var _2 = "Expected a function", S7 = NaN, U5 = "[object Symbol]", X6 = /^\s+|\s+$/g, q6 = /^[-+]0x[0-9a-f]+$/i, z4 = /^0b[01]+$/i, J4 = /^0o[0-7]+$/i, K6 = parseInt, Q6 = typeof __global$ == "object" && __global$ && __global$.Object === Object && __global$, V6 = typeof self == "object" && self && self.Object === Object && self, Y6 = Q6 || V6 || Function("return this")(), Z5 = Object.prototype, w4 = Z5.toString, ee4 = Math.max, ne4 = Math.min, j5 = function() {
    return Y6.Date.now();
  };
  function te2(e3, n3, t4) {
    var f4, i2, g5, c3, a4, u3, l2 = 0, v2 = false, s4 = false, y3 = true;
    if (typeof e3 != "function")
      throw new TypeError(_2);
    n3 = E3(n3) || 0, b4(t4) && (v2 = !!t4.leading, s4 = "maxWait" in t4, g5 = s4 ? ee4(E3(t4.maxWait) || 0, n3) : g5, y3 = "trailing" in t4 ? !!t4.trailing : y3);
    function p6(r) {
      var o3 = f4, d3 = i2;
      return f4 = i2 = void 0, l2 = r, c3 = e3.apply(d3, o3), c3;
    }
    function C5(r) {
      return l2 = r, a4 = setTimeout(m4, n3), v2 ? p6(r) : c3;
    }
    function M5(r) {
      var o3 = r - u3, d3 = r - l2, O4 = n3 - o3;
      return s4 ? ne4(O4, g5 - d3) : O4;
    }
    function x5(r) {
      var o3 = r - u3, d3 = r - l2;
      return u3 === void 0 || o3 >= n3 || o3 < 0 || s4 && d3 >= g5;
    }
    function m4() {
      var r = j5();
      if (x5(r))
        return I5(r);
      a4 = setTimeout(m4, M5(r));
    }
    function I5(r) {
      return a4 = void 0, y3 && f4 ? p6(r) : (f4 = i2 = void 0, c3);
    }
    function N7() {
      a4 !== void 0 && clearTimeout(a4), l2 = 0, f4 = u3 = i2 = a4 = void 0;
    }
    function $4() {
      return a4 === void 0 ? c3 : I5(j5());
    }
    function T6() {
      var r = j5(), o3 = x5(r);
      if (f4 = arguments, i2 = this, u3 = r, o3) {
        if (a4 === void 0)
          return C5(u3);
        if (s4)
          return a4 = setTimeout(m4, n3), p6(u3);
      }
      return a4 === void 0 && (a4 = setTimeout(m4, n3)), c3;
    }
    return T6.cancel = N7, T6.flush = $4, T6;
  }
  function re4(e3, n3, t4) {
    var f4 = true, i2 = true;
    if (typeof e3 != "function")
      throw new TypeError(_2);
    return b4(t4) && (f4 = "leading" in t4 ? !!t4.leading : f4, i2 = "trailing" in t4 ? !!t4.trailing : i2), te2(e3, n3, { leading: f4, maxWait: n3, trailing: i2 });
  }
  function b4(e3) {
    var n3 = typeof e3;
    return !!e3 && (n3 == "object" || n3 == "function");
  }
  function ie4(e3) {
    return !!e3 && typeof e3 == "object";
  }
  function fe(e3) {
    return typeof e3 == "symbol" || ie4(e3) && w4.call(e3) == U5;
  }
  function E3(e3) {
    if (typeof e3 == "number")
      return e3;
    if (fe(e3))
      return S7;
    if (b4(e3)) {
      var n3 = typeof e3.valueOf == "function" ? e3.valueOf() : e3;
      e3 = b4(n3) ? n3 + "" : n3;
    }
    if (typeof e3 != "string")
      return e3 === 0 ? e3 : +e3;
    e3 = e3.replace(X6, "");
    var t4 = z4.test(e3);
    return t4 || J4.test(e3) ? K6(e3.slice(2), t4 ? 2 : 8) : q6.test(e3) ? S7 : +e3;
  }
  k4.exports = re4;
});
var ae = H2(L3());
var { default: W2, ...oe2 } = ae;
var le = W2 !== void 0 ? W2 : oe2;

// https://esm.sh/v106/@twind/core@1.0.1/deno/core.js
var F4;
function lt(t4) {
  return [...t4.v, (t4.i ? "!" : "") + t4.n].join(":");
}
function st(t4, e3 = ",") {
  return t4.map(lt).join(e3);
}
var W3 = typeof CSS < "u" && CSS.escape || ((t4) => t4.replace(/[!"'`*+.,;:\\/<=>?@#$%&^|~()[\]{}]/g, "\\$&").replace(/^\d/, "\\3$& "));
function V3(t4) {
  for (var e3 = 9, r = t4.length; r--; )
    e3 = Math.imul(e3 ^ t4.charCodeAt(r), 1597334677);
  return "#" + ((e3 ^ e3 >>> 9) >>> 0).toString(36);
}
function kt(t4, e3 = "@media ") {
  return e3 + x2(t4).map((r) => (typeof r == "string" && (r = { min: r }), r.raw || Object.keys(r).map((n3) => `(${n3}-width:${r[n3]})`).join(" and "))).join(",");
}
function x2(t4 = []) {
  return Array.isArray(t4) ? t4 : t4 == null ? [] : [t4];
}
function D4() {
}
var w3 = { d: 0, b: 134217728, c: 268435456, a: 671088640, u: 805306368, o: 939524096 };
function jt(t4) {
  var e3;
  return ((e3 = t4.match(/[-=:;]/g)) == null ? void 0 : e3.length) || 0;
}
function X2(t4) {
  return Math.min(/(?:^|width[^\d]+)(\d+(?:.\d+)?)(p)?/.test(t4) ? +RegExp.$1 / (RegExp.$2 ? 15 : 1) / 10 : 0, 15) << 22 | Math.min(jt(t4), 15) << 18;
}
var qt = ["rst-c", "st-ch", "h-chi", "y-lin", "nk", "sited", "ecked", "pty", "ad-on", "cus-w", "ver", "cus", "cus-v", "tive", "sable", "tiona", "quire"];
function at({ n: t4, i: e3, v: r = [] }, n3, i2, l2) {
  for (let a4 of (t4 && (t4 = lt({ n: t4, i: e3, v: r })), l2 = [...x2(l2)], r)) {
    let s4 = n3.theme("screens", a4);
    for (let u3 of x2(s4 && kt(s4) || n3.v(a4))) {
      var o3;
      l2.push(u3), i2 |= s4 ? 67108864 | X2(u3) : a4 == "dark" ? 1073741824 : u3[0] == "@" ? X2(u3) : (o3 = u3, 1 << ~(/:([a-z-]+)/.test(o3) && ~qt.indexOf(RegExp.$1.slice(2, 7)) || -18));
    }
  }
  return { n: t4, p: i2, r: l2, i: e3 };
}
var ut = /* @__PURE__ */ new Map();
function tt(t4) {
  if (t4.d) {
    let e3 = [], r = Y2(t4.r.reduce((n3, i2) => i2[0] == "@" ? (e3.push(i2), n3) : i2 ? Y2(n3, (l2) => Y2(i2, (o3) => {
      let a4 = /(:merge\(.+?\))(:[a-z-]+|\\[.+])/.exec(o3);
      if (a4) {
        let s4 = l2.indexOf(a4[1]);
        return ~s4 ? l2.slice(0, s4) + a4[0] + l2.slice(s4 + a4[1].length) : Z2(l2, o3);
      }
      return Z2(o3, l2);
    })) : n3, "&"), (n3) => Z2(n3, t4.n ? "." + W3(t4.n) : ""));
    return r && e3.push(r.replace(/:merge\((.+?)\)/g, "$1")), e3.reduceRight((n3, i2) => i2 + "{" + n3 + "}", t4.d);
  }
}
function Y2(t4, e3) {
  return t4.replace(/ *((?:\(.+?\)|\[.+?\]|[^,])+) *(,|$)/g, (r, n3, i2) => e3(n3) + i2);
}
function Z2(t4, e3) {
  return t4.replace(/&/g, e3);
}
var Dt = new Intl.Collator("en", { numeric: true });
function St(t4, e3) {
  for (var r = 0, n3 = t4.length; r < n3; ) {
    let i2 = n3 + r >> 1;
    0 >= Mt(t4[i2], e3) ? r = i2 + 1 : n3 = i2;
  }
  return n3;
}
function Mt(t4, e3) {
  let r = t4.p & w3.o;
  return r == (e3.p & w3.o) && (r == w3.b || r == w3.o) ? 0 : t4.p - e3.p || t4.o - e3.o || Dt.compare(t4.n, e3.n);
}
function H3(t4, e3) {
  return Math.round(parseInt(t4, 16) * e3);
}
function T2(t4, e3 = {}) {
  if (typeof t4 == "function")
    return t4(e3);
  let { opacityValue: r = "1", opacityVariable: n3 } = e3, i2 = n3 ? `var(${n3})` : r;
  if (t4.includes("<alpha-value>"))
    return t4.replace("<alpha-value>", i2);
  if (t4[0] == "#" && (t4.length == 4 || t4.length == 7)) {
    let l2 = (t4.length - 1) / 3, o3 = [17, 1, 0.062272][l2 - 1];
    return `rgba(${[H3(t4.substr(1, l2), o3), H3(t4.substr(1 + l2, l2), o3), H3(t4.substr(1 + 2 * l2, l2), o3), i2]})`;
  }
  return i2 == "1" ? t4 : i2 == "0" ? "#0000" : t4.replace(/^(rgb|hsl)(\([^)]+)\)$/, `$1a$2,${i2})`);
}
function ct(t4, e3, r, n3, i2 = []) {
  return function l2(o3, { n: a4, p: s4, r: u3 = [], i: f4 }, c3) {
    let p6 = [], d3 = "", v2 = 0, g5 = 0;
    for (let h3 in o3 || {}) {
      var y3, A5;
      let b4 = o3[h3];
      if (h3[0] == "@") {
        if (!b4)
          continue;
        if (h3[1] == "a") {
          p6.push(...ht(a4, s4, N3("" + b4), c3, s4, u3, f4, true));
          continue;
        }
        if (h3[1] == "l") {
          for (let m4 of x2(b4))
            p6.push(...l2(m4, { n: a4, p: (y3 = w3[h3[7]], s4 & ~w3.o | y3), r: u3, i: f4 }, c3));
          continue;
        }
        if (h3[1] == "i") {
          p6.push(...x2(b4).map((m4) => ({ p: -1, o: 0, r: [], d: h3 + " " + m4 })));
          continue;
        }
        if (h3[1] == "k") {
          p6.push({ p: w3.d, o: 0, r: [h3], d: l2(b4, { p: w3.d }, c3).map(tt).join("") });
          continue;
        }
        if (h3[1] == "f") {
          p6.push(...x2(b4).map((m4) => ({ p: w3.d, o: 0, r: [h3], d: l2(m4, { p: w3.d }, c3).map(tt).join("") })));
          continue;
        }
      }
      if (typeof b4 != "object" || Array.isArray(b4))
        h3 == "label" && b4 ? a4 = b4 + V3(JSON.stringify([s4, f4, o3])) : (b4 || b4 === 0) && (h3 = h3.replace(/[A-Z]/g, (m4) => "-" + m4.toLowerCase()), g5 += 1, v2 = Math.max(v2, (A5 = h3)[0] == "-" ? 0 : jt(A5) + (/^(?:(border-(?!w|c|sty)|[tlbr].{2,4}m?$|c.{7}$)|([fl].{5}l|g.{8}$|pl))/.test(A5) ? +!!RegExp.$1 || -!!RegExp.$2 : 0) + 1), d3 += (d3 ? ";" : "") + x2(b4).map((m4) => c3.s(h3, ft("" + m4, c3.theme) + (f4 ? " !important" : ""))).join(";"));
      else if (h3[0] == "@" || h3.includes("&")) {
        let m4 = s4;
        h3[0] == "@" && (h3 = h3.replace(/\bscreen\(([^)]+)\)/g, (C5, $4) => {
          let j5 = c3.theme("screens", $4);
          return j5 ? (m4 |= 67108864, kt(j5, "")) : C5;
        }), m4 |= X2(h3)), p6.push(...l2(b4, { n: a4, p: m4, r: [...u3, h3], i: f4 }, c3));
      } else
        p6.push(...l2(b4, { p: s4, r: [...u3, h3] }, c3));
    }
    return p6.unshift({ n: a4, p: s4, o: Math.max(0, 15 - g5) + 1.5 * Math.min(v2 || 15, 15), r: u3, d: d3 }), p6.sort(Mt);
  }(t4, at(e3, r, n3, i2), r);
}
function ft(t4, e3) {
  return t4.replace(/theme\((["'`])?(.+?)\1(?:\s*,\s*(["'`])?(.+?)\3)?\)/g, (r, n3, i2, l2, o3) => {
    let a4 = e3(i2, o3);
    return typeof a4 == "function" && /color|fill|stroke/i.test(i2) ? T2(a4) : "" + a4;
  });
}
function pt(t4, e3) {
  let r, n3 = [];
  for (let i2 of t4)
    i2.d && i2.n ? r?.p == i2.p && "" + r.r == "" + i2.r ? (r.c = [r.c, i2.c].filter(Boolean).join(" "), r.d = r.d + ";" + i2.d) : n3.push(r = { ...i2, n: i2.n && e3 }) : n3.push({ ...i2, n: i2.n && e3 });
  return n3;
}
function B4(t4, e3, r = w3.u, n3, i2) {
  let l2 = [];
  for (let o3 of t4)
    for (let a4 of function(s4, u3, f4, c3, p6) {
      var d3;
      s4 = { ...s4, i: s4.i || p6 };
      let v2 = function(g5, y3) {
        let A5 = ut.get(g5.n);
        return A5 ? A5(g5, y3) : y3.r(g5.n, g5.v[0] == "dark");
      }(s4, u3);
      return v2 ? typeof v2 == "string" ? ({ r: c3, p: f4 } = at(s4, u3, f4, c3), pt(B4(N3(v2), u3, f4, c3, s4.i), s4.n)) : Array.isArray(v2) ? v2.map((g5) => {
        var y3, A5;
        return { o: 0, ...g5, r: [...x2(c3), ...x2(g5.r)], p: (y3 = f4, A5 = (d3 = g5.p) != null ? d3 : f4, y3 & ~w3.o | A5) };
      }) : ct(v2, s4, u3, f4, c3) : [{ c: lt(s4), p: 0, o: 0, r: [] }];
    }(o3, e3, r, n3, i2))
      l2.splice(St(l2, a4), 0, a4);
  return l2;
}
function ht(t4, e3, r, n3, i2, l2, o3, a4) {
  return pt((a4 ? r.flatMap((s4) => B4([s4], n3, i2, l2, o3)) : B4(r, n3, i2, l2, o3)).map((s4) => s4.p & w3.o && (s4.n || e3 == w3.b) ? { ...s4, p: s4.p & ~w3.o | e3, o: 0 } : s4), t4);
}
function Ot(t4, e3, r, n3) {
  var i2;
  return i2 = (l2, o3) => {
    let { n: a4, p: s4, r: u3, i: f4 } = at(l2, o3, e3);
    return r && ht(a4, e3, r, o3, s4, u3, f4, n3);
  }, ut.set(t4, i2), t4;
}
function K2(t4, e3) {
  if (t4[t4.length - 1] != "(") {
    let r = [], n3 = false, i2 = false, l2 = "";
    for (let o3 of t4)
      if (!(o3 == "(" || /[~@]$/.test(o3))) {
        if (o3[0] == "!" && (o3 = o3.slice(1), n3 = !n3), o3.endsWith(":")) {
          r[o3 == "dark:" ? "unshift" : "push"](o3.slice(0, -1));
          continue;
        }
        o3[0] == "-" && (o3 = o3.slice(1), i2 = !i2), o3.endsWith("-") && (o3 = o3.slice(0, -1)), o3 && o3 != "&" && (l2 += (l2 && "-") + o3);
      }
    l2 && (i2 && (l2 = "-" + l2), e3[0].push({ n: l2, v: r.filter(Jt), i: n3 }));
  }
}
function Jt(t4, e3, r) {
  return r.indexOf(t4) == e3;
}
var yt = /* @__PURE__ */ new Map();
function N3(t4) {
  let e3 = yt.get(t4);
  if (!e3) {
    let r = [], n3 = [[]], i2 = 0, l2 = 0, o3 = null, a4 = 0, s4 = (u3, f4 = 0) => {
      i2 != a4 && (r.push(t4.slice(i2, a4 + f4)), u3 && K2(r, n3)), i2 = a4 + 1;
    };
    for (; a4 < t4.length; a4++) {
      let u3 = t4[a4];
      if (l2)
        t4[a4 - 1] != "\\" && (l2 += +(u3 == "[") || -(u3 == "]"));
      else if (u3 == "[")
        l2 += 1;
      else if (o3)
        t4[a4 - 1] != "\\" && o3.test(t4.slice(a4)) && (o3 = null, i2 = a4 + RegExp.lastMatch.length);
      else if (u3 == "/" && t4[a4 - 1] != "\\" && (t4[a4 + 1] == "*" || t4[a4 + 1] == "/"))
        o3 = t4[a4 + 1] == "*" ? /^\*\// : /^[\r\n]/;
      else if (u3 == "(")
        s4(), r.push(u3);
      else if (u3 == ":")
        t4[a4 + 1] != ":" && s4(false, 1);
      else if (/[\s,)]/.test(u3)) {
        s4(true);
        let f4 = r.lastIndexOf("(");
        if (u3 == ")") {
          let c3 = r[f4 - 1];
          if (/[~@]$/.test(c3)) {
            let p6 = n3.shift();
            r.length = f4, K2([...r, "#"], n3);
            let { v: d3 } = n3[0].pop();
            for (let v2 of p6)
              v2.v.splice(+(v2.v[0] == "dark") - +(d3[0] == "dark"), d3.length);
            K2([...r, Ot(c3.length > 1 ? c3.slice(0, -1) + V3(JSON.stringify([c3, p6])) : c3 + "(" + st(p6) + ")", w3.a, p6, /@$/.test(c3))], n3);
          }
          f4 = r.lastIndexOf("(", f4 - 1);
        }
        r.length = f4 + 1;
      } else
        /[~@]/.test(u3) && t4[a4 + 1] == "(" && n3.unshift([]);
    }
    s4(true), yt.set(t4, e3 = n3[0]);
  }
  return e3;
}
function Ct(t4, e3, r) {
  return e3.reduce((n3, i2, l2) => n3 + r(i2) + t4[l2 + 1], t4[0]);
}
function G3(t4, e3) {
  return Array.isArray(t4) && Array.isArray(t4.raw) ? Ct(t4, e3, (r) => Q2(r).trim()) : e3.filter(Boolean).reduce((r, n3) => r + Q2(n3), t4 ? Q2(t4) : "");
}
function Q2(t4) {
  let e3, r = "";
  if (t4 && typeof t4 == "object")
    if (Array.isArray(t4))
      (e3 = G3(t4[0], t4.slice(1))) && (r += " " + e3);
    else
      for (let n3 in t4)
        t4[n3] && (r += " " + n3);
  else
    t4 != null && typeof t4 != "boolean" && (r += " " + t4);
  return r;
}
var ae2 = Et("@");
var ue = Et("~");
function Et(t4) {
  return new Proxy(function(r, ...n3) {
    return e3("", r, n3);
  }, { get: (r, n3) => n3 in r ? r[n3] : function(i2, ...l2) {
    return e3(n3, i2, l2);
  } });
  function e3(r, n3, i2) {
    return st(N3(r + t4 + "(" + G3(n3, i2) + ")"));
  }
}
function U2(t4, e3) {
  return Array.isArray(t4) ? mt(Ct(t4, e3, (r) => r != null && typeof r != "boolean" ? r : "")) : typeof t4 == "string" ? mt(t4) : [t4];
}
var Bt = / *(?:(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}))/g;
function mt(t4) {
  let e3;
  t4 = t4.replace(/\/\*[^]*?\*\/|\s\s+|\n/gm, " ");
  let r = [{}], n3 = [r[0]], i2 = [];
  for (; e3 = Bt.exec(t4); )
    e3[4] && (r.shift(), i2.shift()), e3[3] ? (i2.unshift(e3[3]), r.unshift({}), n3.push(i2.reduce((l2, o3) => ({ [o3]: l2 }), r[0]))) : e3[4] || (r[0][e3[1]] && (r.unshift({}), n3.push(i2.reduce((l2, o3) => ({ [o3]: l2 }), r[0]))), r[0][e3[1]] = e3[2]);
  return n3;
}
function dt(t4, ...e3) {
  var r, n3;
  let i2 = U2(t4, e3), l2 = (((r = i2.find((o3) => o3.label)) == null ? void 0 : r.label) || "css") + V3(JSON.stringify(i2));
  return n3 = (o3, a4) => pt(i2.flatMap((s4) => ct(s4, o3, a4, w3.o)), l2), ut.set(l2, n3), l2;
}
var ce2 = new Proxy(function(t4, e3) {
  return bt("animation", t4, e3);
}, { get: (t4, e3) => e3 in t4 ? t4[e3] : function(r, n3) {
  return bt(e3, r, n3);
} });
function bt(t4, e3, r) {
  return { toString: () => dt({ label: t4, "@layer components": { ...typeof e3 == "object" ? e3 : { animation: e3 }, animationName: "" + r } }) };
}
var Ut = Symbol();
var z2 = new Proxy(D4, { apply: (t4, e3, r) => F4(r[0]), get(t4, e3) {
  let r = F4[e3];
  return typeof r == "function" ? function() {
    return r.apply(F4, arguments);
  } : r;
} });
var xe = function t(e3) {
  return new Proxy(function(r, ...n3) {
    return xt(e3, "", r, n3);
  }, { get: (r, n3) => n3 === "bind" ? t : n3 in r ? r[n3] : function(i2, ...l2) {
    return xt(e3, n3, i2, l2);
  } });
}();
function xt(t4, e3, r, n3) {
  return { toString() {
    let i2 = U2(r, n3), l2 = W3(e3 + V3(JSON.stringify([e3, i2])));
    return (typeof t4 == "function" ? t4 : z2)(dt({ [`@keyframes ${l2}`]: U2(r, n3) })), l2;
  } };
}

// https://esm.sh/v106/@twind/core@1.1.3/deno/core.js
var B5;
function ae3(e3) {
  return [...e3.v, (e3.i ? "!" : "") + e3.n].join(":");
}
function ue2(e3, t4 = ",") {
  return e3.map(ae3).join(t4);
}
var Y3 = typeof CSS < "u" && CSS.escape || ((e3) => e3.replace(/[!"'`*+.,;:\\/<=>?@#$%&^|~()[\]{}]/g, "\\$&").replace(/^\d/, "\\3$& "));
function T3(e3) {
  for (var t4 = 9, r = e3.length; r--; )
    t4 = Math.imul(t4 ^ e3.charCodeAt(r), 1597334677);
  return "#" + ((t4 ^ t4 >>> 9) >>> 0).toString(36);
}
function Ce(e3, t4 = "@media ") {
  return t4 + b2(e3).map((r) => (typeof r == "string" && (r = { min: r }), r.raw || Object.keys(r).map((i2) => `(${i2}-width:${r[i2]})`).join(" and "))).join(",");
}
function b2(e3 = []) {
  return Array.isArray(e3) ? e3 : e3 == null ? [] : [e3];
}
function F5() {
}
var S3 = { d: 0, b: 134217728, c: 268435456, a: 671088640, u: 805306368, o: 939524096 };
function Ee(e3) {
  return e3.match(/[-=:;]/g)?.length || 0;
}
function re2(e3) {
  return Math.min(/(?:^|width[^\d]+)(\d+(?:.\d+)?)(p)?/.test(e3) ? Math.max(0, 29.63 * (+RegExp.$1 / (RegExp.$2 ? 15 : 1)) ** 0.137 - 43) : 0, 15) << 22 | Math.min(Ee(e3), 15) << 18;
}
var Ue = ["rst-c", "st-ch", "h-chi", "y-lin", "nk", "sited", "ecked", "pty", "ad-on", "cus-w", "ver", "cus", "cus-v", "tive", "sable", "tiona", "quire"];
function ce3({ n: e3, i: t4, v: r = [] }, i2, n3, l2) {
  e3 && (e3 = ae3({ n: e3, i: t4, v: r })), l2 = [...b2(l2)];
  for (let s4 of r) {
    let f4 = i2.theme("screens", s4);
    for (let a4 of b2(f4 && Ce(f4) || i2.v(s4))) {
      var o3;
      l2.push(a4), n3 |= f4 ? 67108864 | re2(a4) : s4 == "dark" ? 1073741824 : a4[0] == "@" ? re2(a4) : (o3 = a4, 1 << ~(/:([a-z-]+)/.test(o3) && ~Ue.indexOf(RegExp.$1.slice(2, 7)) || -18));
    }
  }
  return { n: e3, p: n3, r: l2, i: t4 };
}
var pe = /* @__PURE__ */ new Map();
function ne2(e3) {
  if (e3.d) {
    let t4 = [], r = H4(e3.r.reduce((i2, n3) => n3[0] == "@" ? (t4.push(n3), i2) : n3 ? H4(i2, (l2) => H4(n3, (o3) => {
      let s4 = /(:merge\(.+?\))(:[a-z-]+|\\[.+])/.exec(o3);
      if (s4) {
        let f4 = l2.indexOf(s4[1]);
        return ~f4 ? l2.slice(0, f4) + s4[0] + l2.slice(f4 + s4[1].length) : Q3(l2, o3);
      }
      return Q3(o3, l2);
    })) : i2, "&"), (i2) => Q3(i2, e3.n ? "." + Y3(e3.n) : ""));
    return r && t4.push(r.replace(/:merge\((.+?)\)/g, "$1")), t4.reduceRight((i2, n3) => n3 + "{" + i2 + "}", e3.d);
  }
}
function H4(e3, t4) {
  return e3.replace(/ *((?:\(.+?\)|\[.+?\]|[^,])+) *(,|$)/g, (r, i2, n3) => t4(i2) + n3);
}
function Q3(e3, t4) {
  return e3.replace(/&/g, t4);
}
var $e = new Intl.Collator("en", { numeric: true });
function Me(e3, t4) {
  for (var r = 0, i2 = e3.length; r < i2; ) {
    let n3 = i2 + r >> 1;
    0 >= Ne(e3[n3], t4) ? r = n3 + 1 : i2 = n3;
  }
  return i2;
}
function Ne(e3, t4) {
  let r = e3.p & S3.o;
  return r == (t4.p & S3.o) && (r == S3.b || r == S3.o) ? 0 : e3.p - t4.p || e3.o - t4.o || $e.compare(we(e3.n), we(t4.n)) || $e.compare(Ae(e3.n), Ae(t4.n));
}
function we(e3) {
  return (e3 || "").split(/:/).pop().split("/").pop() || "\0";
}
function Ae(e3) {
  return (e3 || "").replace(/\W/g, (t4) => String.fromCharCode(127 + t4.charCodeAt(0))) + "\0";
}
function X3(e3, t4) {
  return Math.round(parseInt(e3, 16) * t4);
}
function P4(e3, t4 = {}) {
  if (typeof e3 == "function")
    return e3(t4);
  let { opacityValue: r = "1", opacityVariable: i2 } = t4, n3 = i2 ? `var(${i2})` : r;
  if (e3.includes("<alpha-value>"))
    return e3.replace("<alpha-value>", n3);
  if (e3[0] == "#" && (e3.length == 4 || e3.length == 7)) {
    let l2 = (e3.length - 1) / 3, o3 = [17, 1, 0.062272][l2 - 1];
    return `rgba(${[X3(e3.substr(1, l2), o3), X3(e3.substr(1 + l2, l2), o3), X3(e3.substr(1 + 2 * l2, l2), o3), n3]})`;
  }
  return n3 == "1" ? e3 : n3 == "0" ? "#0000" : e3.replace(/^(rgb|hsl)(\([^)]+)\)$/, `$1a$2,${n3})`);
}
function de(e3, t4, r, i2, n3 = []) {
  return function l2(o3, { n: s4, p: f4, r: a4 = [], i: c3 }, u3) {
    let p6 = [], g5 = "", y3 = 0, $4 = 0;
    for (let h3 in o3 || {}) {
      var A5, R6;
      let d3 = o3[h3];
      if (h3[0] == "@") {
        if (!d3)
          continue;
        if (h3[1] == "a") {
          p6.push(...ge(s4, f4, I2("" + d3), u3, f4, a4, c3, true));
          continue;
        }
        if (h3[1] == "l") {
          for (let w4 of b2(d3))
            p6.push(...l2(w4, { n: s4, p: (A5 = S3[h3[7]], f4 & ~S3.o | A5), r: h3[7] == "d" ? [] : a4, i: c3 }, u3));
          continue;
        }
        if (h3[1] == "i") {
          p6.push(...b2(d3).map((w4) => ({ p: -1, o: 0, r: [], d: h3 + " " + w4 })));
          continue;
        }
        if (h3[1] == "k") {
          p6.push({ p: S3.d, o: 0, r: [h3], d: l2(d3, { p: S3.d }, u3).map(ne2).join("") });
          continue;
        }
        if (h3[1] == "f") {
          p6.push(...b2(d3).map((w4) => ({ p: S3.d, o: 0, r: [h3], d: l2(w4, { p: S3.d }, u3).map(ne2).join("") })));
          continue;
        }
      }
      if (typeof d3 != "object" || Array.isArray(d3))
        h3 == "label" && d3 ? s4 = d3 + T3(JSON.stringify([f4, c3, o3])) : (d3 || d3 === 0) && (h3 = h3.replace(/[A-Z]/g, (w4) => "-" + w4.toLowerCase()), $4 += 1, y3 = Math.max(y3, (R6 = h3)[0] == "-" ? 0 : Ee(R6) + (/^(?:(border-(?!w|c|sty)|[tlbr].{2,4}m?$|c.{7,8}$)|([fl].{5}l|g.{8}$|pl))/.test(R6) ? +!!RegExp.$1 || -!!RegExp.$2 : 0) + 1), g5 += (g5 ? ";" : "") + b2(d3).map((w4) => u3.s(h3, he("" + w4, u3.theme) + (c3 ? " !important" : ""))).join(";"));
      else if (h3[0] == "@" || h3.includes("&")) {
        let w4 = f4;
        h3[0] == "@" && (h3 = h3.replace(/\bscreen\(([^)]+)\)/g, (j5, M5) => {
          let N7 = u3.theme("screens", M5);
          return N7 ? (w4 |= 67108864, Ce(N7, "")) : j5;
        }), w4 |= re2(h3)), p6.push(...l2(d3, { n: s4, p: w4, r: [...a4, h3], i: c3 }, u3));
      } else
        p6.push(...l2(d3, { p: f4, r: [...a4, h3] }, u3));
    }
    return p6.unshift({ n: s4, p: f4, o: Math.max(0, 15 - $4) + 1.5 * Math.min(y3 || 15, 15), r: a4, d: g5 }), p6.sort(Ne);
  }(e3, ce3(t4, r, i2, n3), r);
}
function he(e3, t4) {
  return e3.replace(/theme\((["'`])?(.+?)\1(?:\s*,\s*(["'`])?(.+?)\3)?\)/g, (r, i2, n3, l2, o3 = "") => {
    let s4 = t4(n3, o3);
    return typeof s4 == "function" && /color|fill|stroke/i.test(n3) ? P4(s4) : "" + b2(s4).filter((f4) => Object(f4) !== f4);
  });
}
function ye(e3, t4) {
  let r, i2 = [];
  for (let n3 of e3)
    n3.d && n3.n ? r?.p == n3.p && "" + r.r == "" + n3.r ? (r.c = [r.c, n3.c].filter(Boolean).join(" "), r.d = r.d + ";" + n3.d) : i2.push(r = { ...n3, n: n3.n && t4 }) : i2.push({ ...n3, n: n3.n && t4 });
  return i2;
}
function W4(e3, t4, r = S3.u, i2, n3) {
  let l2 = [];
  for (let o3 of e3)
    for (let s4 of function(f4, a4, c3, u3, p6) {
      f4 = { ...f4, i: f4.i || p6 };
      let g5 = function(y3, $4) {
        let A5 = pe.get(y3.n);
        return A5 ? A5(y3, $4) : $4.r(y3.n, y3.v[0] == "dark");
      }(f4, a4);
      return g5 ? typeof g5 == "string" ? ({ r: u3, p: c3 } = ce3(f4, a4, c3, u3), ye(W4(I2(g5), a4, c3, u3, f4.i), f4.n)) : Array.isArray(g5) ? g5.map((y3) => {
        var $4, A5;
        return { o: 0, ...y3, r: [...b2(u3), ...b2(y3.r)], p: ($4 = c3, A5 = y3.p ?? c3, $4 & ~S3.o | A5) };
      }) : de(g5, f4, a4, c3, u3) : [{ c: ae3(f4), p: 0, o: 0, r: [] }];
    }(o3, t4, r, i2, n3))
      l2.splice(Me(l2, s4), 0, s4);
  return l2;
}
function ge(e3, t4, r, i2, n3, l2, o3, s4) {
  return ye((s4 ? r.flatMap((f4) => W4([f4], i2, n3, l2, o3)) : W4(r, i2, n3, l2, o3)).map((f4) => f4.p & S3.o && (f4.n || t4 == S3.b) ? { ...f4, p: f4.p & ~S3.o | t4, o: 0 } : f4), e3);
}
function _e2(e3, t4, r, i2) {
  var n3;
  return n3 = (l2, o3) => {
    let { n: s4, p: f4, r: a4, i: c3 } = ce3(l2, o3, t4);
    return r && ge(s4, t4, r, o3, f4, a4, c3, i2);
  }, pe.set(e3, n3), e3;
}
function K3(e3, t4, r) {
  if (e3[e3.length - 1] != "(") {
    let i2 = [], n3 = false, l2 = false, o3 = "";
    for (let s4 of e3)
      if (!(s4 == "(" || /[~@]$/.test(s4))) {
        if (s4[0] == "!" && (s4 = s4.slice(1), n3 = !n3), s4.endsWith(":")) {
          i2[s4 == "dark:" ? "unshift" : "push"](s4.slice(0, -1));
          continue;
        }
        s4[0] == "-" && (s4 = s4.slice(1), l2 = !l2), s4.endsWith("-") && (s4 = s4.slice(0, -1)), s4 && s4 != "&" && (o3 += (o3 && "-") + s4);
      }
    o3 && (l2 && (o3 = "-" + o3), t4[0].push({ n: o3, v: i2.filter(Be), i: n3 }));
  }
}
function Be(e3, t4, r) {
  return r.indexOf(e3) == t4;
}
var Se = /* @__PURE__ */ new Map();
function I2(e3) {
  let t4 = Se.get(e3);
  if (!t4) {
    let r = [], i2 = [[]], n3 = 0, l2 = 0, o3 = null, s4 = 0, f4 = (a4, c3 = 0) => {
      n3 != s4 && (r.push(e3.slice(n3, s4 + c3)), a4 && K3(r, i2)), n3 = s4 + 1;
    };
    for (; s4 < e3.length; s4++) {
      let a4 = e3[s4];
      if (l2)
        e3[s4 - 1] != "\\" && (l2 += +(a4 == "[") || -(a4 == "]"));
      else if (a4 == "[")
        l2 += 1;
      else if (o3)
        e3[s4 - 1] != "\\" && o3.test(e3.slice(s4)) && (o3 = null, n3 = s4 + RegExp.lastMatch.length);
      else if (a4 == "/" && e3[s4 - 1] != "\\" && (e3[s4 + 1] == "*" || e3[s4 + 1] == "/"))
        o3 = e3[s4 + 1] == "*" ? /^\*\// : /^[\r\n]/;
      else if (a4 == "(")
        f4(), r.push(a4);
      else if (a4 == ":")
        e3[s4 + 1] != ":" && f4(false, 1);
      else if (/[\s,)]/.test(a4)) {
        f4(true);
        let c3 = r.lastIndexOf("(");
        if (a4 == ")") {
          let u3 = r[c3 - 1];
          if (/[~@]$/.test(u3)) {
            let p6 = i2.shift();
            r.length = c3, K3([...r, "#"], i2);
            let { v: g5 } = i2[0].pop();
            for (let y3 of p6)
              y3.v.splice(+(y3.v[0] == "dark") - +(g5[0] == "dark"), g5.length);
            K3([...r, _e2(u3.length > 1 ? u3.slice(0, -1) + T3(JSON.stringify([u3, p6])) : u3 + "(" + ue2(p6) + ")", S3.a, p6, /@$/.test(u3))], i2);
          }
          c3 = r.lastIndexOf("(", c3 - 1);
        }
        r.length = c3 + 1;
      } else
        /[~@]/.test(a4) && e3[s4 + 1] == "(" && i2.unshift([]);
    }
    f4(true), Se.set(e3, t4 = i2[0]);
  }
  return t4;
}
function Ve(e3, t4, r) {
  return t4.reduce((i2, n3, l2) => i2 + r(n3) + e3[l2 + 1], e3[0]);
}
function Z3(e3, t4) {
  return Array.isArray(e3) && Array.isArray(e3.raw) ? Ve(e3, t4, (r) => ee2(r).trim()) : t4.filter(Boolean).reduce((r, i2) => r + ee2(i2), e3 ? ee2(e3) : "");
}
function ee2(e3) {
  let t4, r = "";
  if (e3 && typeof e3 == "object")
    if (Array.isArray(e3))
      (t4 = Z3(e3[0], e3.slice(1))) && (r += " " + t4);
    else
      for (let i2 in e3)
        e3[i2] && (r += " " + i2);
  else
    e3 != null && typeof e3 != "boolean" && (r += " " + e3);
  return r;
}
var pt2 = ze("@");
var dt2 = ze("~");
function ze(e3) {
  return new Proxy(function(i2, ...n3) {
    return t4("", i2, n3);
  }, { get(r, i2) {
    return i2 in r ? r[i2] : function(l2, ...o3) {
      return t4(i2, l2, o3);
    };
  } });
  function t4(r, i2, n3) {
    return ue2(I2(r + e3 + "(" + Z3(i2, n3) + ")"));
  }
}
function G4(e3, t4) {
  return Array.isArray(e3) ? ve(Ve(e3, t4, (r) => r != null && typeof r != "boolean" ? r : "")) : typeof e3 == "string" ? ve(e3) : [e3];
}
var We = / *(?:(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}))/g;
function ve(e3) {
  let t4;
  e3 = e3.replace(/\/\*[^]*?\*\/|\s\s+|\n/gm, " ");
  let r = [{}], i2 = [r[0]], n3 = [];
  for (; t4 = We.exec(e3); )
    t4[4] && (r.shift(), n3.shift()), t4[3] ? (n3.unshift(t4[3]), r.unshift({}), i2.push(n3.reduce((l2, o3) => ({ [o3]: l2 }), r[0]))) : t4[4] || (r[0][t4[1]] && (r.unshift({}), i2.push(n3.reduce((l2, o3) => ({ [o3]: l2 }), r[0]))), r[0][t4[1]] = t4[2]);
  return i2;
}
function me(e3, ...t4) {
  var r;
  let i2 = G4(e3, t4), n3 = (i2.find((l2) => l2.label)?.label || "css") + T3(JSON.stringify(i2));
  return r = (l2, o3) => ye(i2.flatMap((s4) => de(s4, l2, o3, S3.o)), n3), pe.set(n3, r), n3;
}
var ht2 = new Proxy(function(e3, t4) {
  return Re("animation", e3, t4);
}, { get(e3, t4) {
  return t4 in e3 ? e3[t4] : function(i2, n3) {
    return Re(t4, i2, n3);
  };
} });
function Re(e3, t4, r) {
  return { toString() {
    return me({ label: e3, "@layer components": { ...typeof t4 == "object" ? t4 : { animation: t4 }, animationName: "" + r } });
  } };
}
function yt2(e3, t4, r) {
  return [e3, ie(t4, r)];
}
function ie(e3, t4) {
  return typeof e3 == "function" ? e3 : typeof e3 == "string" && /^[\w-]+$/.test(e3) ? (r, i2) => ({ [e3]: t4 ? t4(r, i2) : le2(r, 1) }) : (r) => e3 || { [r[1]]: le2(r, 2) };
}
function le2(e3, t4, r = e3.slice(t4).find(Boolean) || e3.$$ || e3.input) {
  return e3.input[0] == "-" ? `calc(${r} * -1)` : r;
}
function gt(e3, t4, r, i2) {
  return [e3, Ge(t4, r, i2)];
}
function Ge(e3, t4, r) {
  let i2 = typeof t4 == "string" ? (n3, l2) => ({ [t4]: r ? r(n3, l2) : n3._ }) : t4 || (({ 1: n3, _: l2 }, o3, s4) => ({ [n3 || s4]: l2 }));
  return (n3, l2) => {
    let o3 = ke(e3 || n3[1]), s4 = l2.theme(o3, n3.$$) ?? oe3(n3.$$, o3, l2);
    if (s4 != null)
      return n3._ = le2(n3, 0, s4), i2(n3, l2, o3);
  };
}
function mt2(e3, t4 = {}, r) {
  return [e3, Ye(t4, r)];
}
function Ye(e3 = {}, t4) {
  return (r, i2) => {
    let { section: n3 = ke(r[0]).replace("-", "") + "Color" } = e3, [l2, o3] = Ze(r.$$);
    if (!l2)
      return;
    let s4 = i2.theme(n3, l2) || oe3(l2, n3, i2);
    if (!s4 || typeof s4 == "object")
      return;
    let { opacityVariable: f4 = `--tw-${r[0].replace(/-$/, "")}-opacity`, opacitySection: a4 = n3.replace("Color", "Opacity"), property: c3 = n3, selector: u3 } = e3, p6 = i2.theme(a4, o3 || "DEFAULT") || o3 && oe3(o3, a4, i2), g5 = t4 || (({ _: $4 }) => {
      let A5 = He(c3, $4);
      return u3 ? { [u3]: A5 } : A5;
    });
    r._ = { value: P4(s4, { opacityVariable: f4 || void 0, opacityValue: p6 || void 0 }), color: ($4) => P4(s4, $4), opacityVariable: f4 || void 0, opacityValue: p6 || void 0 };
    let y3 = g5(r, i2);
    if (!r.dark) {
      let $4 = i2.d(n3, l2, s4);
      $4 && $4 !== s4 && (r._ = { value: P4($4, { opacityVariable: f4 || void 0, opacityValue: p6 || "1" }), color: (A5) => P4($4, A5), opacityVariable: f4 || void 0, opacityValue: p6 || void 0 }, y3 = { "&": y3, [i2.v("dark")]: g5(r, i2) });
    }
    return y3;
  };
}
function Ze(e3) {
  return (e3.match(/^(\[[^\]]+]|[^/]+?)(?:\/(.+))?$/) || []).slice(1);
}
function He(e3, t4) {
  let r = {};
  return typeof t4 == "string" ? r[e3] = t4 : (t4.opacityVariable && t4.value.includes(t4.opacityVariable) && (r[t4.opacityVariable] = t4.opacityValue || "1"), r[e3] = t4.value), r;
}
function oe3(e3, t4, r) {
  if (e3[0] == "[" && e3.slice(-1) == "]") {
    if (e3 = se(he(e3.slice(1, -1), r.theme)), !t4)
      return e3;
    if (!(/color|fill|stroke/i.test(t4) && !(/^color:/.test(e3) || /^(#|((hsl|rgb)a?|hwb|lab|lch|color)\(|[a-z]+$)/.test(e3)) || /image/i.test(t4) && !(/^image:/.test(e3) || /^[a-z-]+\(/.test(e3)) || /weight/i.test(t4) && !(/^(number|any):/.test(e3) || /^\d+$/.test(e3)) || /position/i.test(t4) && /^(length|size):/.test(e3)))
      return e3.replace(/^[a-z-]+:/, "");
  }
}
function ke(e3) {
  return e3.replace(/-./g, (t4) => t4[1].toUpperCase());
}
function se(e3) {
  return e3.includes("url(") ? e3.replace(/(.*?)(url\(.*?\))(.*?)/g, (t4, r = "", i2, n3 = "") => se(r) + i2 + se(n3)) : e3.replace(/(^|[^\\])_+/g, (t4, r) => r + " ".repeat(t4.length - r.length)).replace(/\\_/g, "_").replace(/(calc|min|max|clamp)\(.+\)/g, (t4) => t4.replace(/(-?\d*\.?\d(?!\b-.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 "));
}
var Qe = Symbol();
var D5 = new Proxy(F5, { apply(e3, t4, r) {
  return B5(r[0]);
}, get(e3, t4) {
  let r = B5[t4];
  return typeof r == "function" ? function() {
    return r.apply(B5, arguments);
  } : r;
} });
var Rt = function e2(t4) {
  return new Proxy(function(i2, ...n3) {
    return xe2(t4, "", i2, n3);
  }, { get(r, i2) {
    return i2 === "bind" ? e2 : i2 in r ? r[i2] : function(l2, ...o3) {
      return xe2(t4, i2, l2, o3);
    };
  } });
}();
function xe2(e3, t4, r, i2) {
  return { toString() {
    let n3 = G4(r, i2), l2 = Y3(t4 + T3(JSON.stringify([t4, n3])));
    return (typeof e3 == "function" ? e3 : D5)(me({ [`@keyframes ${l2}`]: G4(r, i2) })), l2;
  } };
}

// https://esm.sh/v106/@twind/preset-tailwind@1.0.1/deno/preset-tailwind.js
var L4 = "inherit";
var U3 = "currentColor";
var j3 = "transparent";
var V4 = "#000";
var B6 = "#fff";
var H5 = { 50: "#f8fafc", 100: "#f1f5f9", 200: "#e2e8f0", 300: "#cbd5e1", 400: "#94a3b8", 500: "#64748b", 600: "#475569", 700: "#334155", 800: "#1e293b", 900: "#0f172a" };
var I3 = { 50: "#f9fafb", 100: "#f3f4f6", 200: "#e5e7eb", 300: "#d1d5db", 400: "#9ca3af", 500: "#6b7280", 600: "#4b5563", 700: "#374151", 800: "#1f2937", 900: "#111827" };
var M3 = { 50: "#fafafa", 100: "#f4f4f5", 200: "#e4e4e7", 300: "#d4d4d8", 400: "#a1a1aa", 500: "#71717a", 600: "#52525b", 700: "#3f3f46", 800: "#27272a", 900: "#18181b" };
var P5 = { 50: "#fafafa", 100: "#f5f5f5", 200: "#e5e5e5", 300: "#d4d4d4", 400: "#a3a3a3", 500: "#737373", 600: "#525252", 700: "#404040", 800: "#262626", 900: "#171717" };
var N4 = { 50: "#fafaf9", 100: "#f5f5f4", 200: "#e7e5e4", 300: "#d6d3d1", 400: "#a8a29e", 500: "#78716c", 600: "#57534e", 700: "#44403c", 800: "#292524", 900: "#1c1917" };
var G5 = { 50: "#fef2f2", 100: "#fee2e2", 200: "#fecaca", 300: "#fca5a5", 400: "#f87171", 500: "#ef4444", 600: "#dc2626", 700: "#b91c1c", 800: "#991b1b", 900: "#7f1d1d" };
var q3 = { 50: "#fff7ed", 100: "#ffedd5", 200: "#fed7aa", 300: "#fdba74", 400: "#fb923c", 500: "#f97316", 600: "#ea580c", 700: "#c2410c", 800: "#9a3412", 900: "#7c2d12" };
var Y4 = { 50: "#fffbeb", 100: "#fef3c7", 200: "#fde68a", 300: "#fcd34d", 400: "#fbbf24", 500: "#f59e0b", 600: "#d97706", 700: "#b45309", 800: "#92400e", 900: "#78350f" };
var X4 = { 50: "#fefce8", 100: "#fef9c3", 200: "#fef08a", 300: "#fde047", 400: "#facc15", 500: "#eab308", 600: "#ca8a04", 700: "#a16207", 800: "#854d0e", 900: "#713f12" };
var J2 = { 50: "#f7fee7", 100: "#ecfccb", 200: "#d9f99d", 300: "#bef264", 400: "#a3e635", 500: "#84cc16", 600: "#65a30d", 700: "#4d7c0f", 800: "#3f6212", 900: "#365314" };
var K4 = { 50: "#f0fdf4", 100: "#dcfce7", 200: "#bbf7d0", 300: "#86efac", 400: "#4ade80", 500: "#22c55e", 600: "#16a34a", 700: "#15803d", 800: "#166534", 900: "#14532d" };
var Q4 = { 50: "#ecfdf5", 100: "#d1fae5", 200: "#a7f3d0", 300: "#6ee7b7", 400: "#34d399", 500: "#10b981", 600: "#059669", 700: "#047857", 800: "#065f46", 900: "#064e3b" };
var Z4 = { 50: "#f0fdfa", 100: "#ccfbf1", 200: "#99f6e4", 300: "#5eead4", 400: "#2dd4bf", 500: "#14b8a6", 600: "#0d9488", 700: "#0f766e", 800: "#115e59", 900: "#134e4a" };
var ee3 = { 50: "#ecfeff", 100: "#cffafe", 200: "#a5f3fc", 300: "#67e8f9", 400: "#22d3ee", 500: "#06b6d4", 600: "#0891b2", 700: "#0e7490", 800: "#155e75", 900: "#164e63" };
var te = { 50: "#f0f9ff", 100: "#e0f2fe", 200: "#bae6fd", 300: "#7dd3fc", 400: "#38bdf8", 500: "#0ea5e9", 600: "#0284c7", 700: "#0369a1", 800: "#075985", 900: "#0c4a6e" };
var oe4 = { 50: "#eff6ff", 100: "#dbeafe", 200: "#bfdbfe", 300: "#93c5fd", 400: "#60a5fa", 500: "#3b82f6", 600: "#2563eb", 700: "#1d4ed8", 800: "#1e40af", 900: "#1e3a8a" };
var re3 = { 50: "#eef2ff", 100: "#e0e7ff", 200: "#c7d2fe", 300: "#a5b4fc", 400: "#818cf8", 500: "#6366f1", 600: "#4f46e5", 700: "#4338ca", 800: "#3730a3", 900: "#312e81" };
var ae4 = { 50: "#f5f3ff", 100: "#ede9fe", 200: "#ddd6fe", 300: "#c4b5fd", 400: "#a78bfa", 500: "#8b5cf6", 600: "#7c3aed", 700: "#6d28d9", 800: "#5b21b6", 900: "#4c1d95" };
var ie2 = { 50: "#faf5ff", 100: "#f3e8ff", 200: "#e9d5ff", 300: "#d8b4fe", 400: "#c084fc", 500: "#a855f7", 600: "#9333ea", 700: "#7e22ce", 800: "#6b21a8", 900: "#581c87" };
var ne3 = { 50: "#fdf4ff", 100: "#fae8ff", 200: "#f5d0fe", 300: "#f0abfc", 400: "#e879f9", 500: "#d946ef", 600: "#c026d3", 700: "#a21caf", 800: "#86198f", 900: "#701a75" };
var le3 = { 50: "#fdf2f8", 100: "#fce7f3", 200: "#fbcfe8", 300: "#f9a8d4", 400: "#f472b6", 500: "#ec4899", 600: "#db2777", 700: "#be185d", 800: "#9d174d", 900: "#831843" };
var se2 = { 50: "#fff1f2", 100: "#ffe4e6", 200: "#fecdd3", 300: "#fda4af", 400: "#fb7185", 500: "#f43f5e", 600: "#e11d48", 700: "#be123c", 800: "#9f1239", 900: "#881337" };
var S4 = { __proto__: null, inherit: L4, current: U3, transparent: j3, black: V4, white: B6, slate: H5, gray: I3, zinc: M3, neutral: P5, stone: N4, red: G5, orange: q3, amber: Y4, yellow: X4, lime: J2, green: K4, emerald: Q4, teal: Z4, cyan: ee3, sky: te, blue: oe4, indigo: re3, violet: ae4, purple: ie2, fuchsia: ne3, pink: le3, rose: se2 };
var h2 = { screens: { sm: "640px", md: "768px", lg: "1024px", xl: "1280px", "2xl": "1536px" }, colors: S4, columns: { auto: "auto", "3xs": "16rem", "2xs": "18rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem" }, spacing: { px: "1px", 0: "0px", ...c(4, "rem", 4, 0.5, 0.5), ...c(12, "rem", 4, 5), 14: "3.5rem", ...c(64, "rem", 4, 16, 4), 72: "18rem", 80: "20rem", 96: "24rem" }, durations: { 75: "75ms", 100: "100ms", 150: "150ms", 200: "200ms", 300: "300ms", 500: "500ms", 700: "700ms", 1e3: "1000ms" }, animation: { none: "none", spin: "spin 1s linear infinite", ping: "ping 1s cubic-bezier(0,0,0.2,1) infinite", pulse: "pulse 2s cubic-bezier(0.4,0,0.6,1) infinite", bounce: "bounce 1s infinite" }, aspectRatio: { auto: "auto", square: "1/1", video: "16/9" }, backdropBlur: n2("blur"), backdropBrightness: n2("brightness"), backdropContrast: n2("contrast"), backdropGrayscale: n2("grayscale"), backdropHueRotate: n2("hueRotate"), backdropInvert: n2("invert"), backdropOpacity: n2("opacity"), backdropSaturate: n2("saturate"), backdropSepia: n2("sepia"), backgroundColor: n2("colors"), backgroundImage: { none: "none" }, backgroundOpacity: n2("opacity"), backgroundSize: { auto: "auto", cover: "cover", contain: "contain" }, blur: { none: "none", 0: "0", sm: "4px", DEFAULT: "8px", md: "12px", lg: "16px", xl: "24px", "2xl": "40px", "3xl": "64px" }, brightness: { ...c(200, "", 100, 0, 50), ...c(110, "", 100, 90, 5), 75: "0.75", 125: "1.25" }, borderColor: ({ theme: e3 }) => ({ DEFAULT: e3("colors.gray.200", "currentColor"), ...e3("colors") }), borderOpacity: n2("opacity"), borderRadius: { none: "0px", sm: "0.125rem", DEFAULT: "0.25rem", md: "0.375rem", lg: "0.5rem", xl: "0.75rem", "2xl": "1rem", "3xl": "1.5rem", "1/2": "50%", full: "9999px" }, borderSpacing: n2("spacing"), borderWidth: { DEFAULT: "1px", ...f2(8, "px") }, boxShadow: { sm: "0 1px 2px 0 rgba(0,0,0,0.05)", DEFAULT: "0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px -1px rgba(0,0,0,0.1)", md: "0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.1)", lg: "0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -4px rgba(0,0,0,0.1)", xl: "0 20px 25px -5px rgba(0,0,0,0.1), 0 8px 10px -6px rgba(0,0,0,0.1)", "2xl": "0 25px 50px -12px rgba(0,0,0,0.25)", inner: "inset 0 2px 4px 0 rgba(0,0,0,0.05)", none: "0 0 #0000" }, boxShadowColor: n2("colors"), caretColor: n2("colors"), accentColor: ({ theme: e3 }) => ({ auto: "auto", ...e3("colors") }), contrast: { ...c(200, "", 100, 0, 50), 75: "0.75", 125: "1.25" }, content: { none: "none" }, divideColor: n2("borderColor"), divideOpacity: n2("borderOpacity"), divideWidth: n2("borderWidth"), dropShadow: { sm: "0 1px 1px rgba(0,0,0,0.05)", DEFAULT: ["0 1px 2px rgba(0,0,0,0.1)", "0 1px 1px rgba(0,0,0,0.06)"], md: ["0 4px 3px rgba(0,0,0,0.07)", "0 2px 2px rgba(0,0,0,0.06)"], lg: ["0 10px 8px rgba(0,0,0,0.04)", "0 4px 3px rgba(0,0,0,0.1)"], xl: ["0 20px 13px rgba(0,0,0,0.03)", "0 8px 5px rgba(0,0,0,0.08)"], "2xl": "0 25px 25px rgba(0,0,0,0.15)", none: "0 0 #0000" }, fill: n2("colors"), grayscale: { DEFAULT: "100%", 0: "0" }, hueRotate: { 0: "0deg", 15: "15deg", 30: "30deg", 60: "60deg", 90: "90deg", 180: "180deg" }, invert: { DEFAULT: "100%", 0: "0" }, flex: { 1: "1 1 0%", auto: "1 1 auto", initial: "0 1 auto", none: "none" }, flexBasis: ({ theme: e3 }) => ({ ...e3("spacing"), ...x3(2, 6), ...x3(12, 12), auto: "auto", full: "100%" }), flexGrow: { DEFAULT: 1, 0: 0 }, flexShrink: { DEFAULT: 1, 0: 0 }, fontFamily: { sans: 'ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji"'.split(","), serif: 'ui-serif,Georgia,Cambria,"Times New Roman",Times,serif'.split(","), mono: 'ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace'.split(",") }, fontSize: { xs: ["0.75rem", "1rem"], sm: ["0.875rem", "1.25rem"], base: ["1rem", "1.5rem"], lg: ["1.125rem", "1.75rem"], xl: ["1.25rem", "1.75rem"], "2xl": ["1.5rem", "2rem"], "3xl": ["1.875rem", "2.25rem"], "4xl": ["2.25rem", "2.5rem"], "5xl": ["3rem", "1"], "6xl": ["3.75rem", "1"], "7xl": ["4.5rem", "1"], "8xl": ["6rem", "1"], "9xl": ["8rem", "1"] }, fontWeight: { thin: "100", extralight: "200", light: "300", normal: "400", medium: "500", semibold: "600", bold: "700", extrabold: "800", black: "900" }, gap: n2("spacing"), gradientColorStops: n2("colors"), gridAutoColumns: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0,1fr)" }, gridAutoRows: { auto: "auto", min: "min-content", max: "max-content", fr: "minmax(0,1fr)" }, gridColumn: { auto: "auto", "span-full": "1 / -1" }, gridRow: { auto: "auto", "span-full": "1 / -1" }, gridTemplateColumns: { none: "none" }, gridTemplateRows: { none: "none" }, height: ({ theme: e3 }) => ({ ...e3("spacing"), ...x3(2, 6), min: "min-content", max: "max-content", fit: "fit-content", auto: "auto", full: "100%", screen: "100vh" }), inset: ({ theme: e3 }) => ({ ...e3("spacing"), ...x3(2, 4), auto: "auto", full: "100%" }), keyframes: { spin: { from: { transform: "rotate(0deg)" }, to: { transform: "rotate(360deg)" } }, ping: { "0%": { transform: "scale(1)", opacity: "1" }, "75%,100%": { transform: "scale(2)", opacity: "0" } }, pulse: { "0%,100%": { opacity: "1" }, "50%": { opacity: ".5" } }, bounce: { "0%, 100%": { transform: "translateY(-25%)", animationTimingFunction: "cubic-bezier(0.8,0,1,1)" }, "50%": { transform: "none", animationTimingFunction: "cubic-bezier(0,0,0.2,1)" } } }, letterSpacing: { tighter: "-0.05em", tight: "-0.025em", normal: "0em", wide: "0.025em", wider: "0.05em", widest: "0.1em" }, lineHeight: { ...c(10, "rem", 4, 3), none: "1", tight: "1.25", snug: "1.375", normal: "1.5", relaxed: "1.625", loose: "2" }, margin: ({ theme: e3 }) => ({ auto: "auto", ...e3("spacing") }), maxHeight: ({ theme: e3 }) => ({ full: "100%", min: "min-content", max: "max-content", fit: "fit-content", screen: "100vh", ...e3("spacing") }), maxWidth: ({ theme: e3, breakpoints: r }) => ({ ...r(e3("screens")), none: "none", 0: "0rem", xs: "20rem", sm: "24rem", md: "28rem", lg: "32rem", xl: "36rem", "2xl": "42rem", "3xl": "48rem", "4xl": "56rem", "5xl": "64rem", "6xl": "72rem", "7xl": "80rem", full: "100%", min: "min-content", max: "max-content", fit: "fit-content", prose: "65ch" }), minHeight: { 0: "0px", full: "100%", min: "min-content", max: "max-content", fit: "fit-content", screen: "100vh" }, minWidth: { 0: "0px", full: "100%", min: "min-content", max: "max-content", fit: "fit-content" }, opacity: { ...c(100, "", 100, 0, 10), 5: "0.05", 25: "0.25", 75: "0.75", 95: "0.95" }, order: { first: "-9999", last: "9999", none: "0" }, padding: n2("spacing"), placeholderColor: n2("colors"), placeholderOpacity: n2("opacity"), outlineColor: n2("colors"), outlineOffset: f2(8, "px"), outlineWidth: f2(8, "px"), ringColor: ({ theme: e3 }) => ({ ...e3("colors"), DEFAULT: e3("colors.blue.500", "#3b82f6") }), ringOffsetColor: n2("colors"), ringOffsetWidth: f2(8, "px"), ringOpacity: ({ theme: e3 }) => ({ ...e3("opacity"), DEFAULT: "0.5" }), ringWidth: { DEFAULT: "3px", ...f2(8, "px") }, rotate: { ...f2(2, "deg"), ...f2(12, "deg", 3), ...f2(180, "deg", 45) }, saturate: c(200, "", 100, 0, 50), scale: { ...c(150, "", 100, 0, 50), ...c(110, "", 100, 90, 5), 75: "0.75", 125: "1.25" }, scrollMargin: n2("spacing"), scrollPadding: n2("spacing"), sepia: { 0: "0", DEFAULT: "100%" }, skew: { ...f2(2, "deg"), ...f2(12, "deg", 3) }, space: n2("spacing"), stroke: n2("colors"), strokeWidth: c(2), textColor: n2("colors"), textDecorationColor: n2("colors"), textDecorationThickness: { "from-font": "from-font", auto: "auto", ...f2(8, "px") }, textUnderlineOffset: { auto: "auto", ...f2(8, "px") }, textIndent: n2("spacing"), textOpacity: n2("opacity"), transitionDuration: ({ theme: e3 }) => ({ ...e3("durations"), DEFAULT: "150ms" }), transitionDelay: n2("durations"), transitionProperty: { none: "none", all: "all", DEFAULT: "color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter", colors: "color,background-color,border-color,text-decoration-color,fill,stroke", opacity: "opacity", shadow: "box-shadow", transform: "transform" }, transitionTimingFunction: { DEFAULT: "cubic-bezier(0.4,0,0.2,1)", linear: "linear", in: "cubic-bezier(0.4,0,1,1)", out: "cubic-bezier(0,0,0.2,1)", "in-out": "cubic-bezier(0.4,0,0.2,1)" }, translate: ({ theme: e3 }) => ({ ...e3("spacing"), ...x3(2, 4), full: "100%" }), width: ({ theme: e3 }) => ({ min: "min-content", max: "max-content", fit: "fit-content", screen: "100vw", ...e3("flexBasis") }), willChange: { scroll: "scroll-position" }, zIndex: { ...c(50, "", 1, 0, 10), auto: "auto" } };
function x3(e3, r) {
  let a4 = {};
  do
    for (var i2 = 1; i2 < e3; i2++)
      a4[`${i2}/${e3}`] = Number((i2 / e3 * 100).toFixed(6)) + "%";
  while (++e3 <= r);
  return a4;
}
function f2(e3, r, a4 = 0) {
  let i2 = {};
  for (; a4 <= e3; a4 = 2 * a4 || 1)
    i2[a4] = a4 + r;
  return i2;
}
function c(e3, r = "", a4 = 1, i2 = 0, l2 = 1, d3 = {}) {
  for (; i2 <= e3; i2 += l2)
    d3[i2] = i2 / a4 + r;
  return d3;
}
function n2(e3) {
  return ({ theme: r }) => r(e3);
}
var C3 = { "*,::before,::after": { boxSizing: "border-box", borderWidth: "0", borderStyle: "solid", borderColor: "theme(borderColor.DEFAULT, currentColor)" }, "::before,::after": { "--tw-content": "''" }, html: { lineHeight: 1.5, WebkitTextSizeAdjust: "100%", MozTabSize: "4", tabSize: 4, fontFamily: `theme(fontFamily.sans, ${h2.fontFamily.sans})` }, body: { margin: "0", lineHeight: "inherit" }, hr: { height: "0", color: "inherit", borderTopWidth: "1px" }, "abbr:where([title])": { textDecoration: "underline dotted" }, "h1,h2,h3,h4,h5,h6": { fontSize: "inherit", fontWeight: "inherit" }, a: { color: "inherit", textDecoration: "inherit" }, "b,strong": { fontWeight: "bolder" }, "code,kbd,samp,pre": { fontFamily: `theme(fontFamily.mono, ${h2.fontFamily.mono})`, fontSize: "1em" }, small: { fontSize: "80%" }, "sub,sup": { fontSize: "75%", lineHeight: 0, position: "relative", verticalAlign: "baseline" }, sub: { bottom: "-0.25em" }, sup: { top: "-0.5em" }, table: { textIndent: "0", borderColor: "inherit", borderCollapse: "collapse" }, "button,input,optgroup,select,textarea": { fontFamily: "inherit", fontSize: "100%", lineHeight: "inherit", color: "inherit", margin: "0", padding: "0" }, "button,select": { textTransform: "none" }, "button,[type='button'],[type='reset'],[type='submit']": { WebkitAppearance: "button", backgroundColor: "transparent", backgroundImage: "none" }, ":-moz-focusring": { outline: "auto" }, ":-moz-ui-invalid": { boxShadow: "none" }, progress: { verticalAlign: "baseline" }, "::-webkit-inner-spin-button,::-webkit-outer-spin-button": { height: "auto" }, "[type='search']": { WebkitAppearance: "textfield", outlineOffset: "-2px" }, "::-webkit-search-decoration": { WebkitAppearance: "none" }, "::-webkit-file-upload-button": { WebkitAppearance: "button", font: "inherit" }, summary: { display: "list-item" }, "blockquote,dl,dd,h1,h2,h3,h4,h5,h6,hr,figure,p,pre": { margin: "0" }, fieldset: { margin: "0", padding: "0" }, legend: { padding: "0" }, "ol,ul,menu": { listStyle: "none", margin: "0", padding: "0" }, textarea: { resize: "vertical" }, "input::placeholder,textarea::placeholder": { opacity: 1, color: "theme(colors.gray.400, #9ca3af)" }, 'button,[role="button"]': { cursor: "pointer" }, ":disabled": { cursor: "default" }, "img,svg,video,canvas,audio,iframe,embed,object": { display: "block", verticalAlign: "middle" }, "img,video": { maxWidth: "100%", height: "auto" }, "[hidden]": { display: "none" } };
var O2 = [yt2("\\[([-\\w]+):(.+)]", ({ 1: e3, 2: r }, a4) => ({ "@layer overrides": { "&": { [e3]: oe3(`[${r}]`, e3, a4) } } })), yt2("(group|peer)(~[^-[]+)?", ({ input: e3 }, { h: r }) => [{ c: r(e3) }]), gt("aspect-", "aspectRatio"), yt2("container", (e3, { theme: r }) => {
  let { screens: a4 = r("screens"), center: i2, padding: l2 } = r("container"), d3 = { width: "100%", marginRight: i2 && "auto", marginLeft: i2 && "auto", ...m4("xs") };
  for (let w4 in a4) {
    let b4 = a4[w4];
    typeof b4 == "string" && (d3[Ce(b4)] = { "&": { maxWidth: b4, ...m4(w4) } });
  }
  return d3;
  function m4(w4) {
    let b4 = l2 && (typeof l2 == "string" ? l2 : l2[w4] || l2.DEFAULT);
    if (b4)
      return { paddingRight: b4, paddingLeft: b4 };
  }
}), gt("content-", "content", ({ _: e3 }) => ({ "--tw-content": e3, content: "var(--tw-content)" })), yt2("(?:box-)?decoration-(slice|clone)", "boxDecorationBreak"), yt2("box-(border|content)", "boxSizing", ({ 1: e3 }) => e3 + "-box"), yt2("hidden", { display: "none" }), yt2("table-(auto|fixed)", "tableLayout"), yt2(["(block|flex|table|grid|inline|contents|flow-root|list-item)", "(inline-(block|flex|table|grid))", "(table-(caption|cell|column|row|(column|row|footer|header)-group))"], "display"), "(float)-(left|right|none)", "(clear)-(left|right|none|both)", "(overflow(?:-[xy])?)-(auto|hidden|clip|visible|scroll)", "(isolation)-(auto)", yt2("isolate", "isolation"), yt2("object-(contain|cover|fill|none|scale-down)", "objectFit"), gt("object-", "objectPosition"), yt2("object-(top|bottom|center|(left|right)(-(top|bottom))?)", "objectPosition", y2), yt2("overscroll(-[xy])?-(auto|contain|none)", ({ 1: e3 = "", 2: r }) => ({ ["overscroll-behavior" + e3]: r })), yt2("(static|fixed|absolute|relative|sticky)", "position"), gt("-?inset(-[xy])?(?:$|-)", "inset", ({ 1: e3, _: r }) => ({ top: e3 != "-x" && r, right: e3 != "-y" && r, bottom: e3 != "-x" && r, left: e3 != "-y" && r })), gt("-?(top|bottom|left|right)(?:$|-)", "inset"), yt2("visible", "visibility"), yt2("invisible", { visibility: "hidden" }), gt("-?z-", "zIndex"), yt2("flex-((row|col)(-reverse)?)", "flexDirection", F6), yt2("flex-(wrap|wrap-reverse|nowrap)", "flexWrap"), gt("(flex-(?:grow|shrink))(?:$|-)"), gt("(flex)-"), gt("grow(?:$|-)", "flexGrow"), gt("shrink(?:$|-)", "flexShrink"), gt("basis-", "flexBasis"), gt("-?(order)-"), "-?(order)-(\\d+)", gt("grid-cols-", "gridTemplateColumns"), yt2("grid-cols-(\\d+)", "gridTemplateColumns", D6), gt("col-", "gridColumn"), yt2("col-(span)-(\\d+)", "gridColumn", W5), gt("col-start-", "gridColumnStart"), yt2("col-start-(auto|\\d+)", "gridColumnStart"), gt("col-end-", "gridColumnEnd"), yt2("col-end-(auto|\\d+)", "gridColumnEnd"), gt("grid-rows-", "gridTemplateRows"), yt2("grid-rows-(\\d+)", "gridTemplateRows", D6), gt("row-", "gridRow"), yt2("row-(span)-(\\d+)", "gridRow", W5), gt("row-start-", "gridRowStart"), yt2("row-start-(auto|\\d+)", "gridRowStart"), gt("row-end-", "gridRowEnd"), yt2("row-end-(auto|\\d+)", "gridRowEnd"), yt2("grid-flow-((row|col)(-dense)?)", "gridAutoFlow", (e3) => y2(F6(e3))), yt2("grid-flow-(dense)", "gridAutoFlow"), gt("auto-cols-", "gridAutoColumns"), gt("auto-rows-", "gridAutoRows"), gt("gap-x(?:$|-)", "gap", "columnGap"), gt("gap-y(?:$|-)", "gap", "rowGap"), gt("gap(?:$|-)", "gap"), "(justify-(?:items|self))-", yt2("justify-", "justifyContent", T4), yt2("(content|items|self)-", (e3) => ({ ["align-" + e3[1]]: T4(e3) })), yt2("(place-(content|items|self))-", ({ 1: e3, $$: r }) => ({ [e3]: ("wun".includes(r[3]) ? "space-" : "") + r })), gt("p([xytrbl])?(?:$|-)", "padding", u("padding")), gt("-?m([xytrbl])?(?:$|-)", "margin", u("margin")), gt("-?space-(x|y)(?:$|-)", "space", ({ 1: e3, _: r }) => ({ "&>:not([hidden])~:not([hidden])": { [`--tw-space-${e3}-reverse`]: "0", ["margin-" + { y: "top", x: "left" }[e3]]: `calc(${r} * calc(1 - var(--tw-space-${e3}-reverse)))`, ["margin-" + { y: "bottom", x: "right" }[e3]]: `calc(${r} * var(--tw-space-${e3}-reverse))` } })), yt2("space-(x|y)-reverse", ({ 1: e3 }) => ({ "&>:not([hidden])~:not([hidden])": { [`--tw-space-${e3}-reverse`]: "1" } })), gt("w-", "width"), gt("min-w-", "minWidth"), gt("max-w-", "maxWidth"), gt("h-", "height"), gt("min-h-", "minHeight"), gt("max-h-", "maxHeight"), gt("font-", "fontWeight"), gt("font-", "fontFamily", "fontFamily", p2), yt2("antialiased", { WebkitFontSmoothing: "antialiased", MozOsxFontSmoothing: "grayscale" }), yt2("subpixel-antialiased", { WebkitFontSmoothing: "auto", MozOsxFontSmoothing: "auto" }), yt2("italic", "fontStyle"), yt2("not-italic", { fontStyle: "normal" }), yt2("(ordinal|slashed-zero|(normal|lining|oldstyle|proportional|tabular)-nums|(diagonal|stacked)-fractions)", ({ 1: e3, 2: r = "", 3: a4 }) => r == "normal" ? { fontVariantNumeric: "normal" } : { ["--tw-" + (a4 ? "numeric-fraction" : "pt".includes(r[0]) ? "numeric-spacing" : r ? "numeric-figure" : e3)]: e3, fontVariantNumeric: "var(--tw-ordinal) var(--tw-slashed-zero) var(--tw-numeric-figure) var(--tw-numeric-spacing) var(--tw-numeric-fraction)", "@layer defaults": { "*,::before,::after,::backdrop": { "--tw-ordinal": "var(--tw-empty,/*!*/ /*!*/)", "--tw-slashed-zero": "var(--tw-empty,/*!*/ /*!*/)", "--tw-numeric-figure": "var(--tw-empty,/*!*/ /*!*/)", "--tw-numeric-spacing": "var(--tw-empty,/*!*/ /*!*/)", "--tw-numeric-fraction": "var(--tw-empty,/*!*/ /*!*/)" } } }), gt("tracking-", "letterSpacing"), gt("leading-", "lineHeight"), yt2("list-(inside|outside)", "listStylePosition"), gt("list-", "listStyleType"), yt2("list-", "listStyleType"), gt("placeholder-opacity-", "placeholderOpacity", ({ _: e3 }) => ({ "&::placeholder": { "--tw-placeholder-opacity": e3 } })), mt2("placeholder-", { property: "color", selector: "&::placeholder" }), yt2("text-(left|center|right|justify|start|end)", "textAlign"), yt2("text-(ellipsis|clip)", "textOverflow"), gt("text-opacity-", "textOpacity", "--tw-text-opacity"), mt2("text-", { property: "color" }), gt("text-", "fontSize", ({ _: e3 }) => typeof e3 == "string" ? { fontSize: e3 } : { fontSize: e3[0], ...typeof e3[1] == "string" ? { lineHeight: e3[1] } : e3[1] }), gt("indent-", "textIndent"), yt2("(overline|underline|line-through)", "textDecorationLine"), yt2("no-underline", { textDecorationLine: "none" }), gt("underline-offset-", "textUnderlineOffset"), mt2("decoration-", { section: "textDecorationColor", opacityVariable: false, opacitySection: "opacity" }), gt("decoration-", "textDecorationThickness"), yt2("decoration-", "textDecorationStyle"), yt2("(uppercase|lowercase|capitalize)", "textTransform"), yt2("normal-case", { textTransform: "none" }), yt2("truncate", { overflow: "hidden", whiteSpace: "nowrap", textOverflow: "ellipsis" }), yt2("align-", "verticalAlign"), yt2("whitespace-", "whiteSpace"), yt2("break-normal", { wordBreak: "normal", overflowWrap: "normal" }), yt2("break-words", { overflowWrap: "break-word" }), yt2("break-all", { wordBreak: "break-all" }), mt2("caret-", { opacityVariable: false, opacitySection: "opacity" }), mt2("accent-", { opacityVariable: false, opacitySection: "opacity" }), yt2("bg-gradient-to-([trbl]|[tb][rl])", "backgroundImage", ({ 1: e3 }) => `linear-gradient(to ${g2(e3, " ")},var(--tw-gradient-stops))`), mt2("from-", { section: "gradientColorStops", opacityVariable: false, opacitySection: "opacity" }, ({ _: e3 }) => ({ "--tw-gradient-from": e3.value, "--tw-gradient-to": e3.color({ opacityValue: "0" }), "--tw-gradient-stops": "var(--tw-gradient-from),var(--tw-gradient-to)" })), mt2("via-", { section: "gradientColorStops", opacityVariable: false, opacitySection: "opacity" }, ({ _: e3 }) => ({ "--tw-gradient-to": e3.color({ opacityValue: "0" }), "--tw-gradient-stops": `var(--tw-gradient-from),${e3.value},var(--tw-gradient-to)` })), mt2("to-", { section: "gradientColorStops", property: "--tw-gradient-to", opacityVariable: false, opacitySection: "opacity" }), yt2("bg-(fixed|local|scroll)", "backgroundAttachment"), yt2("bg-origin-(border|padding|content)", "backgroundOrigin", ({ 1: e3 }) => e3 + "-box"), yt2(["bg-(no-repeat|repeat(-[xy])?)", "bg-repeat-(round|space)"], "backgroundRepeat"), yt2("bg-blend-", "backgroundBlendMode"), yt2("bg-clip-(border|padding|content|text)", "backgroundClip", ({ 1: e3 }) => e3 + (e3 == "text" ? "" : "-box")), gt("bg-opacity-", "backgroundOpacity", "--tw-bg-opacity"), mt2("bg-", { section: "backgroundColor" }), gt("bg-", "backgroundImage"), gt("bg-", "backgroundPosition"), yt2("bg-(top|bottom|center|(left|right)(-(top|bottom))?)", "backgroundPosition", y2), gt("bg-", "backgroundSize"), gt("rounded(?:$|-)", "borderRadius"), gt("rounded-([trbl]|[tb][rl])(?:$|-)", "borderRadius", ({ 1: e3, _: r }) => {
  let a4 = { t: ["tl", "tr"], r: ["tr", "br"], b: ["bl", "br"], l: ["bl", "tl"] }[e3] || [e3, e3];
  return { [`border-${g2(a4[0])}-radius`]: r, [`border-${g2(a4[1])}-radius`]: r };
}), yt2("border-(collapse|separate)", "borderCollapse"), gt("border-opacity(?:$|-)", "borderOpacity", "--tw-border-opacity"), yt2("border-(solid|dashed|dotted|double|none)", "borderStyle"), gt("border-spacing(-[xy])?(?:$|-)", "borderSpacing", ({ 1: e3, _: r }) => ({ "@layer defaults": { "*,::before,::after,::backdrop": { "--tw-border-spacing-x": 0, "--tw-border-spacing-y": 0 } }, ["--tw-border-spacing" + (e3 || "-x")]: r, ["--tw-border-spacing" + (e3 || "-y")]: r, "border-spacing": "var(--tw-border-spacing-x) var(--tw-border-spacing-y)" })), mt2("border-([xytrbl])-", { section: "borderColor" }, u("border", "Color")), mt2("border-"), gt("border-([xytrbl])(?:$|-)", "borderWidth", u("border", "Width")), gt("border(?:$|-)", "borderWidth"), gt("divide-opacity(?:$|-)", "divideOpacity", ({ _: e3 }) => ({ "&>:not([hidden])~:not([hidden])": { "--tw-divide-opacity": e3 } })), yt2("divide-(solid|dashed|dotted|double|none)", ({ 1: e3 }) => ({ "&>:not([hidden])~:not([hidden])": { borderStyle: e3 } })), yt2("divide-([xy]-reverse)", ({ 1: e3 }) => ({ "&>:not([hidden])~:not([hidden])": { ["--tw-divide-" + e3]: "1" } })), gt("divide-([xy])(?:$|-)", "divideWidth", ({ 1: e3, _: r }) => {
  let a4 = { x: "lr", y: "tb" }[e3];
  return { "&>:not([hidden])~:not([hidden])": { [`--tw-divide-${e3}-reverse`]: "0", [`border-${g2(a4[0])}Width`]: `calc(${r} * calc(1 - var(--tw-divide-${e3}-reverse)))`, [`border-${g2(a4[1])}Width`]: `calc(${r} * var(--tw-divide-${e3}-reverse))` } };
}), mt2("divide-", { property: "borderColor", selector: "&>:not([hidden])~:not([hidden])" }), gt("ring-opacity(?:$|-)", "ringOpacity", "--tw-ring-opacity"), mt2("ring-offset-", { property: "--tw-ring-offset-color", opacityVariable: false }), gt("ring-offset(?:$|-)", "ringOffsetWidth", "--tw-ring-offset-width"), yt2("ring-inset", { "--tw-ring-inset": "inset" }), mt2("ring-", { property: "--tw-ring-color" }), gt("ring(?:$|-)", "ringWidth", ({ _: e3 }, { theme: r }) => ({ "--tw-ring-offset-shadow": "var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color)", "--tw-ring-shadow": `var(--tw-ring-inset) 0 0 0 calc(${e3} + var(--tw-ring-offset-width)) var(--tw-ring-color)`, boxShadow: "var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)", "@layer defaults": { "*,::before,::after,::backdrop": { "--tw-ring-offset-shadow": "0 0 #0000", "--tw-ring-shadow": "0 0 #0000", "--tw-shadow": "0 0 #0000", "--tw-shadow-colored": "0 0 #0000", "&": { "--tw-ring-inset": "var(--tw-empty,/*!*/ /*!*/)", "--tw-ring-offset-width": r("ringOffsetWidth", "", "0px"), "--tw-ring-offset-color": P4(r("ringOffsetColor", "", "#fff")), "--tw-ring-color": P4(r("ringColor", "", "#93c5fd"), { opacityVariable: "--tw-ring-opacity" }), "--tw-ring-opacity": r("ringOpacity", "", "0.5") } } } })), mt2("shadow-", { section: "boxShadowColor", opacityVariable: false, opacitySection: "opacity" }, ({ _: e3 }) => ({ "--tw-shadow-color": e3.value, "--tw-shadow": "var(--tw-shadow-colored)" })), gt("shadow(?:$|-)", "boxShadow", ({ _: e3 }) => ({ "--tw-shadow": p2(e3), "--tw-shadow-colored": p2(e3).replace(/([^,]\s+)(?:#[a-f\d]+|(?:(?:hsl|rgb)a?|hwb|lab|lch|color|var)\(.+?\)|[a-z]+)(,|$)/g, "$1var(--tw-shadow-color)$2"), boxShadow: "var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)", "@layer defaults": { "*,::before,::after,::backdrop": { "--tw-ring-offset-shadow": "0 0 #0000", "--tw-ring-shadow": "0 0 #0000", "--tw-shadow": "0 0 #0000", "--tw-shadow-colored": "0 0 #0000" } } })), gt("(opacity)-"), yt2("mix-blend-", "mixBlendMode"), ...A3(), ...A3("backdrop-"), gt("transition(?:$|-)", "transitionProperty", (e3, { theme: r }) => ({ transitionProperty: p2(e3), transitionTimingFunction: e3._ == "none" ? void 0 : p2(r("transitionTimingFunction", "")), transitionDuration: e3._ == "none" ? void 0 : p2(r("transitionDuration", "")) })), gt("duration(?:$|-)", "transitionDuration", "transitionDuration", p2), gt("ease(?:$|-)", "transitionTimingFunction", "transitionTimingFunction", p2), gt("delay(?:$|-)", "transitionDelay", "transitionDelay", p2), gt("animate(?:$|-)", "animation", (e3, { theme: r, h: a4 }) => {
  let i2 = p2(e3), l2 = i2.split(" "), d3 = r("keyframes", l2[0]);
  return d3 ? { ["@keyframes " + (l2[0] = a4(l2[0]))]: d3, animation: l2.join(" ") } : { animation: i2 };
}), "(transform)-(none)", yt2("transform", $2), yt2("transform-(cpu|gpu)", ({ 1: e3 }) => ({ "--tw-transform": E(e3 == "gpu") })), gt("scale(-[xy])?-", "scale", ({ 1: e3, _: r }) => ({ ["--tw-scale" + (e3 || "-x")]: r, ["--tw-scale" + (e3 || "-y")]: r, ...$2() })), gt("-?(rotate)-", "rotate", k2), gt("-?(translate-[xy])-", "translate", k2), gt("-?(skew-[xy])-", "skew", k2), yt2("origin-(center|((top|bottom)(-(left|right))?)|left|right)", "transformOrigin", y2), "(appearance)-", gt("(columns)-"), "(columns)-(\\d+)", "(break-(?:before|after|inside))-", gt("(cursor)-"), "(cursor)-", yt2("snap-(none)", "scroll-snap-type"), yt2("snap-(x|y|both)", ({ 1: e3 }) => ({ "scroll-snap-type": e3 + " var(--tw-scroll-snap-strictness)", "@layer defaults": { "*,::before,::after,::backdrop": { "--tw-scroll-snap-strictness": "proximity" } } })), yt2("snap-(mandatory|proximity)", "--tw-scroll-snap-strictness"), yt2("snap-(?:(start|end|center)|align-(none))", "scroll-snap-align"), yt2("snap-(normal|always)", "scroll-snap-stop"), yt2("scroll-(auto|smooth)", "scroll-behavior"), gt("scroll-p([xytrbl])?(?:$|-)", "padding", u("scroll-padding")), gt("-?scroll-m([xytrbl])?(?:$|-)", "scroll-margin", u("scroll-margin")), yt2("touch-(auto|none|manipulation)", "touch-action"), yt2("touch-(pinch-zoom|pan-(?:(x|left|right)|(y|up|down)))", ({ 1: e3, 2: r, 3: a4 }) => ({ [`--tw-${r ? "pan-x" : a4 ? "pan-y" : e3}`]: e3, "touch-action": "var(--tw-touch-action)", "@layer defaults": { "*,::before,::after,::backdrop": { "--tw-pan-x": "var(--tw-empty,/*!*/ /*!*/)", "--tw-pan-y": "var(--tw-empty,/*!*/ /*!*/)", "--tw-pinch-zoom": "var(--tw-empty,/*!*/ /*!*/)", "--tw-touch-action": "var(--tw-pan-x) var(--tw-pan-y) var(--tw-pinch-zoom)" } } })), yt2("outline-none", { outline: "2px solid transparent", "outline-offset": "2px" }), yt2("outline", { outlineStyle: "solid" }), yt2("outline-(dashed|dotted|double|hidden)", "outlineStyle"), gt("(outline-offset)-"), mt2("outline-", { opacityVariable: false, opacitySection: "opacity" }), gt("outline-", "outlineWidth"), "(pointer-events)-", gt("(will-change)-"), "(will-change)-", ["resize(?:-(none|x|y))?", "resize", ({ 1: e3 }) => ({ x: "horizontal", y: "vertical" })[e3] || e3 || "both"], yt2("select-(none|text|all|auto)", "userSelect"), mt2("fill-", { section: "fill", opacityVariable: false, opacitySection: "opacity" }), mt2("stroke-", { section: "stroke", opacityVariable: false, opacitySection: "opacity" }), gt("stroke-", "strokeWidth"), yt2("sr-only", { position: "absolute", width: "1px", height: "1px", padding: "0", margin: "-1px", overflow: "hidden", whiteSpace: "nowrap", clip: "rect(0,0,0,0)", borderWidth: "0" }), yt2("not-sr-only", { position: "static", width: "auto", height: "auto", padding: "0", margin: "0", overflow: "visible", whiteSpace: "normal", clip: "auto" })];
function y2(e3) {
  return (typeof e3 == "string" ? e3 : e3[1]).replace(/-/g, " ").trim();
}
function F6(e3) {
  return (typeof e3 == "string" ? e3 : e3[1]).replace("col", "column");
}
function g2(e3, r = "-") {
  let a4 = [];
  for (let i2 of e3)
    a4.push({ t: "top", r: "right", b: "bottom", l: "left" }[i2]);
  return a4.join(r);
}
function p2(e3) {
  return e3 && "" + (e3._ || e3);
}
function T4({ $$: e3 }) {
  return ({ r: "flex-", "": "flex-", w: "space-", u: "space-", n: "space-" }[e3[3] || ""] || "") + e3;
}
function u(e3, r = "") {
  return ({ 1: a4, _: i2 }) => {
    let l2 = { x: "lr", y: "tb" }[a4] || a4 + a4;
    return l2 ? { ...He(e3 + "-" + g2(l2[0]) + r, i2), ...He(e3 + "-" + g2(l2[1]) + r, i2) } : He(e3 + r, i2);
  };
}
function A3(e3 = "") {
  let r = ["blur", "brightness", "contrast", "grayscale", "hue-rotate", "invert", e3 && "opacity", "saturate", "sepia", !e3 && "drop-shadow"].filter(Boolean), a4 = {};
  for (let i2 of r)
    a4[`--tw-${e3}${i2}`] = "var(--tw-empty,/*!*/ /*!*/)";
  return a4 = { [`${e3}filter`]: r.map((i2) => `var(--tw-${e3}${i2})`).join(" "), "@layer defaults": { "*,::before,::after,::backdrop": a4 } }, [`(${e3}filter)-(none)`, yt2(`${e3}filter`, a4), ...r.map((i2) => gt(`${i2[0] == "h" ? "-?" : ""}(${e3}${i2})(?:$|-)`, i2, ({ 1: l2, _: d3 }) => ({ [`--tw-${l2}`]: b2(d3).map((m4) => `${i2}(${m4})`).join(" "), ...a4 })))];
}
function k2({ 1: e3, _: r }) {
  return { ["--tw-" + e3]: r, ...$2() };
}
function $2() {
  return { transform: "var(--tw-transform)", "@layer defaults": { "*,::before,::after,::backdrop": { "--tw-translate-x": "0", "--tw-translate-y": "0", "--tw-rotate": "0", "--tw-skew-x": "0", "--tw-skew-y": "0", "--tw-scale-x": "1", "--tw-scale-y": "1", "--tw-transform": E() } } };
}
function E(e3) {
  return [e3 ? "translate3d(var(--tw-translate-x),var(--tw-translate-y),0)" : "translateX(var(--tw-translate-x)) translateY(var(--tw-translate-y))", "rotate(var(--tw-rotate))", "skewX(var(--tw-skew-x))", "skewY(var(--tw-skew-y))", "scaleX(var(--tw-scale-x))", "scaleY(var(--tw-scale-y))"].join(" ");
}
function W5({ 1: e3, 2: r }) {
  return `${e3} ${r} / ${e3} ${r}`;
}
function D6({ 1: e3 }) {
  return `repeat(${e3},minmax(0,1fr))`;
}

// https://esm.sh/v106/notie@4.3.1/deno/notie.js
var Me2 = Object.create;
var xe3 = Object.defineProperty;
var He2 = Object.getOwnPropertyDescriptor;
var Se2 = Object.getOwnPropertyNames;
var we2 = Object.getPrototypeOf;
var Oe = Object.prototype.hasOwnProperty;
var Ae2 = (y3, o3) => () => (o3 || y3((o3 = { exports: {} }).exports, o3), o3.exports);
var De = (y3, o3, v2, b4) => {
  if (o3 && typeof o3 == "object" || typeof o3 == "function")
    for (let m4 of Se2(o3))
      !Oe.call(y3, m4) && m4 !== v2 && xe3(y3, m4, { get: () => o3[m4], enumerable: !(b4 = He2(o3, m4)) || b4.enumerable });
  return y3;
};
var Ie = (y3, o3, v2) => (v2 = y3 != null ? Me2(we2(y3)) : {}, De(o3 || !y3 || !y3.__esModule ? xe3(v2, "default", { value: y3, enumerable: true }) : v2, y3));
var ye2 = Ae2((ie4, pe2) => {
  (function(y3, o3) {
    typeof ie4 == "object" && typeof pe2 == "object" ? pe2.exports = o3() : typeof define == "function" && define.amd ? define([], o3) : typeof ie4 == "object" ? ie4.notie = o3() : y3.notie = o3();
  })(ie4, function() {
    return function(y3) {
      function o3(b4) {
        if (v2[b4])
          return v2[b4].exports;
        var m4 = v2[b4] = { i: b4, l: false, exports: {} };
        return y3[b4].call(m4.exports, m4, m4.exports, o3), m4.l = true, m4.exports;
      }
      var v2 = {};
      return o3.m = y3, o3.c = v2, o3.i = function(b4) {
        return b4;
      }, o3.d = function(b4, m4, ce4) {
        o3.o(b4, m4) || Object.defineProperty(b4, m4, { configurable: false, enumerable: true, get: ce4 });
      }, o3.n = function(b4) {
        var m4 = b4 && b4.__esModule ? function() {
          return b4.default;
        } : function() {
          return b4;
        };
        return o3.d(m4, "a", m4), m4;
      }, o3.o = function(b4, m4) {
        return Object.prototype.hasOwnProperty.call(b4, m4);
      }, o3.p = "", o3(o3.s = 1);
    }([function(y3, o3) {
      y3.exports = function(v2) {
        return v2.webpackPolyfill || (v2.deprecate = function() {
        }, v2.paths = [], v2.children || (v2.children = []), Object.defineProperty(v2, "loaded", { enumerable: true, get: function() {
          return v2.l;
        } }), Object.defineProperty(v2, "id", { enumerable: true, get: function() {
          return v2.i;
        } }), v2.webpackPolyfill = 1), v2;
      };
    }, function(y3, o3, v2) {
      "use strict";
      (function(b4) {
        var m4, ce4, re4, V6 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(A5) {
          return typeof A5;
        } : function(A5) {
          return A5 && typeof Symbol == "function" && A5.constructor === Symbol && A5 !== Symbol.prototype ? "symbol" : typeof A5;
        };
        (function(A5, u3) {
          V6(o3) === "object" && V6(b4) === "object" ? b4.exports = u3() : (ce4 = [], m4 = u3, re4 = typeof m4 == "function" ? m4.apply(o3, ce4) : m4, re4 !== void 0 && (b4.exports = re4));
        })(void 0, function() {
          return function(A5) {
            function u3(g5) {
              if (X6[g5])
                return X6[g5].exports;
              var T6 = X6[g5] = { i: g5, l: false, exports: {} };
              return A5[g5].call(T6.exports, T6, T6.exports, u3), T6.l = true, T6.exports;
            }
            var X6 = {};
            return u3.m = A5, u3.c = X6, u3.i = function(g5) {
              return g5;
            }, u3.d = function(g5, T6, B8) {
              u3.o(g5, T6) || Object.defineProperty(g5, T6, { configurable: false, enumerable: true, get: B8 });
            }, u3.n = function(g5) {
              var T6 = g5 && g5.__esModule ? function() {
                return g5.default;
              } : function() {
                return g5;
              };
              return u3.d(T6, "a", T6), T6;
            }, u3.o = function(g5, T6) {
              return Object.prototype.hasOwnProperty.call(g5, T6);
            }, u3.p = "", u3(u3.s = 0);
          }([function(A5, u3, X6) {
            function g5(t4, c3) {
              var s4 = {};
              for (var d3 in t4)
                c3.indexOf(d3) >= 0 || Object.prototype.hasOwnProperty.call(t4, d3) && (s4[d3] = t4[d3]);
              return s4;
            }
            Object.defineProperty(u3, "__esModule", { value: true });
            var T6 = typeof Symbol == "function" && V6(Symbol.iterator) === "symbol" ? function(t4) {
              return typeof t4 > "u" ? "undefined" : V6(t4);
            } : function(t4) {
              return t4 && typeof Symbol == "function" && t4.constructor === Symbol && t4 !== Symbol.prototype ? "symbol" : typeof t4 > "u" ? "undefined" : V6(t4);
            }, B8 = Object.assign || function(t4) {
              for (var c3 = 1; c3 < arguments.length; c3++) {
                var s4 = arguments[c3];
                for (var d3 in s4)
                  Object.prototype.hasOwnProperty.call(s4, d3) && (t4[d3] = s4[d3]);
              }
              return t4;
            }, J4 = { top: "top", bottom: "bottom" }, e3 = { alertTime: 3, dateMonths: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], overlayClickDismiss: true, overlayOpacity: 0.75, transitionCurve: "ease", transitionDuration: 0.3, transitionSelector: "all", classes: { container: "notie-container", textbox: "notie-textbox", textboxInner: "notie-textbox-inner", button: "notie-button", element: "notie-element", elementHalf: "notie-element-half", elementThird: "notie-element-third", overlay: "notie-overlay", backgroundSuccess: "notie-background-success", backgroundWarning: "notie-background-warning", backgroundError: "notie-background-error", backgroundInfo: "notie-background-info", backgroundNeutral: "notie-background-neutral", backgroundOverlay: "notie-background-overlay", alert: "notie-alert", inputField: "notie-input-field", selectChoiceRepeated: "notie-select-choice-repeated", dateSelectorInner: "notie-date-selector-inner", dateSelectorUp: "notie-date-selector-up" }, ids: { overlay: "notie-overlay" }, positions: { alert: J4.top, force: J4.top, confirm: J4.top, input: J4.top, select: J4.bottom, date: J4.top } }, ge2 = u3.setOptions = function(t4) {
              e3 = B8({}, e3, t4, { classes: B8({}, e3.classes, t4.classes), ids: B8({}, e3.ids, t4.ids), positions: B8({}, e3.positions, t4.positions) });
            }, fe = function() {
              return new Promise(function(t4) {
                return setTimeout(t4, 0);
              });
            }, oe5 = function(t4) {
              return new Promise(function(c3) {
                return setTimeout(c3, 1e3 * t4);
              });
            }, R6 = function() {
              document.activeElement && document.activeElement.blur();
            }, W7 = function() {
              var t4 = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c3) {
                var s4 = 16 * Math.random() | 0, d3 = c3 === "x" ? s4 : 3 & s4 | 8;
                return d3.toString(16);
              });
              return "notie-" + t4;
            }, le4 = { 1: e3.classes.backgroundSuccess, success: e3.classes.backgroundSuccess, 2: e3.classes.backgroundWarning, warning: e3.classes.backgroundWarning, 3: e3.classes.backgroundError, error: e3.classes.backgroundError, 4: e3.classes.backgroundInfo, info: e3.classes.backgroundInfo, 5: e3.classes.backgroundNeutral, neutral: e3.classes.backgroundNeutral }, me2 = function() {
              return e3.transitionSelector + " " + e3.transitionDuration + "s " + e3.transitionCurve;
            }, $4 = function(t4) {
              return t4.keyCode === 13;
            }, ee4 = function(t4) {
              return t4.keyCode === 27;
            }, K6 = function(t4, c3) {
              t4.classList.add(e3.classes.container), t4.style[c3] = "-10000px", document.body.appendChild(t4), t4.style[c3] = "-" + t4.offsetHeight + "px", t4.listener && window.addEventListener("keydown", t4.listener), fe().then(function() {
                t4.style.transition = me2(), t4.style[c3] = 0;
              });
            }, O4 = function(t4, c3) {
              var s4 = document.getElementById(t4);
              s4 && (s4.style[c3] = "-" + s4.offsetHeight + "px", s4.listener && window.removeEventListener("keydown", s4.listener), oe5(e3.transitionDuration).then(function() {
                s4.parentNode && s4.parentNode.removeChild(s4);
              }));
            }, te2 = function(t4, c3) {
              var s4 = document.createElement("div");
              s4.id = e3.ids.overlay, s4.classList.add(e3.classes.overlay), s4.classList.add(e3.classes.backgroundOverlay), s4.style.opacity = 0, t4 && e3.overlayClickDismiss && (s4.onclick = function() {
                O4(t4.id, c3), j5();
              }), document.body.appendChild(s4), fe().then(function() {
                s4.style.transition = me2(), s4.style.opacity = e3.overlayOpacity;
              });
            }, j5 = function() {
              var t4 = document.getElementById(e3.ids.overlay);
              t4.style.opacity = 0, oe5(e3.transitionDuration).then(function() {
                t4.parentNode && t4.parentNode.removeChild(t4);
              });
            }, F8 = u3.hideAlerts = function(t4) {
              var c3 = document.getElementsByClassName(e3.classes.alert);
              if (c3.length) {
                for (var s4 = 0; s4 < c3.length; s4++) {
                  var d3 = c3[s4];
                  O4(d3.id, d3.position);
                }
                t4 && oe5(e3.transitionDuration).then(function() {
                  return t4();
                });
              }
            }, he2 = u3.alert = function(t4) {
              var c3 = t4.type, s4 = c3 === void 0 ? 4 : c3, d3 = t4.text, i2 = t4.time, k4 = i2 === void 0 ? e3.alertTime : i2, H7 = t4.stay, S7 = H7 !== void 0 && H7, h3 = t4.position, p6 = h3 === void 0 ? e3.positions.alert || p6.top : h3;
              R6(), F8();
              var l2 = document.createElement("div"), f4 = W7();
              l2.id = f4, l2.position = p6, l2.classList.add(e3.classes.textbox), l2.classList.add(le4[s4]), l2.classList.add(e3.classes.alert), l2.innerHTML = '<div class="' + e3.classes.textboxInner + '">' + d3 + "</div>", l2.onclick = function() {
                return O4(f4, p6);
              }, l2.listener = function(n3) {
                ($4(n3) || ee4(n3)) && F8();
              }, K6(l2, p6), k4 && k4 < 1 && (k4 = 1), !S7 && k4 && oe5(k4).then(function() {
                return O4(f4, p6);
              });
            }, ke2 = u3.force = function(t4, c3) {
              var s4 = t4.type, d3 = s4 === void 0 ? 5 : s4, i2 = t4.text, k4 = t4.buttonText, H7 = k4 === void 0 ? "OK" : k4, S7 = t4.callback, h3 = t4.position, p6 = h3 === void 0 ? e3.positions.force || p6.top : h3;
              R6(), F8();
              var l2 = document.createElement("div"), f4 = W7();
              l2.id = f4;
              var n3 = document.createElement("div");
              n3.classList.add(e3.classes.textbox), n3.classList.add(e3.classes.backgroundInfo), n3.innerHTML = '<div class="' + e3.classes.textboxInner + '">' + i2 + "</div>";
              var r = document.createElement("div");
              r.classList.add(e3.classes.button), r.classList.add(le4[d3]), r.innerHTML = H7, r.onclick = function() {
                O4(f4, p6), j5(), S7 ? S7() : c3 && c3();
              }, l2.appendChild(n3), l2.appendChild(r), l2.listener = function(C5) {
                $4(C5) && r.click();
              }, K6(l2, p6), te2();
            }, Ce3 = u3.confirm = function(t4, c3, s4) {
              var d3 = t4.text, i2 = t4.submitText, k4 = i2 === void 0 ? "Yes" : i2, H7 = t4.cancelText, S7 = H7 === void 0 ? "Cancel" : H7, h3 = t4.submitCallback, p6 = t4.cancelCallback, l2 = t4.position, f4 = l2 === void 0 ? e3.positions.confirm || f4.top : l2;
              R6(), F8();
              var n3 = document.createElement("div"), r = W7();
              n3.id = r;
              var C5 = document.createElement("div");
              C5.classList.add(e3.classes.textbox), C5.classList.add(e3.classes.backgroundInfo), C5.innerHTML = '<div class="' + e3.classes.textboxInner + '">' + d3 + "</div>";
              var x5 = document.createElement("div");
              x5.classList.add(e3.classes.button), x5.classList.add(e3.classes.elementHalf), x5.classList.add(e3.classes.backgroundSuccess), x5.innerHTML = k4, x5.onclick = function() {
                O4(r, f4), j5(), h3 ? h3() : c3 && c3();
              };
              var a4 = document.createElement("div");
              a4.classList.add(e3.classes.button), a4.classList.add(e3.classes.elementHalf), a4.classList.add(e3.classes.backgroundError), a4.innerHTML = S7, a4.onclick = function() {
                O4(r, f4), j5(), p6 ? p6() : s4 && s4();
              }, n3.appendChild(C5), n3.appendChild(x5), n3.appendChild(a4), n3.listener = function(E3) {
                $4(E3) ? x5.click() : ee4(E3) && a4.click();
              }, K6(n3, f4), te2(n3, f4);
            }, ve2 = function(t4, c3, s4) {
              var d3 = t4.text, i2 = t4.submitText, k4 = i2 === void 0 ? "Submit" : i2, H7 = t4.cancelText, S7 = H7 === void 0 ? "Cancel" : H7, h3 = t4.submitCallback, p6 = t4.cancelCallback, l2 = t4.position, f4 = l2 === void 0 ? e3.positions.input || f4.top : l2, n3 = g5(t4, ["text", "submitText", "cancelText", "submitCallback", "cancelCallback", "position"]);
              R6(), F8();
              var r = document.createElement("div"), C5 = W7();
              r.id = C5;
              var x5 = document.createElement("div");
              x5.classList.add(e3.classes.textbox), x5.classList.add(e3.classes.backgroundInfo), x5.innerHTML = '<div class="' + e3.classes.textboxInner + '">' + d3 + "</div>";
              var a4 = document.createElement("input");
              a4.classList.add(e3.classes.inputField), a4.setAttribute("autocapitalize", n3.autocapitalize || "none"), a4.setAttribute("autocomplete", n3.autocomplete || "off"), a4.setAttribute("autocorrect", n3.autocorrect || "off"), a4.setAttribute("autofocus", n3.autofocus || "true"), a4.setAttribute("inputmode", n3.inputmode || "verbatim"), a4.setAttribute("max", n3.max || ""), a4.setAttribute("maxlength", n3.maxlength || ""), a4.setAttribute("min", n3.min || ""), a4.setAttribute("minlength", n3.minlength || ""), a4.setAttribute("placeholder", n3.placeholder || ""), a4.setAttribute("spellcheck", n3.spellcheck || "default"), a4.setAttribute("step", n3.step || "any"), a4.setAttribute("type", n3.type || "text"), a4.value = n3.value || "", n3.allowed && (a4.oninput = function() {
                var M5 = void 0;
                if (Array.isArray(n3.allowed)) {
                  for (var w4 = "", _2 = n3.allowed, P7 = 0; P7 < _2.length; P7++)
                    _2[P7] === "an" ? w4 += "0-9a-zA-Z" : _2[P7] === "a" ? w4 += "a-zA-Z" : _2[P7] === "n" && (w4 += "0-9"), _2[P7] === "s" && (w4 += " ");
                  M5 = new RegExp("[^" + w4 + "]", "g");
                } else
                  T6(n3.allowed) === "object" && (M5 = n3.allowed);
                a4.value = a4.value.replace(M5, "");
              });
              var E3 = document.createElement("div");
              E3.classList.add(e3.classes.button), E3.classList.add(e3.classes.elementHalf), E3.classList.add(e3.classes.backgroundSuccess), E3.innerHTML = k4, E3.onclick = function() {
                O4(C5, f4), j5(), h3 ? h3(a4.value) : c3 && c3(a4.value);
              };
              var D9 = document.createElement("div");
              D9.classList.add(e3.classes.button), D9.classList.add(e3.classes.elementHalf), D9.classList.add(e3.classes.backgroundError), D9.innerHTML = S7, D9.onclick = function() {
                O4(C5, f4), j5(), p6 ? p6(a4.value) : s4 && s4(a4.value);
              }, r.appendChild(x5), r.appendChild(a4), r.appendChild(E3), r.appendChild(D9), r.listener = function(M5) {
                $4(M5) ? E3.click() : ee4(M5) && D9.click();
              }, K6(r, f4), a4.focus(), te2(r, f4);
            };
            u3.input = ve2;
            var Ee2 = u3.select = function(t4, c3) {
              var s4 = t4.text, d3 = t4.cancelText, i2 = d3 === void 0 ? "Cancel" : d3, k4 = t4.cancelCallback, H7 = t4.choices, S7 = t4.position, h3 = S7 === void 0 ? e3.positions.select || h3.top : S7;
              R6(), F8();
              var p6 = document.createElement("div"), l2 = W7();
              p6.id = l2;
              var f4 = document.createElement("div");
              f4.classList.add(e3.classes.textbox), f4.classList.add(e3.classes.backgroundInfo), f4.innerHTML = '<div class="' + e3.classes.textboxInner + '">' + s4 + "</div>", p6.appendChild(f4), H7.forEach(function(r, C5) {
                var x5 = r.type, a4 = x5 === void 0 ? 1 : x5, E3 = r.text, D9 = r.handler, M5 = document.createElement("div");
                M5.classList.add(le4[a4]), M5.classList.add(e3.classes.button), M5.classList.add(e3.classes.selectChoice);
                var w4 = H7[C5 + 1];
                w4 && !w4.type && (w4.type = 1), w4 && w4.type === a4 && M5.classList.add(e3.classes.selectChoiceRepeated), M5.innerHTML = E3, M5.onclick = function() {
                  O4(l2, h3), j5(), D9();
                }, p6.appendChild(M5);
              });
              var n3 = document.createElement("div");
              n3.classList.add(e3.classes.backgroundNeutral), n3.classList.add(e3.classes.button), n3.innerHTML = i2, n3.onclick = function() {
                O4(l2, h3), j5(), k4 ? k4() : c3 && c3();
              }, p6.appendChild(n3), p6.listener = function(r) {
                ee4(r) && n3.click();
              }, K6(p6, h3), te2(p6, h3);
            }, Te = u3.date = function(t4, c3, s4) {
              var d3 = t4.value, i2 = d3 === void 0 ? /* @__PURE__ */ new Date() : d3, k4 = t4.submitText, H7 = k4 === void 0 ? "OK" : k4, S7 = t4.cancelText, h3 = S7 === void 0 ? "Cancel" : S7, p6 = t4.submitCallback, l2 = t4.cancelCallback, f4 = t4.position, n3 = f4 === void 0 ? e3.positions.date || n3.top : f4;
              R6(), F8();
              var r = "&#9662", C5 = document.createElement("div"), x5 = document.createElement("div"), a4 = document.createElement("div"), E3 = function(L6) {
                C5.innerHTML = e3.dateMonths[L6.getMonth()], x5.innerHTML = L6.getDate(), a4.innerHTML = L6.getFullYear();
              }, D9 = function(L6) {
                var N7 = new Date(i2.getFullYear(), i2.getMonth() + 1, 0).getDate(), Q6 = L6.target.textContent.replace(/^0+/, "").replace(/[^\d]/g, "").slice(0, 2);
                Number(Q6) > N7 && (Q6 = N7.toString()), L6.target.textContent = Q6, Number(Q6) < 1 && (Q6 = "1"), i2.setDate(Number(Q6));
              }, M5 = function(L6) {
                var N7 = L6.target.textContent.replace(/^0+/, "").replace(/[^\d]/g, "").slice(0, 4);
                L6.target.textContent = N7, i2.setFullYear(Number(N7));
              }, w4 = function(L6) {
                E3(i2);
              }, _2 = function(L6) {
                var N7 = new Date(i2.getFullYear(), i2.getMonth() + L6 + 1, 0).getDate();
                i2.getDate() > N7 && i2.setDate(N7), i2.setMonth(i2.getMonth() + L6), E3(i2);
              }, P7 = function(L6) {
                i2.setDate(i2.getDate() + L6), E3(i2);
              }, be = function(L6) {
                var N7 = i2.getFullYear() + L6;
                N7 < 0 ? i2.setFullYear(0) : i2.setFullYear(i2.getFullYear() + L6), E3(i2);
              }, Y6 = document.createElement("div"), de2 = W7();
              Y6.id = de2;
              var ue3 = document.createElement("div");
              ue3.classList.add(e3.classes.backgroundInfo);
              var I5 = document.createElement("div");
              I5.classList.add(e3.classes.dateSelectorInner);
              var Z5 = document.createElement("div");
              Z5.classList.add(e3.classes.button), Z5.classList.add(e3.classes.elementThird), Z5.classList.add(e3.classes.dateSelectorUp), Z5.innerHTML = r;
              var q6 = document.createElement("div");
              q6.classList.add(e3.classes.button), q6.classList.add(e3.classes.elementThird), q6.classList.add(e3.classes.dateSelectorUp), q6.innerHTML = r;
              var G7 = document.createElement("div");
              G7.classList.add(e3.classes.button), G7.classList.add(e3.classes.elementThird), G7.classList.add(e3.classes.dateSelectorUp), G7.innerHTML = r, C5.classList.add(e3.classes.element), C5.classList.add(e3.classes.elementThird), C5.innerHTML = e3.dateMonths[i2.getMonth()], x5.classList.add(e3.classes.element), x5.classList.add(e3.classes.elementThird), x5.setAttribute("contentEditable", true), x5.addEventListener("input", D9), x5.addEventListener("blur", w4), x5.innerHTML = i2.getDate(), a4.classList.add(e3.classes.element), a4.classList.add(e3.classes.elementThird), a4.setAttribute("contentEditable", true), a4.addEventListener("input", M5), a4.addEventListener("blur", w4), a4.innerHTML = i2.getFullYear();
              var ne4 = document.createElement("div");
              ne4.classList.add(e3.classes.button), ne4.classList.add(e3.classes.elementThird), ne4.innerHTML = r;
              var se3 = document.createElement("div");
              se3.classList.add(e3.classes.button), se3.classList.add(e3.classes.elementThird), se3.innerHTML = r;
              var ae5 = document.createElement("div");
              ae5.classList.add(e3.classes.button), ae5.classList.add(e3.classes.elementThird), ae5.innerHTML = r, Z5.onclick = function() {
                return _2(1);
              }, q6.onclick = function() {
                return P7(1);
              }, G7.onclick = function() {
                return be(1);
              }, ne4.onclick = function() {
                return _2(-1);
              }, se3.onclick = function() {
                return P7(-1);
              }, ae5.onclick = function() {
                return be(-1);
              };
              var z4 = document.createElement("div");
              z4.classList.add(e3.classes.button), z4.classList.add(e3.classes.elementHalf), z4.classList.add(e3.classes.backgroundSuccess), z4.innerHTML = H7, z4.onclick = function() {
                O4(de2, n3), j5(), p6 ? p6(i2) : c3 && c3(i2);
              };
              var U5 = document.createElement("div");
              U5.classList.add(e3.classes.button), U5.classList.add(e3.classes.elementHalf), U5.classList.add(e3.classes.backgroundError), U5.innerHTML = h3, U5.onclick = function() {
                O4(de2, n3), j5(), l2 ? l2(i2) : s4 && s4(i2);
              }, I5.appendChild(Z5), I5.appendChild(q6), I5.appendChild(G7), I5.appendChild(C5), I5.appendChild(x5), I5.appendChild(a4), I5.appendChild(ne4), I5.appendChild(se3), I5.appendChild(ae5), ue3.appendChild(I5), Y6.appendChild(ue3), Y6.appendChild(z4), Y6.appendChild(U5), Y6.listener = function(L6) {
                $4(L6) ? z4.click() : ee4(L6) && U5.click();
              }, K6(Y6, n3), te2(Y6, n3);
            };
            u3.default = { alert: he2, force: ke2, confirm: Ce3, input: ve2, select: Ee2, date: Te, setOptions: ge2, hideAlerts: F8 };
          }]);
        });
      }).call(o3, v2(0)(y3));
    }]);
  });
});
var je = Ie(ye2());
var { default: Le, ...Ne2 } = je;
var Fe = Le !== void 0 ? Le : Ne2;

// https://esm.sh/v106/nanostores@0.7.1/deno/nanostores.js
var S5 = Symbol("clean");
var c2 = Symbol();

// https://esm.sh/v106/@nanostores/i18n@0.7.1/deno/i18n.js
function g3(r, n3) {
  if (typeof r == "string")
    return n3(r);
  {
    let e3 = {};
    for (let t4 in r)
      e3[t4] = g3(r[t4], n3);
    return e3;
  }
}
function p4(r) {
  return (n3) => {
    if (n3.transform) {
      let e3 = n3.transform;
      return n3 = n3.input, { input: n3, transform(t4, o3, s4) {
        let f4 = r(t4, o3, ...s4);
        return (...l2) => e3(t4, f4, l2);
      } };
    } else
      return { input: n3, transform(e3, t4, o3) {
        return r(e3, t4, ...o3);
      } };
  };
}
var N5 = p4((r, n3, e3) => g3(n3, (t4) => {
  for (let o3 in e3)
    t4 = t4.replace(new RegExp(`{${o3}}`, "g"), e3[o3]);
  return t4;
}));
var R4 = p4((r, n3, e3) => {
  let t4 = new Intl.PluralRules(r).select(e3);
  return t4 in n3 || (t4 = "many"), g3(n3[t4], (o3) => o3.replace(/{count}/g, e3));
});

// https://esm.sh/v106/hotkeys-js@3.10.1/deno/hotkeys-js.js
var M4 = typeof navigator < "u" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
function P6(e3, t4, i2, r) {
  e3.addEventListener ? e3.addEventListener(t4, i2, r) : e3.attachEvent && e3.attachEvent("on".concat(t4), function() {
    i2(window.event);
  });
}
function T5(e3, t4) {
  for (var i2 = t4.slice(0, t4.length - 1), r = 0; r < i2.length; r++)
    i2[r] = e3[i2[r].toLowerCase()];
  return i2;
}
function U4(e3) {
  typeof e3 != "string" && (e3 = ""), e3 = e3.replace(/\s/g, "");
  for (var t4 = e3.split(","), i2 = t4.lastIndexOf(""); i2 >= 0; )
    t4[i2 - 1] += ",", t4.splice(i2, 1), i2 = t4.lastIndexOf("");
  return t4;
}
function G6(e3, t4) {
  for (var i2 = e3.length >= t4.length ? e3 : t4, r = e3.length >= t4.length ? t4 : e3, n3 = true, a4 = 0; a4 < i2.length; a4++)
    r.indexOf(i2[a4]) === -1 && (n3 = false);
  return n3;
}
var b3 = { backspace: 8, "\u232B": 8, tab: 9, clear: 12, enter: 13, "\u21A9": 13, return: 13, esc: 27, escape: 27, space: 32, left: 37, up: 38, right: 39, down: 40, del: 46, delete: 46, ins: 45, insert: 45, home: 36, end: 35, pageup: 33, pagedown: 34, capslock: 20, num_0: 96, num_1: 97, num_2: 98, num_3: 99, num_4: 100, num_5: 101, num_6: 102, num_7: 103, num_8: 104, num_9: 105, num_multiply: 106, num_add: 107, num_enter: 108, num_subtract: 109, num_decimal: 110, num_divide: 111, "\u21EA": 20, ",": 188, ".": 190, "/": 191, "`": 192, "-": M4 ? 173 : 189, "=": M4 ? 61 : 187, ";": M4 ? 59 : 186, "'": 222, "[": 219, "]": 221, "\\": 220 };
var g4 = { "\u21E7": 16, shift: 16, "\u2325": 18, alt: 18, option: 18, "\u2303": 17, ctrl: 17, control: 17, "\u2318": 91, cmd: 91, command: 91 };
var L5 = { 16: "shiftKey", 18: "altKey", 17: "ctrlKey", 91: "metaKey", shiftKey: 16, ctrlKey: 17, altKey: 18, metaKey: 91 };
var u2 = { 16: false, 18: false, 17: false, 91: false };
var s3 = {};
for (O3 = 1; O3 < 20; O3++)
  b3["f".concat(O3)] = 111 + O3;
var O3;
var f3 = [];
var A4 = false;
var D7 = "all";
var H6 = [];
var C4 = function(t4) {
  return b3[t4.toLowerCase()] || g4[t4.toLowerCase()] || t4.toUpperCase().charCodeAt(0);
};
var R5 = function(t4) {
  return Object.keys(b3).find(function(i2) {
    return b3[i2] === t4;
  });
};
var V5 = function(t4) {
  return Object.keys(g4).find(function(i2) {
    return g4[i2] === t4;
  });
};
function F7(e3) {
  D7 = e3 || "all";
}
function E2() {
  return D7 || "all";
}
function X5() {
  return f3.slice(0);
}
function $3() {
  return f3.map(function(e3) {
    return R5(e3) || V5(e3) || String.fromCharCode(e3);
  });
}
function q5(e3) {
  var t4 = e3.target || e3.srcElement, i2 = t4.tagName, r = true;
  return (t4.isContentEditable || (i2 === "INPUT" || i2 === "TEXTAREA" || i2 === "SELECT") && !t4.readOnly) && (r = false), r;
}
function z3(e3) {
  return typeof e3 == "string" && (e3 = C4(e3)), f3.indexOf(e3) !== -1;
}
function J3(e3, t4) {
  var i2, r;
  e3 || (e3 = E2());
  for (var n3 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, n3))
      for (i2 = s3[n3], r = 0; r < i2.length; )
        i2[r].scope === e3 ? i2.splice(r, 1) : r++;
  E2() === e3 && F7(t4 || "all");
}
function N6(e3) {
  var t4 = e3.keyCode || e3.which || e3.charCode, i2 = f3.indexOf(t4);
  if (i2 >= 0 && f3.splice(i2, 1), e3.key && e3.key.toLowerCase() === "meta" && f3.splice(0, f3.length), (t4 === 93 || t4 === 224) && (t4 = 91), t4 in u2) {
    u2[t4] = false;
    for (var r in g4)
      g4[r] === t4 && (v[r] = false);
  }
}
function Q5(e3) {
  if (typeof e3 > "u")
    Object.keys(s3).forEach(function(o3) {
      return delete s3[o3];
    });
  else if (Array.isArray(e3))
    e3.forEach(function(o3) {
      o3.key && S6(o3);
    });
  else if (typeof e3 == "object")
    e3.key && S6(e3);
  else if (typeof e3 == "string") {
    for (var t4 = arguments.length, i2 = new Array(t4 > 1 ? t4 - 1 : 0), r = 1; r < t4; r++)
      i2[r - 1] = arguments[r];
    var n3 = i2[0], a4 = i2[1];
    typeof n3 == "function" && (a4 = n3, n3 = ""), S6({ key: e3, scope: n3, method: a4, splitKey: "+" });
  }
}
var S6 = function(t4) {
  var i2 = t4.key, r = t4.scope, n3 = t4.method, a4 = t4.splitKey, o3 = a4 === void 0 ? "+" : a4, l2 = U4(i2);
  l2.forEach(function(c3) {
    var p6 = c3.split(o3), m4 = p6.length, y3 = p6[m4 - 1], d3 = y3 === "*" ? "*" : C4(y3);
    if (s3[d3]) {
      r || (r = E2());
      var K6 = m4 > 1 ? T5(g4, p6) : [];
      s3[d3] = s3[d3].filter(function(h3) {
        var w4 = n3 ? h3.method === n3 : true;
        return !(w4 && h3.scope === r && G6(h3.mods, K6));
      });
    }
  });
};
function _(e3, t4, i2, r) {
  if (t4.element === r) {
    var n3;
    if (t4.scope === i2 || t4.scope === "all") {
      n3 = t4.mods.length > 0;
      for (var a4 in u2)
        Object.prototype.hasOwnProperty.call(u2, a4) && (!u2[a4] && t4.mods.indexOf(+a4) > -1 || u2[a4] && t4.mods.indexOf(+a4) === -1) && (n3 = false);
      (t4.mods.length === 0 && !u2[16] && !u2[18] && !u2[17] && !u2[91] || n3 || t4.shortcut === "*") && t4.method(e3, t4) === false && (e3.preventDefault ? e3.preventDefault() : e3.returnValue = false, e3.stopPropagation && e3.stopPropagation(), e3.cancelBubble && (e3.cancelBubble = true));
    }
  }
}
function k3(e3, t4) {
  var i2 = s3["*"], r = e3.keyCode || e3.which || e3.charCode;
  if (v.filter.call(this, e3)) {
    if ((r === 93 || r === 224) && (r = 91), f3.indexOf(r) === -1 && r !== 229 && f3.push(r), ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(h3) {
      var w4 = L5[h3];
      e3[h3] && f3.indexOf(w4) === -1 ? f3.push(w4) : !e3[h3] && f3.indexOf(w4) > -1 ? f3.splice(f3.indexOf(w4), 1) : h3 === "metaKey" && e3[h3] && f3.length === 3 && (e3.ctrlKey || e3.shiftKey || e3.altKey || (f3 = f3.slice(f3.indexOf(w4))));
    }), r in u2) {
      u2[r] = true;
      for (var n3 in g4)
        g4[n3] === r && (v[n3] = true);
      if (!i2)
        return;
    }
    for (var a4 in u2)
      Object.prototype.hasOwnProperty.call(u2, a4) && (u2[a4] = e3[L5[a4]]);
    e3.getModifierState && !(e3.altKey && !e3.ctrlKey) && e3.getModifierState("AltGraph") && (f3.indexOf(17) === -1 && f3.push(17), f3.indexOf(18) === -1 && f3.push(18), u2[17] = true, u2[18] = true);
    var o3 = E2();
    if (i2)
      for (var l2 = 0; l2 < i2.length; l2++)
        i2[l2].scope === o3 && (e3.type === "keydown" && i2[l2].keydown || e3.type === "keyup" && i2[l2].keyup) && _(e3, i2[l2], o3, t4);
    if (r in s3) {
      for (var c3 = 0; c3 < s3[r].length; c3++)
        if ((e3.type === "keydown" && s3[r][c3].keydown || e3.type === "keyup" && s3[r][c3].keyup) && s3[r][c3].key) {
          for (var p6 = s3[r][c3], m4 = p6.splitKey, y3 = p6.key.split(m4), d3 = [], K6 = 0; K6 < y3.length; K6++)
            d3.push(C4(y3[K6]));
          d3.sort().join("") === f3.sort().join("") && _(e3, p6, o3, t4);
        }
    }
  }
}
function W6(e3) {
  return H6.indexOf(e3) > -1;
}
function v(e3, t4, i2) {
  f3 = [];
  var r = U4(e3), n3 = [], a4 = "all", o3 = document, l2 = 0, c3 = false, p6 = true, m4 = "+", y3 = false;
  for (i2 === void 0 && typeof t4 == "function" && (i2 = t4), Object.prototype.toString.call(t4) === "[object Object]" && (t4.scope && (a4 = t4.scope), t4.element && (o3 = t4.element), t4.keyup && (c3 = t4.keyup), t4.keydown !== void 0 && (p6 = t4.keydown), t4.capture !== void 0 && (y3 = t4.capture), typeof t4.splitKey == "string" && (m4 = t4.splitKey)), typeof t4 == "string" && (a4 = t4); l2 < r.length; l2++)
    e3 = r[l2].split(m4), n3 = [], e3.length > 1 && (n3 = T5(g4, e3)), e3 = e3[e3.length - 1], e3 = e3 === "*" ? "*" : C4(e3), e3 in s3 || (s3[e3] = []), s3[e3].push({ keyup: c3, keydown: p6, scope: a4, mods: n3, shortcut: r[l2], method: i2, key: r[l2], splitKey: m4, element: o3 });
  typeof o3 < "u" && !W6(o3) && window && (H6.push(o3), P6(o3, "keydown", function(d3) {
    k3(d3, o3);
  }, y3), A4 || (A4 = true, P6(window, "focus", function() {
    f3 = [];
  }, y3)), P6(o3, "keyup", function(d3) {
    k3(d3, o3), N6(d3);
  }, y3));
}
function Y5(e3) {
  var t4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(s3).forEach(function(i2) {
    var r = s3[i2].filter(function(n3) {
      return n3.scope === t4 && n3.shortcut === e3;
    });
    r.forEach(function(n3) {
      n3 && n3.method && n3.method();
    });
  });
}
var j4 = { getPressedKeyString: $3, setScope: F7, getScope: E2, deleteScope: J3, getPressedKeyCodes: X5, isPressed: z3, filter: q5, trigger: Y5, unbind: Q5, keyMap: b3, modifier: g4, modifierMap: L5 };
for (x4 in j4)
  Object.prototype.hasOwnProperty.call(j4, x4) && (v[x4] = j4[x4]);
var x4;
typeof document < "u" && (B7 = window.hotkeys, v.noConflict = function(e3) {
  return e3 && window.hotkeys === v && (window.hotkeys = B7), v;
}, window.hotkeys = v);
var B7;

// deps.ts
var toast = Fe.alert;

// log.ts
var Timing = class {
  #t = performance.now();
  reset() {
    this.#t = performance.now();
  }
  stop(message) {
    const now = performance.now();
    const d3 = Math.round(now - this.#t);
    let cf = colors_exports.green;
    if (d3 > 1e4) {
      cf = colors_exports.red;
    } else if (d3 > 1e3) {
      cf = colors_exports.yellow;
    }
    console.debug(
      colors_exports.dim(brandName + " TIMING:"),
      message,
      "in",
      cf(d3 + "ms")
    );
    this.#t = now;
  }
};
var Logger = class {
  #level = 1 /* Info */;
  get level() {
    return this.#level;
  }
  setLevel(level) {
    switch (level) {
      case "debug":
        this.#level = 0 /* Debug */;
        break;
      case "info":
        this.#level = 1 /* Info */;
        break;
      case "warn":
        this.#level = 2 /* Warn */;
        break;
      case "error":
        this.#level = 3 /* Error */;
        break;
      case "fatal":
        this.#level = 4 /* Fatal */;
        break;
    }
  }
  debug(...args) {
    if (this.#level <= 0 /* Debug */) {
      console.log(colors_exports.dim(brandName + " DEBUG:"), ...args);
    }
  }
  v(...args) {
    if (this.#level <= 0 /* Debug */) {
      console.log(colors_exports.dim(brandName + " VERBOSE:"), ...args);
    }
  }
  info(...args) {
    if (this.#level <= 1 /* Info */) {
      console.log(colors_exports.green(brandName + " INFO:"), ...args);
    }
  }
  l(...args) {
    if (this.#level <= 1 /* Info */) {
      console.log(colors_exports.green(brandName + " TEMP INFO:"), ...args);
    }
  }
  warn(...args) {
    if (this.#level <= 2 /* Warn */) {
      console.warn(colors_exports.yellow(brandName + " WARN:"), ...args);
    }
  }
  error(...args) {
    if (this.#level <= 3 /* Error */) {
      console.error(colors_exports.red(brandName + " ERROR:"), ...args);
    }
  }
  fatal(...args) {
    if (this.#level <= 4 /* Fatal */) {
      console.error(colors_exports.red(brandName + " FATAL:"), ...args);
    }
  }
  timing() {
    if (this.level === 0 /* Debug */) {
      return new Timing();
    }
    return { reset: () => {
    }, stop: () => {
    } };
  }
};
var log_default = new Logger();

// utils/is_mobile.ts
var appleIphone = /iPhone/i;
var appleIpod = /iPod/i;
var appleTablet = /iPad/i;
var appleUniversal = /\biOS-universal(?:.+)Mac\b/i;
var androidPhone = /\bAndroid(?:.+)Mobile\b/i;
var androidTablet = /Android/i;
var amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i;
var amazonTablet = /Silk/i;
var windowsPhone = /Windows Phone/i;
var windowsTablet = /\bWindows(?:.+)ARM\b/i;
var otherBlackBerry = /BlackBerry/i;
var otherBlackBerry10 = /BB10/i;
var otherOpera = /Opera Mini/i;
var otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i;
var otherFirefox = /Mobile(?:.+)Firefox\b/i;
var isAppleTabletOnIos13 = (navigator2) => {
  return typeof navigator2 !== "undefined" && navigator2.platform === "MacIntel" && typeof navigator2.maxTouchPoints === "number" && // @ts-ignore: it's ok
  navigator2.maxTouchPoints > 1 && typeof globalThis.MSStream === "undefined";
};
function createMatch(userAgent) {
  return (regex) => regex.test(userAgent);
}
function isMobile(param) {
  let nav = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  if (!param && typeof navigator !== "undefined") {
    nav = {
      userAgent: navigator.userAgent,
      platform: navigator.platform,
      maxTouchPoints: navigator.maxTouchPoints || 0
    };
  } else if (typeof param === "string") {
    nav.userAgent = param;
  } else if (param && param.userAgent) {
    nav = {
      userAgent: param.userAgent,
      platform: param.platform,
      maxTouchPoints: param.maxTouchPoints || 0
    };
  }
  let userAgent = nav.userAgent;
  let tmp = userAgent.split("[FBAN");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  tmp = userAgent.split("Twitter");
  if (typeof tmp[1] !== "undefined") {
    userAgent = tmp[0];
  }
  const match = createMatch(userAgent);
  const result = {
    apple: {
      phone: match(appleIphone) && !match(windowsPhone),
      ipod: match(appleIpod),
      tablet: !match(appleIphone) && (match(appleTablet) || isAppleTabletOnIos13(nav)) && !match(windowsPhone),
      universal: match(appleUniversal),
      device: (match(appleIphone) || match(appleIpod) || match(appleTablet) || match(appleUniversal) || isAppleTabletOnIos13(nav)) && !match(windowsPhone)
    },
    amazon: {
      phone: match(amazonPhone),
      tablet: !match(amazonPhone) && match(amazonTablet),
      device: match(amazonPhone) || match(amazonTablet)
    },
    android: {
      phone: !match(windowsPhone) && match(amazonPhone) || !match(windowsPhone) && match(androidPhone),
      tablet: !match(windowsPhone) && !match(amazonPhone) && !match(androidPhone) && (match(amazonTablet) || match(androidTablet)),
      device: !match(windowsPhone) && (match(amazonPhone) || match(amazonTablet) || match(androidPhone) || match(androidTablet)) || match(/\bokhttp\b/i)
    },
    windows: {
      phone: match(windowsPhone),
      tablet: match(windowsTablet),
      device: match(windowsPhone) || match(windowsTablet)
    },
    other: {
      blackberry: match(otherBlackBerry),
      blackberry10: match(otherBlackBerry10),
      opera: match(otherOpera),
      firefox: match(otherFirefox),
      chrome: match(otherChrome),
      device: match(otherBlackBerry) || match(otherBlackBerry10) || match(otherOpera) || match(otherFirefox) || match(otherChrome)
    },
    any: false,
    phone: false,
    tablet: false
  };
  result.any = result.apple.device || result.android.device || result.windows.device || result.other.device;
  result.phone = result.apple.phone || result.android.phone || result.windows.phone;
  result.tablet = result.apple.tablet || result.android.tablet || result.windows.tablet;
  return result;
}

// utils/platform.ts
var DENO = "DENO";
var CHROME = "CHROME";
var FIREFOX = "FIREFOX";
function isBrowser(toCheck) {
  let currentBrowser = CHROME;
  try {
    const userAgent = navigator?.userAgent || "";
    if (/firefox/i.test(userAgent)) {
      currentBrowser = FIREFOX;
    } else if (/deno/i.test(userAgent)) {
      currentBrowser = DENO;
    }
  } catch (_2) {
  }
  if (!toCheck)
    currentBrowser;
  if (toCheck === CHROME && currentBrowser === CHROME)
    return true;
  if (toCheck === FIREFOX && currentBrowser === FIREFOX)
    return true;
  if (toCheck === DENO && currentBrowser === DENO)
    return true;
  return false;
}
function isDeno2() {
  return typeof Deno !== "undefined";
}
function isFirefox() {
  return isBrowser(FIREFOX);
}
function isTouchDevice() {
  return !!navigator.maxTouchPoints || "ontouchstart" in document.documentElement;
}

// browser/mock_browser.ts
var listeners = {
  addListener: () => {
  },
  removeListener: () => {
  },
  hasListener: () => {
  }
};
var mock_browser_default = {
  permissions: {
    contains: () => {
    },
    request: () => {
    }
  },
  runtime: {
    onMessage: listeners,
    openOptionsPage: () => {
    },
    lastError: {
      message: ""
    }
  },
  storage: {
    sync: {
      get: () => {
      },
      set: () => {
      }
    }
  },
  tabs: {
    onUpdated: listeners,
    query: () => {
    },
    sendMessage: () => {
    }
  }
};

// browser/browser.ts
var browserAPI;
if (isDeno2()) {
  browserAPI = mock_browser_default;
} else {
  browserAPI = globalThis.immersiveTranslateBrowserAPI;
}

// buildin_config.json
var buildin_config_default = {
  minVersion: "0.0.20",
  immediateTranslationTextCount: 5e3,
  interval: 36e5,
  beta: false,
  cache: true,
  donateUrl: "https://immersive-translate.owenyoung.com/donate.html",
  feedbackUrl: "https://github.com/immersive-translate/immersive-translate/issues",
  isShowContextMenu: true,
  loadingTheme: "spinner",
  canary: false,
  translationServices: {
    volcAlpha: {
      placeholderDelimiters: ["{", "}"]
    },
    volc: {
      placeholderDelimiters: ["{", "}"]
    },
    tencent: {
      placeholderDelimiters: ["{", "}"]
    },
    transmart: {
      placeholderDelimiters: ["#", "#"]
    },
    baidu: {
      placeholderDelimiters: ["#", "#"]
    },
    caiyun: {
      placeholderDelimiters: ["{", "}"]
    },
    youdao: {
      placeholderDelimiters: ["\u{1F6A0}", "\u{1F6A0}"]
    },
    deepl: {},
    dpro: {
      apiUrl: "https://api.deepl.com/jsonrpc"
    }
  },
  shortcuts: {
    toggleTranslatePage: "Alt+A",
    toggleTranslateTheWholePage: "Alt+W",
    toggleTranslateToThePageEndImmediately: "Alt+S",
    toggleTranslationMask: "Alt+D"
  },
  tempTranslateDomainMinutes: 0,
  immediateTranslationPattern: {
    matches: [
      "www.tumblr.com",
      "twitter.com",
      "*.twitter.com",
      "medium.com",
      "*.medium.com",
      "github.com",
      "gist.github.com",
      "www.facebook.com",
      "www.youtube.com",
      "m.youtube.com",
      "mail.google.com",
      "discord.com",
      "web.telegram.org",
      "instagram.com",
      "*.slack.com",
      "https://old.reddit.com/",
      "https://www.reddit.com/r/popular/",
      "https://www.reddit.com/",
      "https://www.reddit.com/hot/",
      "https://www.reddit.com/new/",
      "https://www.reddit.com/top/",
      "https://www.reddit.com/.compact"
    ],
    excludeMatches: [],
    selectorMatches: [
      "meta[property='al:ios:url'][content^='medium://']"
    ],
    selectorExcludeMatches: []
  },
  translationParagraphLanguagePattern: {
    matches: [
      "www.reddit.com",
      "old.reddit.com",
      "twitter.com",
      "www.tumblr.com",
      "*.twitter.com",
      "medium.com",
      "*.medium.com",
      "github.com",
      "gist.github.com",
      "www.facebook.com",
      "www.youtube.com",
      "m.youtube.com",
      "read.readwise.io",
      "www.inoreader.com",
      "mail.google.com",
      "google.com",
      "discord.com",
      "instagram.com",
      "web.telegram.org",
      "*.slack.com"
    ],
    excludeMatches: [],
    selectorMatches: [
      "meta[property='al:ios:url'][content^='medium://']"
    ],
    selectorExcludeMatches: []
  },
  sourceLanguageUrlPattern: {},
  generalRule: {
    _comment: "",
    normalizeBody: "",
    injectedCss: [],
    additionalInjectedCss: [],
    languageDetectMinTextCount: 50,
    wrapperPrefix: "smart",
    wrapperSuffix: "smart",
    isPdf: false,
    isTransformPreTagNewLine: false,
    urlChangeDelay: 20,
    translationBlockStyle: "",
    isShowUserscriptPagePopup: true,
    observeUrlChange: false,
    paragraphMinTextCount: 8,
    paragraphMinWordCount: 2,
    shadowRootSelectors: [],
    blockMinTextCount: 32,
    blockMinWordCount: 5,
    containerMinTextCount: 18,
    lineBreakMaxTextCount: 0,
    globalAttributes: {},
    globalStyles: {
      ".sr-only": "display:none"
    },
    selectors: [],
    preWhitespaceDetectedTags: ["DIV", "SPAN"],
    stayOriginalSelectors: [],
    additionalSelectors: [
      "h1",
      "section h2",
      "section h3",
      "section h4",
      "main h2",
      "main h3",
      "main h4",
      ".article-title",
      ".article-subtitle",
      ".article_title",
      ".article_subtitle",
      ".article__title",
      ".articleTitle",
      ".Article__content",
      ".title",
      ".abstract",
      ".titleLink",
      ".summary",
      ".content",
      ".headline",
      ".page-content"
    ],
    atomicBlockTags: [],
    excludeSelectors: [],
    additionalExcludeSelectors: [
      ".social-share",
      ".breadcrumbs",
      ".post__footer",
      ".btn",
      ".reference-citations",
      ".share-nav",
      ".o-share",
      "[data-toolbar=share]",
      "rp",
      "rt"
    ],
    translationClasses: [],
    atomicBlockSelectors: [],
    excludeTags: [
      "TITLE",
      "SCRIPT",
      "STYLE",
      "TEXTAREA",
      "SVG",
      "svg",
      "NOSCRIPT",
      "INPUT",
      "BUTTON",
      "BASE",
      "SELECT",
      "OPTION",
      "IMG",
      "SUB",
      "SUP",
      "HR",
      "PRE",
      "CODE",
      "KBD",
      "WBR",
      "TT",
      "RT",
      "RP",
      "META",
      "ASIDE",
      "FOOTER",
      "MATH"
    ],
    bodyTranslateTags: [
      "FOOTER",
      "ADIDE",
      "BUTTON",
      "NAV"
    ],
    forceTranslateTags: [],
    metaTags: [
      "META",
      "SCRIPT",
      "STYLE",
      "NOSCRIPT"
    ],
    additionalExcludeTags: [],
    stayOriginalTags: ["CODE", "TT", "IMG", "SUP", "SUB"],
    additionalStayOriginalTags: [],
    inlineTags: [
      "A",
      "ABBR",
      "FONT",
      "ACRONYM",
      "B",
      "INS",
      "DEL",
      "RUBY",
      "RP",
      "RB",
      "BDO",
      "MARK",
      "BIG",
      "RT",
      "NOBR",
      "CITE",
      "DFN",
      "EM",
      "I",
      "LABEL",
      "Q",
      "S",
      "SMALL",
      "SPAN",
      "STRONG",
      "SUB",
      "SUP",
      "U",
      "KBD",
      "TT",
      "VAR",
      "IMG",
      "CODE",
      "SCRIPT",
      "STYLE",
      "LINK",
      "TIME",
      "META",
      "WBR"
    ],
    additionalInlineTags: [],
    extraInlineSelectors: [],
    additionalInlineSelectors: [],
    extraBlockSelectors: ["turbo-frame", "readme-toc"],
    allBlockTags: [
      "HGROUP",
      "CONTENT",
      "ADDRESS",
      "ARTICLE",
      "ASIDE",
      "BLOCKQUOTE",
      "CANVAS",
      "DD",
      "DL",
      "DT",
      "FIELDSET",
      "FIGCAPTION",
      "FIGURE",
      "FOOTER",
      "HEADER",
      "FORM",
      "HR",
      "MAIN",
      "SUMMARY",
      "NAV",
      "OL",
      "NOSCRIPT",
      "PRE",
      "SECTION",
      "TABLE",
      "TFOOT",
      "UL",
      "VIDEO",
      "P",
      "DIV",
      "H1",
      "H2",
      "H3",
      "H4",
      "H5",
      "H6",
      "UL",
      "LI",
      "OL",
      "BR",
      "PICTURE",
      "TBODY",
      "TR",
      "TD",
      "TH",
      "SOURCE",
      "C-WIZ",
      "BUTTON",
      "TURBO-FRAME",
      "README-TOC"
    ],
    pdfNewParagraphLineHeight: 2.4,
    pdfNewParagraphIndent: 1.2,
    pdfNewParagraphIndentRightIndentPx: 130,
    fingerCountToToggleTranslagePageWhenTouching: 4,
    fingerCountToToggleTranslationMaskWhenTouching: 0
  },
  rules: [
    {
      matches: [
        "moz-extension://*/pdf/index.html*"
      ],
      isPdf: true,
      wrapperPrefix: "",
      wrapperSuffix: "",
      urlChangeDelay: 0,
      selectors: [".textLayer"],
      excludeSelectors: [".annotationLayer"],
      globalStyles: {
        "div.page": "width: 98%;",
        ".textLayer": "overflow:visible;opacity: 1;"
      }
    },
    {
      matches: ["mail.jabber.org", "antirez.com"],
      excludeTags: [
        "TITLE",
        "SCRIPT",
        "STYLE",
        "TEXTAREA",
        "SVG",
        "svg",
        "INPUT",
        "LABEL",
        "IMG",
        "SUB",
        "SUP",
        "BR",
        "CODE",
        "KBD",
        "WBR",
        "TT"
      ]
    },
    {
      matches: "*.wikipedia.org",
      excludeSelectors: [
        ".mw-editsection",
        ".mw-cite-backlink",
        "#mw-panel-toc"
      ],
      stayOriginalSelectors: [
        ".chemf",
        ".mwe-math-element",
        "[role=math]",
        ".nowrap"
      ],
      extraInlineSelectors: [
        ".chemf",
        ".mwe-math-element",
        "[role=math]",
        ".nowrap"
      ]
    },
    {
      matches: [
        "twitter.com",
        "mobile.twitter.com",
        "tweetdeck.twitter.com",
        "https://platform.twitter.com/embed*"
      ],
      selectors: [
        '[data-testid="tweetText"]',
        ".tweet-text",
        ".js-quoted-tweet-text",
        "[data-testid='card.layoutSmall.detail'] > div:nth-child(2)",
        "[data-testid='developerBuiltCardContainer'] > div:nth-child(2)",
        "[data-testid='card.layoutLarge.detail'] > div:nth-child(2)"
      ],
      observeUrlChange: false,
      extraInlineSelectors: ['[data-testid="tweetText"] div']
    },
    {
      matches: [
        "stackoverflow.com",
        "*.stackexchange.com",
        "superuser.com",
        "askubuntu.com",
        "serverfault.com"
      ],
      extraBlockSelectors: ["span.comment-copy"],
      excludeSelectors: [
        "a.comment-user",
        "span.comment-date",
        "div.s-prose.js-post-body + div",
        ".bottom-notice",
        "div[data-campaign-name=stk]"
      ]
    },
    {
      matches: "developer.apple.com/documentation/*",
      selectors: [".container", "h3.title"]
    },
    {
      matches: "news.ycombinator.com",
      selectors: [
        ".titleline > a",
        ".comment > .commtext",
        ".toptext",
        "a.hn-item-title",
        ".hn-comment-text",
        ".hn-story-title"
      ],
      excludeSelectors: [".reply"]
    },
    {
      matches: ["*.quora.com", "quora.com"],
      additionalSelectors: [
        ".puppeteer_test_question_title",
        ".puppeteer_test_answer_content",
        ".q-text"
      ],
      globalStyles: {
        ".qu-truncateLines--3": "-webkit-line-clamp: unset;"
      }
    },
    {
      matches: [
        "old.reddit.com/*/.compact",
        "old.reddit.com/.compact",
        "www.reddit.com/*/.compact",
        "www.reddit.com/.compact"
      ],
      selectors: [".title > a", ".usertext-body"],
      detectParagraphLanguage: true
    },
    {
      matches: "old.reddit.com",
      selectors: ["p.title > a", "[role=main] .md-container"],
      detectParagraphLanguage: true
    },
    {
      matches: "www.reddit.com",
      selectors: [
        "h1",
        ".PostHeader__post-title-line",
        "[data-click-id=body] h3",
        "[data-click-id=background] h3",
        "[data-testid=comment]",
        "[data-adclicklocation='title']",
        "[data-adclicklocation=media]",
        ".PostContent",
        ".post-content",
        ".Comment__body",
        "faceplate-batch .md"
      ],
      detectParagraphLanguage: true,
      globalStyles: {
        "div.XPromoBottomBar": "display:none"
      }
    },
    {
      matches: "www.reuters.com/",
      excludeSelectors: ["header"]
    },
    {
      matches: "github.com",
      selectors: [
        ".markdown-title",
        ".markdown-body",
        ".Layout-sidebar p",
        "div > span.search-match",
        "li.repo-list-item p",
        "#responsive-meta-container p"
      ],
      excludeSelectors: [
        ".css-truncate",
        "[data-test-selector='commit-tease-commit-message']",
        "div.blob-wrapper-embedded",
        "div.Box.Box--condensed.my-2"
      ],
      extraBlockSelectors: [],
      extraInlineSelectors: [
        "g-emoji"
      ],
      stayOriginalTags: ["CODE", "TT", "G-EMOJI", "IMG", "SUP", "SUB"],
      detectParagraphLanguage: true
    },
    {
      matches: "www.facebook.com",
      selectors: [
        "div[dir=auto][style]",
        "div[dir=auto][class]",
        "span[lang]"
      ],
      atomicBlockSelectors: [
        "div[dir=auto][style]",
        "div[dir=auto][class]",
        "span[lang]"
      ],
      insertPosition: "afterend",
      preWhitespaceDetectedTags: ["DIV", "SPAN"],
      extraBlockSelectors: ["span.x1vvkbs"],
      excludeSelectors: ["[role=button]"],
      translationClasses: [
        "immersive-translate-text"
      ],
      detectParagraphLanguage: true
    },
    {
      matches: "m.youtube.com",
      selectors: [
        ".comment-text"
      ],
      observeUrlChange: true,
      atomicBlockSelectors: [
        ".comment-text"
      ],
      globalStyles: {
        ".comment-text": "max-height:unset;"
      },
      injectedCss: [
        ".immersive-translate-target-wrapper img { width: 16px; height: 16px }"
      ]
    },
    {
      matches: "www.youtube.com",
      observeUrlChange: true,
      selectors: [
        "yt-formatted-string[slot=content].ytd-comment-renderer",
        "yt-formatted-string.ytd-video-renderer",
        "h1 > yt-formatted-string.ytd-watch-metadata",
        "yt-formatted-string#video-title",
        "span#video-title",
        "a#video-title",
        "yt-formatted-string.ytd-transcript-segment-renderer"
      ],
      wrapperPrefix: "",
      wrapperSuffix: "",
      globalStyles: {
        "ytd-expander.ytd-comment-renderer": "--ytd-expander-max-lines: 1000;",
        "h1.ytd-watch-metadata": "-webkit-line-clamp: unset;max-height: unset;",
        "yt-formatted-string#video-title": "-webkit-line-clamp: unset;max-height: unset;",
        "#video-title": "-webkit-line-clamp: unset;max-height: unset;"
      },
      urlChangeDelay: 2e3,
      atomicBlockSelectors: [
        "yt-formatted-string[slot=content].ytd-comment-renderer",
        "h1 > yt-formatted-string.ytd-watch-metadata",
        "yt-formatted-string#video-title",
        "span#video-title"
      ],
      excludeSelectors: [
        "[class^='lln-']"
      ],
      extraBlockSelectors: [
        "yt-formatted-string.ytd-transcript-segment-renderer"
      ],
      detectParagraphLanguage: true,
      injectedCss: [
        ".immersive-translate-target-wrapper img { width: 16px; height: 16px }"
      ]
    },
    {
      matches: "https://www.instagram.com/*",
      globalStyles: {
        "._ab05": "min-height:150px"
      },
      wrapperPrefix: "",
      wrapperSuffix: "",
      selectors: [
        "div._aa_c h1",
        "div._a9zs h1",
        "div._a9zr > div._a9zs > span",
        "div._ab5z._ab5_",
        'div._ac72 div[role="button"] > div:last-child',
        'li._acaz div[role="menuitem"]'
      ],
      atomicBlockSelectors: [
        "div._aa_c h1",
        'li._acaz div[role="menuitem"]'
      ]
    },
    {
      matches: "1paragraph.app",
      selectors: "#book"
    },
    {
      matches: "https://poeditor.com/projects/*",
      selectors: [
        ".comment-body",
        ".reference_language .source-string"
      ]
    },
    {
      matches: ["*.substack.com", "newsletter.rootsofprogress.org"],
      selectors: [
        ".post-preview-title",
        ".post-preview-description",
        ".post",
        ".comment-body"
      ],
      excludeSelectors: [
        ".captioned-button-wrap",
        ".subscription-widget-wrap",
        ".tweet-header",
        ".tweet-link-bottom",
        ".expanded-link",
        ".meta-subheader"
      ],
      extraBlockSelectors: [
        ".tweet-link-top",
        ".tweet-link-bottom",
        ".expanded-link"
      ]
    },
    {
      matches: ["seekingalpha.com/article/*", "seekingalpha.com/news/*"],
      selectors: ["[data-test-id=card-container]"],
      excludeSelectors: [
        "[data-test-id=post-page-meta]",
        "header > div:first-child"
      ]
    },
    {
      matches: "hn.algolia.com",
      selectors: [".Story_title > a:first-child", ".Story_comment > span"]
    },
    {
      matches: "read.readwise.io",
      selectors: [
        'div[class^="_titleRow_"]',
        'div[class^="_description_"]',
        "#document-text-content"
      ],
      detectParagraphLanguage: true
    },
    {
      matches: ["www.inoreader.com", "*.inoreader.com"],
      selectors: [
        ".article_header_title",
        ".article_title_link",
        ".article_content",
        ".article_magazine_title_link"
      ],
      observeUrlChange: false,
      globalStyles: {
        ".article_title_link": "-webkit-line-clamp: unset;max-height: unset;"
      }
    },
    {
      matches: ["scholar.google.com"],
      wrapperPrefix: "\n",
      selectors: ["h3 a[data-clk]", "div.gs_rs"],
      atomicBlockSelectors: [".gs_rs", "h3 a[data-clk]"]
    },
    {
      matches: "mail.google.com",
      selectors: [
        "h2[data-thread-perm-id]",
        "span[data-thread-id]",
        "div[data-message-id] div[class='']"
      ],
      detectParagraphLanguage: true
    },
    {
      matches: "www.producthunt.com",
      excludeMatches: "https://www.producthunt.com/stories/*",
      selectors: [
        "h2",
        "div[class^='styles_htmlText__']",
        "[class^='styles_tagline']",
        "a[href^='/discussions/'].fontWeight-600",
        "button[class^='styles_textButton'] > div > span",
        "h5 + p"
      ],
      globalStyles: {
        "h5 + p": "height:unset;"
      },
      excludeTags: [
        "TITLE",
        "SCRIPT",
        "STYLE",
        "TEXTAREA",
        "SVG",
        "svg",
        "INPUT",
        "LABEL",
        "IMG",
        "SUB",
        "SUP",
        "BR",
        "CODE",
        "KBD",
        "WBR",
        "TT"
      ]
    },
    {
      matches: "*.gitbook.io",
      additionalSelectors: ["main"],
      _comment: "https://midjourney.gitbook.io/docs/user-manual"
    },
    {
      matches: "arxiv.org",
      additionalSelectors: ["h1", "blockquote.abstract"]
    },
    {
      matches: "https://discord.com/channels/*",
      selectors: [
        "li[id^=chat-messages] div[id^=message-content]",
        "h3[data-text-variant='heading-lg/semibold']",
        "section[aria-label='Search Results'] div[id^=message-content]"
      ],
      excludeSelectors: [
        "div[class^='repliedTextContent']"
      ],
      globalStyles: {
        "div[class^=headerText]": "max-height: unset;",
        "h3[data-text-variant='heading-lg/semibold']": "-webkit-line-clamp: none;"
      },
      detectParagraphLanguage: true,
      wrapperPrefix: "<br />",
      wrapperSuffix: ""
    },
    {
      matches: "web.telegram.org/z/*",
      selectors: [".text-content"],
      detectParagraphLanguage: true
    },
    {
      matches: ["web.telegram.org/k/*", "web.telegram.org/k/"],
      selectors: [".message"],
      detectParagraphLanguage: true
    },
    {
      matches: "gist.github.com",
      selectors: [".markdown-body", ".readme"],
      detectParagraphLanguage: true
    },
    {
      matches: "lobste.rs",
      selectors: [".u-repost-of", ".comment_text"]
    },
    {
      matches: "*.slack.com",
      selectors: [".p-rich_text_block"],
      detectParagraphLanguage: true
    },
    {
      matches: "1paragraph.app",
      additionalSelectors: ["#book"]
    },
    {
      matches: "www.google.*/search*",
      detectParagraphLanguage: true,
      excludeSelectors: ["a h3 + div", "div#sfooter"],
      wrapperSuffix: "",
      globalStyles: {
        "div[data-content-feature='1'] > div": "-webkit-line-clamp: unset;max-height: unset;",
        "div[style='-webkit-line-clamp:2']": "-webkit-line-clamp: unset;max-height: unset;"
      },
      extraBlockSelectors: [
        ".MUFPAc"
      ]
    },
    {
      matches: "lowendtalk.com",
      selectors: ["[role=heading]", "h1", ".userContent"]
    },
    {
      matches: "www.linkedin.com/jobs/*",
      selectors: ["#job-details > span"]
    },
    {
      matches: "www.linkedin.com",
      addtionalSelectors: ["span.break-words > span > span[dir=ltr]"]
    },
    {
      matches: "www.indiehackers.com",
      selectors: [".content", "h1", ".feed-item__title-link"]
    },
    {
      matches: "libreddit.de",
      selectors: ["h2.post_title", ".comment_body > .md"]
    },
    {
      matches: ["notion.site", "www.notion.so"],
      selectors: ["div[data-block-id]"]
    },
    {
      matches: "www.newyorker.com",
      additionalSelectors: ["h1", "[data-testid=SummaryItemHed]"]
    },
    {
      matches: "start.me",
      selectors: [
        ".rss-article__title",
        ".rss-articles-list__article-link",
        ".rss-showcase__title",
        ".rss-showcase__text"
      ]
    },
    {
      matches: "www.scmp.com",
      additionalSelectors: [".info__subHeadline", ".section-content h2"]
    },
    {
      matches: "www.lesswrong.com",
      extraBlockSelectors: ["span.commentOnSelection"]
    },
    {
      matches: [
        "mastodon.social",
        "mastodon.online",
        "kolektiva.social",
        "indieweb.social",
        "mastodon.world",
        "infosec.exchange"
      ],
      selectorMatches: ["div#mastodon"],
      selectors: ["div.status__content__text"],
      detectLanguage: true
    },
    {
      matches: "www.cnbc.com",
      additionalSelectors: ["div.RenderKeyPoints-list"]
    },
    {
      matches: "app.daily.dev",
      selectors: [
        "h1",
        ".typo-body",
        "article h3",
        "[class^=markdown_markdown]"
      ],
      globalStyles: {
        ".line-clamp-3": "-webkit-line-clamp: unset"
      }
    },
    {
      matches: "www.aljazeera.com",
      addtionalSelectors: ["h1", ".article__subhead"]
    },
    {
      matches: ["*.pornhub.com", "pornhub.com"],
      selectors: [
        ".title >a",
        ".title > span",
        ".thumbnailTitle",
        ".commentMessage > span"
      ],
      detectParagraphLanguage: true,
      wrapperPrefix: "\n\n",
      wrapperSuffix: "\n",
      globalStyles: {
        ".title": "height: unset; max-height: unset;"
      }
    },
    {
      matches: ["weibo.com"],
      selectors: ["div[class^='detail_wbtext']"]
    },
    {
      matches: ["medium.com", "*.medium.com"],
      selectorMatches: [
        "meta[property='al:ios:url'][content^='medium://']"
      ],
      urlChangeDelay: 2e3,
      selectors: [
        "article section",
        "h2",
        "[aria-hidden='false'] pre",
        "article p"
      ],
      excludeSelectors: ["[aria-label='Post Preview Reading Time']"],
      globalStyles: {
        h2: "-webkit-line-clamp: unset;max-height:unset;",
        "article p": "-webkit-line-clamp: unset;max-height:unset;"
      }
    },
    {
      selectorMatches: [
        "meta[property='og:site_name'][content='Nitter']"
      ],
      selectors: [".tweet-content", ".quote-text"]
    },
    {
      matches: "*.fandom.com",
      additionalSelectors: [".mcf-card-article__title"]
    },
    {
      matches: ["www.washingtonpost.com"],
      additionalSelectors: ["[data-qa='article-body']"]
    },
    {
      matches: "www.economist.com",
      extraInlineSelectors: "span[data-caps='initial']"
    },
    {
      matches: "www.healthline.com",
      excludeSelectors: ".icon-hl-trusted-source-after"
    },
    {
      matches: "www.amazon.com",
      selectors: [
        "h1",
        "h2 > a > span",
        "[data-a-expander-name='book_description_expander'] > div",
        "[data-feature-name='editorialReviews']",
        '[data-a-expander-name="review_text_read_more"] > div > span',
        '[data-feature-name="featurebullets"]',
        '[data-feature-name="aplus"'
      ],
      excludeBlockSelectors: [
        "div.reviewText > span"
      ],
      globalStyles: {
        ".s-line-clamp-2": "-webkit-line-clamp: unset;max-height: unset;",
        "[data-a-expander-name='review_text_read_more']": " max-height: unset;"
      }
    },
    {
      matches: "www.bloomberg.com",
      urlChangeDelay: 2e3
    },
    {
      matches: "xueshu.baidu.com",
      globalStyles: {
        ".abstract_wr": "height: unset; overflow: visible; max-height:unset;"
      }
    },
    {
      matches: "www.sciencedirect.com",
      urlChangeDelay: 2e3,
      stayOriginalSelectors: ["span.display"]
    },
    {
      matches: "www.thehighestofthemountains.com",
      extraBlockSelectors: "div"
    },
    {
      matches: "telegra.ph",
      normalizeBody: "div.ql-editor[contenteditable='false']"
    },
    {
      matches: ["*.annas-archive.org", "annas-archive.org"],
      selectors: [
        "h3.text-xl.font-bold",
        "div[class='truncate text-sm']"
      ],
      globalStyles: {
        "div[id^='link-index-']": "height: unset; max-height: unset;"
      },
      normalizeBody: "body",
      extraBlockSelectors: ["a.custom-a"]
    },
    {
      matches: [
        "explainshell.com"
      ],
      selectors: [
        "[class='help-box']"
      ]
    },
    {
      matches: ["apnews.com"],
      urlChangeDelay: 2e3
    },
    {
      matches: "play.google.com",
      additionalSelectors: ["header[data-review-id] + div"]
    },
    {
      matches: ["www.tumblr.com"],
      selectors: [
        "article h1",
        "article > header + div",
        "[data-testid=notes-root] p",
        "div.k31gt",
        "p",
        "article ul",
        "article h2",
        "article h3",
        "article h4",
        "article h5",
        "article h6",
        "article blockquote",
        "article ol"
      ],
      excludeSelectors: ["div.fAAi8", "div.wvu3V"],
      preWhitespaceDetectedTags: ["DIV", "SPAN", "P"]
    },
    {
      matches: ["mail.qq.com/cgi-bin/frame_html"],
      selectors: ["#thisiddoesnotexists"]
    },
    {
      matches: "www.foxnews.com",
      shadowRootSelectors: [
        "[data-spot-im-module-default-area='conversation'] > div"
      ],
      excludeSelectors: [
        ".components-MessageDetails-index__message-details-wrapper",
        "div[class^=SlideDown__container]",
        ".components-MessageActions-index__messageActionsWrapper",
        "span[data-openweb-allow-amp]",
        "div.spcv_typing-users"
      ]
    },
    {
      matches: "www.afreecatv.com",
      globalStyles: {
        "a.title": "max-height:unset;-webkit-line-clamp:unset;"
      }
    },
    {
      matches: "opennet.ru",
      excludeTags: [
        "TITLE",
        "SCRIPT",
        "STYLE",
        "TEXTAREA",
        "SVG",
        "svg",
        "NOSCRIPT",
        "INPUT",
        "BUTTON",
        "BASE",
        "LABEL",
        "SELECT",
        "OPTION",
        "IMG",
        "SUB",
        "SUP",
        "HR",
        "PRE",
        "CODE",
        "KBD",
        "WBR",
        "TT",
        "RT",
        "RP",
        "META"
      ]
    },
    {
      matches: "getpocket.com",
      selectors: ["h2.title", "div.excerpt p", "main > article"],
      globalStyles: {
        "h2.title": "max-height:unset;-webkit-line-clamp:unset;",
        "div.excerpt p": "max-height:unset;-webkit-line-clamp:unset;"
      }
    },
    {
      matches: "huggingface.co",
      globalStyles: {
        ".line-clamp-2": "-webkit-line-clamp:unset;max-height:unset;"
      }
    },
    {
      matches: "www.statista.com",
      globalStyles: {
        ".itemContent__text": "height:unset;max-height:unset;",
        ".itemContent__subline": "height:unset;max-height:unset;"
      }
    },
    {
      matches: "epub-reader.online",
      globalStyles: {
        "span.slide-contents-item-label": "overflow:visible;max-height:unset;white-space:normal;"
      },
      atomicBlockSelectors: "div.slide-contents-item"
    },
    {
      matches: "https://you.com/search",
      globalStyles: {
        h3: "max-height:unset;-webkit-line-clamp:unset;",
        ".caKYaC": "max-height:unset;-webkit-line-clamp:unset;",
        ".dDwDsu": "max-height:unset;-webkit-line-clamp:unset;"
      },
      excludeSelectors: "div.hpIWZO"
    },
    {
      matches: "chat.openai.com",
      excludeSelectors: [
        "div.absolute.bottom-0.left-0.w-full",
        "h1",
        "div#headlessui-portal-root"
      ]
    },
    {
      matches: "glasp.co",
      excludeSelectors: [
        ".home_overview_list_content_wrapper"
      ]
    },
    {
      matches: "developer.chrome.com",
      excludeSelectors: ["web-tabs", "ul.code-sections--summary"]
    },
    {
      matches: "https://rarbg.to/*",
      wrapperPrefix: "",
      wrapperSuffix: "",
      globalStyles: {
        ".lista2 h2": "line-height: 14px;"
      },
      selectors: [
        "#news_content",
        "#top_news > table > tbody > tr > td:nth-child(1) > table > tbody > tr > td > table > tbody > tr > td",
        "#top_news > table > tbody > tr > td > table > tbody > tr > td > h2",
        "body > table > tbody > tr > td > div > table > tbody > tr > td > b",
        "#newsRight > table> tbody > tr > td:nth-child(2) > table > tbody > tr:nth-child(2) > td",
        "#newsRight > table > tbody > tr > td:nth-child(2) > table > tbody > tr > td > span > b"
      ]
    },
    {
      matches: ["developer.android.google.cn", "developer.android.com"],
      additionalSelectors: ["aside.note"]
    }
  ]
};

// utils/array.ts
function arrayOrGenericToArray(arrayOrGeneric) {
  if (Array.isArray(arrayOrGeneric)) {
    return arrayOrGeneric;
  } else if (arrayOrGeneric) {
    return [arrayOrGeneric];
  } else {
    return [];
  }
}
function addToUniqueArray(item, array) {
  if (!array) {
    return [item];
  }
  if (!Array.isArray(array)) {
    array = [array];
  }
  return Array.from(/* @__PURE__ */ new Set([...array, item]));
}
function removeFromArray(item, array) {
  if (!array) {
    return [];
  }
  if (!Array.isArray(item)) {
    item = [item];
  }
  if (!Array.isArray(array)) {
    array = [array];
  }
  return array.filter((i2) => !item.includes(i2));
}

// utils/merge_rule.ts
function mergeRule(generalRule, rule) {
  const arrayKeys = [];
  const allRuleKeys = Object.keys(
    generalRule
  );
  for (const key of allRuleKeys) {
    const value = generalRule[key];
    if (Array.isArray(value)) {
      arrayKeys.push(key);
    }
  }
  const finalRule = {
    ...generalRule
  };
  const ruleKeys = Object.keys(rule);
  ruleKeys.forEach((key) => {
    const value = rule[key];
    if (value !== void 0) {
      if (!arrayKeys.includes(key)) {
        finalRule[key] = value;
      } else {
        if (key.startsWith("additional")) {
          const userValue = arrayOrGenericToArray(value);
          finalRule[key] = Array.from(
            // @ts-ignore: ignore type error
            /* @__PURE__ */ new Set([...finalRule[key], ...userValue])
          );
        } else {
          finalRule[key] = arrayOrGenericToArray(value);
        }
      }
    }
  });
  return finalRule;
}

// config.ts
function getEnvUserConfig() {
  if (env.PROD === "1") {
    return {};
  }
  const defaultUserConfig = {};
  if (env.IMMERSIVE_TRANSLATE_SECRET_TENCENT_SECRET_ID && env.IMMERSIVE_TRANSLATE_SECRET_TENCENT_SECRET_KEY) {
    const tencentAuthConfig = {
      secretId: env.IMMERSIVE_TRANSLATE_SECRET_TENCENT_SECRET_ID,
      secretKey: env.IMMERSIVE_TRANSLATE_SECRET_TENCENT_SECRET_KEY
    };
    defaultUserConfig.translationServices = {};
    defaultUserConfig.translationServices.tencent = tencentAuthConfig;
  }
  if (env.IMMERSIVE_TRANSLATE_SECRET_BAIDU_APPID && env.IMMERSIVE_TRANSLATE_SECRET_BAIDU_KEY) {
    const baiduAuthConfig = {
      appid: env.IMMERSIVE_TRANSLATE_SECRET_BAIDU_APPID,
      key: env.IMMERSIVE_TRANSLATE_SECRET_BAIDU_KEY
    };
    if (!defaultUserConfig.translationServices) {
      defaultUserConfig.translationServices = {};
    }
    defaultUserConfig.translationServices.baidu = baiduAuthConfig;
  }
  if (env.IMMERSIVE_TRANSLATE_SECRET_CAIYUN_TOKEN) {
    const caiyunAuthConfig = {
      token: env.IMMERSIVE_TRANSLATE_SECRET_CAIYUN_TOKEN
    };
    if (!defaultUserConfig.translationServices) {
      defaultUserConfig.translationServices = {};
    }
    defaultUserConfig.translationServices.caiyun = caiyunAuthConfig;
  }
  if (env.IMMERSIVE_TRANSLATE_SECRET_OPENL_APIKEY) {
    const openlAuthConfig = {
      apikey: env.IMMERSIVE_TRANSLATE_SECRET_OPENL_APIKEY
    };
    if (!defaultUserConfig.translationServices) {
      defaultUserConfig.translationServices = {};
    }
    defaultUserConfig.translationServices.openl = openlAuthConfig;
  }
  if (env.IMMERSIVE_TRANSLATE_SECRET_YOUDAO_APP_ID && env.IMMERSIVE_TRANSLATE_SECRET_YOUDAO_APP_SECRET) {
    const youdaoAuthConfig = {
      appId: env.IMMERSIVE_TRANSLATE_SECRET_YOUDAO_APP_ID,
      appSecret: env.IMMERSIVE_TRANSLATE_SECRET_YOUDAO_APP_SECRET
    };
    if (!defaultUserConfig.translationServices) {
      defaultUserConfig.translationServices = {};
    }
    defaultUserConfig.translationServices.youdao = youdaoAuthConfig;
  }
  if (env.IMMERSIVE_TRANSLATE_SECRET_VOLC_ACCESS_KEY_ID && env.IMMERSIVE_TRANSLATE_SECRET_VOLC_SECRET_ACCESS_KEY) {
    const volcAuthConfig = {
      accessKeyId: env.IMMERSIVE_TRANSLATE_SECRET_VOLC_ACCESS_KEY_ID,
      secretAccessKey: env.IMMERSIVE_TRANSLATE_SECRET_VOLC_SECRET_ACCESS_KEY
    };
    if (!defaultUserConfig.translationServices) {
      defaultUserConfig.translationServices = {};
    }
    defaultUserConfig.translationServices.volc = volcAuthConfig;
  }
  if (env.IMMERSIVE_TRANSLATE_SECRET_DEEPL_AUTH_KEY) {
    const deeplAuthConfig = {
      authKey: env.IMMERSIVE_TRANSLATE_SECRET_DEEPL_AUTH_KEY
    };
    if (!defaultUserConfig.translationServices) {
      defaultUserConfig.translationServices = {};
    }
    defaultUserConfig.translationServices.deepl = deeplAuthConfig;
  }
  if (env.IMMERSIVE_TRANSLATE_SERVICE) {
    defaultUserConfig.translationService = env.IMMERSIVE_TRANSLATE_SERVICE;
  }
  if (env.DEEPL_PROXY_ENDPOINT) {
    if (!defaultUserConfig.translationServices) {
      defaultUserConfig.translationServices = {};
    }
    if (!defaultUserConfig.translationServices.deepl) {
      defaultUserConfig.translationServices.deepl = {};
    }
    defaultUserConfig.translationServices.deepl.immersiveTranslateApiUrl = env.DEEPL_PROXY_ENDPOINT;
  }
  if (env.DEBUG === "1") {
    defaultUserConfig.debug = true;
    defaultUserConfig.cache = false;
    defaultUserConfig.alpha = true;
  }
  if (env.MOCK === "1") {
    defaultUserConfig.translationService = "mock";
  }
  return defaultUserConfig;
}
async function getLocalConfig() {
  const localConfig2 = await browserAPI.storage.local.get(localConfigStorageKey);
  if (localConfig2[localConfigStorageKey]) {
    const currentConfig = localConfig2[localConfigStorageKey];
    let currentTempTranslationDomains = currentConfig.tempTranslationUrlMatches || [];
    const newDomains = currentTempTranslationDomains.filter(
      (item) => item.expiredAt > Date.now()
    );
    let isChanged = false;
    if (newDomains.length !== currentTempTranslationDomains.length) {
      currentTempTranslationDomains = newDomains;
      isChanged = true;
    }
    const newLocalConfig = {
      ...currentConfig,
      tempTranslationUrlMatches: [
        ...currentTempTranslationDomains
      ]
    };
    if (isChanged) {
      await setLocalConfig(newLocalConfig);
    }
    return newLocalConfig;
  } else {
    return {};
  }
}
async function setLocalConfig(localConfig2) {
  await browserAPI.storage.local.set({ [localConfigStorageKey]: localConfig2 });
}
async function setBuildinConfig(buildinConfig) {
  await browserAPI.storage.local.set({ [buildinConfigStorageKey]: buildinConfig });
}
async function getConfig() {
  const storageBuildInConfig = await browserAPI.storage.local.get(
    buildinConfigStorageKey
  );
  let finalBuildInConfig = {
    ...buildin_config_default,
    buildinConfigUpdatedAt: env.BUILD_TIME
  };
  if (storageBuildInConfig[buildinConfigStorageKey]) {
    const storageBuildInConfigValue = storageBuildInConfig[buildinConfigStorageKey];
    if (storageBuildInConfigValue && storageBuildInConfigValue.buildinConfigUpdatedAt) {
      const storageBuildinConfigUpdatedAt = new Date(
        storageBuildInConfigValue.buildinConfigUpdatedAt
      );
      const buildinConfigUpdatedAt = new Date(
        finalBuildInConfig.buildinConfigUpdatedAt
      );
      if (storageBuildinConfigUpdatedAt > buildinConfigUpdatedAt) {
        finalBuildInConfig = storageBuildInConfigValue;
      }
    }
  }
  const shortcutsFromBrowser = {};
  if (!isMonkey() && browserAPI.commands && browserAPI.commands.getAll) {
    const commandResult = await browserAPI.commands.getAll();
    for (const command of commandResult) {
      if (command.name && command.shortcut) {
        shortcutsFromBrowser[command.name] = command.shortcut;
      }
    }
  }
  const defaultConfig = getBuildInConfig();
  const envUserConfig = getEnvUserConfig();
  const userConfig = await getUserConfig();
  const globalUserConfig = globalThis.IMMERSIVE_TRANSLATE_CONFIG || {};
  const localConfig2 = await getLocalConfig();
  const now = /* @__PURE__ */ new Date();
  if (localConfig2 && localConfig2.tempTranslationUrlMatches && localConfig2.tempTranslationUrlMatches.length > 0) {
    const validUrlMatches = localConfig2.tempTranslationUrlMatches.filter(
      (urlMatch) => {
        const expiredAt = new Date(urlMatch.expiredAt);
        return expiredAt > now;
      }
    );
    if (validUrlMatches.length > 0) {
      const currentMatches = userConfig.translationUrlPattern ? userConfig.translationUrlPattern?.matches || [] : [];
      const currentMatchesArray = Array.isArray(currentMatches) ? currentMatches : [currentMatches];
      const finalMatches = Array.from(
        new Set(
          currentMatchesArray.concat(
            validUrlMatches.map((urlMatch) => urlMatch.match)
          )
        )
      );
      userConfig.translationUrlPattern = {
        ...userConfig.translationUrlPattern,
        matches: finalMatches
      };
    }
  }
  const mergedUserConfig = Object.assign(
    {},
    globalUserConfig,
    envUserConfig,
    userConfig
  );
  if (!mergedUserConfig.interfaceLanguage) {
    const defaultInterfaceLanguage = await getBrowserIntefaceLanguage();
    mergedUserConfig.interfaceLanguage = defaultInterfaceLanguage;
  }
  const finalConfig = Object.assign(defaultConfig, finalBuildInConfig);
  const configKeys = Object.keys(finalConfig);
  const assignKeys = [
    "translationUrlPattern",
    "translationLanguagePattern",
    "immediateTranslationPattern",
    "translationBodyAreaPattern",
    "translationParagraphLanguagePattern",
    "translationThemePatterns",
    "translationGeneralConfig",
    "shortcuts"
  ];
  for (const key of configKeys) {
    const configKey = key;
    if (configKey === "generalRule") {
      if (typeof mergedUserConfig[configKey] === "object") {
        finalConfig[configKey] = mergeRule(
          defaultConfig[configKey],
          mergedUserConfig[configKey]
        );
      }
    } else if (configKey === "translationServices") {
      const userConfigValue = mergedUserConfig[configKey] || {};
      const buildInConfigValue = finalBuildInConfig[configKey] || {};
      const buildInConfigKeys = Object.keys(buildInConfigValue);
      const userConfigKeys = Object.keys(userConfigValue);
      const allUniqueKeys = [
        .../* @__PURE__ */ new Set([...buildInConfigKeys, ...userConfigKeys])
      ];
      const finalConfigValue = {};
      for (const key2 of allUniqueKeys) {
        finalConfigValue[key2] = {
          // @ts-ignore: it's ok
          ...buildInConfigValue[key2],
          ...userConfigValue[key2]
        };
      }
      finalConfig[configKey] = finalConfigValue;
    } else if (typeof mergedUserConfig[configKey] !== "string" && typeof mergedUserConfig[configKey] !== "boolean" && typeof mergedUserConfig[configKey] !== "number" && assignKeys.includes(configKey)) {
      if (mergedUserConfig[configKey]) {
        finalConfig[configKey] = Object.assign(
          // @ts-ignore: ignore type error
          finalConfig[configKey],
          mergedUserConfig[configKey]
        );
      }
      if (configKey === "shortcuts") {
        finalConfig[configKey] = {
          ...finalConfig[configKey],
          ...shortcutsFromBrowser
        };
      }
    } else if (configKey === "rules") {
      if (Array.isArray(mergedUserConfig[configKey])) {
        finalConfig[configKey] = [
          ...mergedUserConfig[configKey],
          ...finalConfig[configKey]
        ];
      }
      if (env.PROD === "0") {
        if (env.DEV_RULES) {
          const devRules = JSON.parse(env.DEV_RULES);
          finalConfig[configKey] = [
            ...devRules,
            ...finalConfig[configKey]
          ];
        }
      }
    } else {
      if (mergedUserConfig[configKey] !== void 0) {
        finalConfig[configKey] = mergedUserConfig[configKey];
      }
    }
  }
  finalConfig.donateUrl = finalBuildInConfig.donateUrl;
  finalConfig.minVersion = finalBuildInConfig.minVersion;
  finalConfig.feedbackUrl = finalBuildInConfig.feedbackUrl;
  return finalConfig;
}
async function getUserConfig() {
  const userConfigObject = await browserAPI.storage.sync.get("userConfig") || {};
  const userConfig = userConfigObject.userConfig || {};
  return userConfig;
}
var getBrowserIntefaceLanguage = async () => {
  const languages2 = await browserAPI.i18n.getAcceptLanguages();
  const formatedlanguages = languages2.map((lang) => formatLanguage(lang));
  const defaultInterfaceLanguage = formatedlanguages.find((lang) => {
    return translations[lang];
  });
  if (defaultInterfaceLanguage) {
    return defaultInterfaceLanguage;
  } else {
    return "en";
  }
};
var getBuildInConfig = () => {
  const finalBuildInConfig = {
    ...buildin_config_default,
    buildinConfigUpdatedAt: env.BUILD_TIME
  };
  const defaultConfig = {
    ...finalBuildInConfig,
    "targetLanguage": fallbackLanguage,
    "interfaceLanguage": "en",
    debug: false,
    alpha: false,
    translationUrlPattern: {
      matches: [],
      excludeMatches: []
    },
    translationLanguagePattern: {
      matches: [],
      excludeMatches: []
    },
    translationThemePatterns: {},
    translationParagraphLanguagePattern: {
      matches: [],
      excludeMatches: [],
      selectorMatches: [],
      excludeSelectorMatches: []
    },
    translationBodyAreaPattern: {
      matches: [],
      excludeMatches: [],
      selectorMatches: [],
      excludeSelectorMatches: []
    },
    translationTheme: "none",
    translationService: "google",
    translationArea: "main",
    translationStartMode: "dynamic",
    translationServices: {},
    generalRule: {
      ...finalBuildInConfig.generalRule
    },
    translationGeneralConfig: { engine: "google" },
    rules: []
  };
  return defaultConfig;
};

// errors.ts
var CommonError = class extends Error {
  constructor(name, message, details) {
    super(message);
    this.name = name;
    if (details) {
      this.details = details;
    }
  }
};

// browser/request.ts
async function request(options2) {
  let response;
  if (options2 && options2.retry && options2.retry > 0) {
    try {
      response = await retry(rawRequest.bind(null, options2), {
        multiplier: 2,
        maxAttempts: options2.retry
      });
    } catch (e3) {
      if (e3 && e3.name === "RetryError") {
        if (e3.cause) {
          throw e3.cause;
        }
      }
      throw e3;
    }
  } else {
    response = await rawRequest(options2);
  }
  return response;
}
async function rawRequest(options2) {
  if (options2.body) {
  }
  let { url, responseType, ...fetchOptions } = options2;
  if (!responseType) {
    responseType = "json";
  }
  fetchOptions = {
    mode: "cors",
    ...fetchOptions
  };
  const fetchFn = options2.fetchPolyfill || fetch;
  const response = await fetchFn(url, fetchOptions);
  if (response.ok && response.status >= 200 && response.status < 400) {
    if (responseType === "json") {
      const data = await response.json();
      return data;
    } else if (responseType === "text") {
      const data = await response.text();
      return data;
    } else if (responseType === "raw") {
      const data = await response.text();
      const responseHeaders = Object.fromEntries([
        ...response.headers.entries()
      ]);
      let finalUrl = response.url;
      if (!finalUrl) {
        if (response.headers.get("X-Final-URL")) {
          finalUrl = response.headers.get("X-Final-URL");
        } else {
          finalUrl = url;
        }
      }
      const result = {
        body: data,
        headers: responseHeaders,
        status: response.status,
        statusText: response.statusText,
        url: finalUrl
      };
      return result;
    }
  } else {
    let details;
    try {
      details = await response.text();
    } catch (_e3) {
      log_default.error("parse response failed", _e3);
    }
    if (details) {
      log_default.error("fail response", details);
    }
    throw new CommonError(
      "fetchError",
      response.status + ": " + response.statusText || "",
      details
    );
  }
}

// utils/md5.js
function safeAdd(x5, y3) {
  var lsw = (x5 & 65535) + (y3 & 65535);
  var msw = (x5 >> 16) + (y3 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q6, a4, b4, x5, s4, t4) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a4, q6), safeAdd(x5, t4)), s4), b4);
}
function md5ff(a4, b4, c3, d3, x5, s4, t4) {
  return md5cmn(b4 & c3 | ~b4 & d3, a4, b4, x5, s4, t4);
}
function md5gg(a4, b4, c3, d3, x5, s4, t4) {
  return md5cmn(b4 & d3 | c3 & ~d3, a4, b4, x5, s4, t4);
}
function md5hh(a4, b4, c3, d3, x5, s4, t4) {
  return md5cmn(b4 ^ c3 ^ d3, a4, b4, x5, s4, t4);
}
function md5ii(a4, b4, c3, d3, x5, s4, t4) {
  return md5cmn(c3 ^ (b4 | ~d3), a4, b4, x5, s4, t4);
}
function binlMD5(x5, len) {
  x5[len >> 5] |= 128 << len % 32;
  x5[(len + 64 >>> 9 << 4) + 14] = len;
  var i2;
  var olda;
  var oldb;
  var oldc;
  var oldd;
  var a4 = 1732584193;
  var b4 = -271733879;
  var c3 = -1732584194;
  var d3 = 271733878;
  for (i2 = 0; i2 < x5.length; i2 += 16) {
    olda = a4;
    oldb = b4;
    oldc = c3;
    oldd = d3;
    a4 = md5ff(a4, b4, c3, d3, x5[i2], 7, -680876936);
    d3 = md5ff(d3, a4, b4, c3, x5[i2 + 1], 12, -389564586);
    c3 = md5ff(c3, d3, a4, b4, x5[i2 + 2], 17, 606105819);
    b4 = md5ff(b4, c3, d3, a4, x5[i2 + 3], 22, -1044525330);
    a4 = md5ff(a4, b4, c3, d3, x5[i2 + 4], 7, -176418897);
    d3 = md5ff(d3, a4, b4, c3, x5[i2 + 5], 12, 1200080426);
    c3 = md5ff(c3, d3, a4, b4, x5[i2 + 6], 17, -1473231341);
    b4 = md5ff(b4, c3, d3, a4, x5[i2 + 7], 22, -45705983);
    a4 = md5ff(a4, b4, c3, d3, x5[i2 + 8], 7, 1770035416);
    d3 = md5ff(d3, a4, b4, c3, x5[i2 + 9], 12, -1958414417);
    c3 = md5ff(c3, d3, a4, b4, x5[i2 + 10], 17, -42063);
    b4 = md5ff(b4, c3, d3, a4, x5[i2 + 11], 22, -1990404162);
    a4 = md5ff(a4, b4, c3, d3, x5[i2 + 12], 7, 1804603682);
    d3 = md5ff(d3, a4, b4, c3, x5[i2 + 13], 12, -40341101);
    c3 = md5ff(c3, d3, a4, b4, x5[i2 + 14], 17, -1502002290);
    b4 = md5ff(b4, c3, d3, a4, x5[i2 + 15], 22, 1236535329);
    a4 = md5gg(a4, b4, c3, d3, x5[i2 + 1], 5, -165796510);
    d3 = md5gg(d3, a4, b4, c3, x5[i2 + 6], 9, -1069501632);
    c3 = md5gg(c3, d3, a4, b4, x5[i2 + 11], 14, 643717713);
    b4 = md5gg(b4, c3, d3, a4, x5[i2], 20, -373897302);
    a4 = md5gg(a4, b4, c3, d3, x5[i2 + 5], 5, -701558691);
    d3 = md5gg(d3, a4, b4, c3, x5[i2 + 10], 9, 38016083);
    c3 = md5gg(c3, d3, a4, b4, x5[i2 + 15], 14, -660478335);
    b4 = md5gg(b4, c3, d3, a4, x5[i2 + 4], 20, -405537848);
    a4 = md5gg(a4, b4, c3, d3, x5[i2 + 9], 5, 568446438);
    d3 = md5gg(d3, a4, b4, c3, x5[i2 + 14], 9, -1019803690);
    c3 = md5gg(c3, d3, a4, b4, x5[i2 + 3], 14, -187363961);
    b4 = md5gg(b4, c3, d3, a4, x5[i2 + 8], 20, 1163531501);
    a4 = md5gg(a4, b4, c3, d3, x5[i2 + 13], 5, -1444681467);
    d3 = md5gg(d3, a4, b4, c3, x5[i2 + 2], 9, -51403784);
    c3 = md5gg(c3, d3, a4, b4, x5[i2 + 7], 14, 1735328473);
    b4 = md5gg(b4, c3, d3, a4, x5[i2 + 12], 20, -1926607734);
    a4 = md5hh(a4, b4, c3, d3, x5[i2 + 5], 4, -378558);
    d3 = md5hh(d3, a4, b4, c3, x5[i2 + 8], 11, -2022574463);
    c3 = md5hh(c3, d3, a4, b4, x5[i2 + 11], 16, 1839030562);
    b4 = md5hh(b4, c3, d3, a4, x5[i2 + 14], 23, -35309556);
    a4 = md5hh(a4, b4, c3, d3, x5[i2 + 1], 4, -1530992060);
    d3 = md5hh(d3, a4, b4, c3, x5[i2 + 4], 11, 1272893353);
    c3 = md5hh(c3, d3, a4, b4, x5[i2 + 7], 16, -155497632);
    b4 = md5hh(b4, c3, d3, a4, x5[i2 + 10], 23, -1094730640);
    a4 = md5hh(a4, b4, c3, d3, x5[i2 + 13], 4, 681279174);
    d3 = md5hh(d3, a4, b4, c3, x5[i2], 11, -358537222);
    c3 = md5hh(c3, d3, a4, b4, x5[i2 + 3], 16, -722521979);
    b4 = md5hh(b4, c3, d3, a4, x5[i2 + 6], 23, 76029189);
    a4 = md5hh(a4, b4, c3, d3, x5[i2 + 9], 4, -640364487);
    d3 = md5hh(d3, a4, b4, c3, x5[i2 + 12], 11, -421815835);
    c3 = md5hh(c3, d3, a4, b4, x5[i2 + 15], 16, 530742520);
    b4 = md5hh(b4, c3, d3, a4, x5[i2 + 2], 23, -995338651);
    a4 = md5ii(a4, b4, c3, d3, x5[i2], 6, -198630844);
    d3 = md5ii(d3, a4, b4, c3, x5[i2 + 7], 10, 1126891415);
    c3 = md5ii(c3, d3, a4, b4, x5[i2 + 14], 15, -1416354905);
    b4 = md5ii(b4, c3, d3, a4, x5[i2 + 5], 21, -57434055);
    a4 = md5ii(a4, b4, c3, d3, x5[i2 + 12], 6, 1700485571);
    d3 = md5ii(d3, a4, b4, c3, x5[i2 + 3], 10, -1894986606);
    c3 = md5ii(c3, d3, a4, b4, x5[i2 + 10], 15, -1051523);
    b4 = md5ii(b4, c3, d3, a4, x5[i2 + 1], 21, -2054922799);
    a4 = md5ii(a4, b4, c3, d3, x5[i2 + 8], 6, 1873313359);
    d3 = md5ii(d3, a4, b4, c3, x5[i2 + 15], 10, -30611744);
    c3 = md5ii(c3, d3, a4, b4, x5[i2 + 6], 15, -1560198380);
    b4 = md5ii(b4, c3, d3, a4, x5[i2 + 13], 21, 1309151649);
    a4 = md5ii(a4, b4, c3, d3, x5[i2 + 4], 6, -145523070);
    d3 = md5ii(d3, a4, b4, c3, x5[i2 + 11], 10, -1120210379);
    c3 = md5ii(c3, d3, a4, b4, x5[i2 + 2], 15, 718787259);
    b4 = md5ii(b4, c3, d3, a4, x5[i2 + 9], 21, -343485551);
    a4 = safeAdd(a4, olda);
    b4 = safeAdd(b4, oldb);
    c3 = safeAdd(c3, oldc);
    d3 = safeAdd(d3, oldd);
  }
  return [a4, b4, c3, d3];
}
function binl2rstr(input) {
  var i2;
  var output = "";
  var length32 = input.length * 32;
  for (i2 = 0; i2 < length32; i2 += 8) {
    output += String.fromCharCode(input[i2 >> 5] >>> i2 % 32 & 255);
  }
  return output;
}
function rstr2binl(input) {
  var i2;
  var output = [];
  output[(input.length >> 2) - 1] = void 0;
  for (i2 = 0; i2 < output.length; i2 += 1) {
    output[i2] = 0;
  }
  var length8 = input.length * 8;
  for (i2 = 0; i2 < length8; i2 += 8) {
    output[i2 >> 5] |= (input.charCodeAt(i2 / 8) & 255) << i2 % 32;
  }
  return output;
}
function rstrMD5(s4) {
  return binl2rstr(binlMD5(rstr2binl(s4), s4.length * 8));
}
function rstrHMACMD5(key, data) {
  var i2;
  var bkey = rstr2binl(key);
  var ipad = [];
  var opad = [];
  var hash;
  ipad[15] = opad[15] = void 0;
  if (bkey.length > 16) {
    bkey = binlMD5(bkey, key.length * 8);
  }
  for (i2 = 0; i2 < 16; i2 += 1) {
    ipad[i2] = bkey[i2] ^ 909522486;
    opad[i2] = bkey[i2] ^ 1549556828;
  }
  hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binlMD5(opad.concat(hash), 512 + 128));
}
function rstr2hex(input) {
  var hexTab = "0123456789abcdef";
  var output = "";
  var x5;
  var i2;
  for (i2 = 0; i2 < input.length; i2 += 1) {
    x5 = input.charCodeAt(i2);
    output += hexTab.charAt(x5 >>> 4 & 15) + hexTab.charAt(x5 & 15);
  }
  return output;
}
function str2rstrUTF8(input) {
  return unescape(encodeURIComponent(input));
}
function rawMD5(s4) {
  return rstrMD5(str2rstrUTF8(s4));
}
function hexMD5(s4) {
  return rstr2hex(rawMD5(s4));
}
function rawHMACMD5(k4, d3) {
  return rstrHMACMD5(str2rstrUTF8(k4), str2rstrUTF8(d3));
}
function hexHMACMD5(k4, d3) {
  return rstr2hex(rawHMACMD5(k4, d3));
}
function md5(string, key, raw) {
  if (!key) {
    if (!raw) {
      return hexMD5(string);
    }
    return rawMD5(string);
  }
  if (!raw) {
    return hexHMACMD5(key, string);
  }
  return rawHMACMD5(key, string);
}

// services/util.ts
function splitSentences(sentences, maxLength, maxGroupLength) {
  const tempSentences = splitStentenceWithMaxLength(sentences, maxLength);
  const tempSentenceGroups = [];
  let tempGroup = {
    from: sentences[0].from,
    fromByClient: sentences[0].fromByClient,
    to: sentences[0].to,
    tempSentences: [],
    url: sentences[0].url
  };
  for (const tempSentence of tempSentences) {
    const length = tempGroup.tempSentences.reduce(
      (acc, cur) => acc + cur.text.length,
      0
    );
    if (length + tempSentence.text.length > maxLength || tempGroup.tempSentences.length >= maxGroupLength) {
      tempSentenceGroups.push(tempGroup);
      tempGroup = {
        fromByClient: tempGroup.fromByClient,
        from: tempSentence.from,
        to: tempSentence.to,
        tempSentences: [],
        url: tempSentence.url
      };
    }
    if (tempGroup.from !== tempSentence.from || tempGroup.to !== tempSentence.to) {
      if (tempGroup.tempSentences.length > 0) {
        tempSentenceGroups.push(tempGroup);
        tempGroup = {
          fromByClient: tempGroup.fromByClient,
          from: tempSentence.from,
          to: tempSentence.to,
          tempSentences: [],
          url: tempSentence.url
        };
      } else {
        tempGroup.from = tempSentence.from;
        tempGroup.to = tempSentence.to;
      }
    }
    tempGroup.tempSentences.push(tempSentence);
  }
  if (tempGroup.tempSentences.length > 0) {
    tempSentenceGroups.push(tempGroup);
  }
  return tempSentenceGroups;
}
function splitStentenceWithMaxLength(sentences, maxLength) {
  const allTempSentences = [];
  for (let i2 = 0; i2 < sentences.length; i2++) {
    const currentSentence = sentences[i2];
    const { from, to, text, url } = currentSentence;
    const textArrSplitedByNewLine = text.split(/\r?\n/);
    const currentTempSentences = [];
    let currentPrefix = "";
    for (let j5 = 0; j5 < textArrSplitedByNewLine.length; j5++) {
      const currentText = textArrSplitedByNewLine[j5];
      if (currentText === "") {
        if (currentTempSentences.length > 0) {
          if (j5 < textArrSplitedByNewLine.length - 1) {
            currentTempSentences[currentTempSentences.length - 1].suffix += "\n";
          }
        } else {
          currentPrefix += "\n";
        }
        continue;
      } else {
        if (currentText.length > maxLength) {
          const tempSplitedSentences = [];
          splitSentence(currentText, maxLength, tempSplitedSentences);
          for (let k4 = 0; k4 < tempSplitedSentences.length; k4++) {
            const tempSentence = tempSplitedSentences[k4];
            const { text: text2, prefix, suffix } = tempSentence;
            currentTempSentences.push({
              from,
              to,
              text: text2,
              prefix,
              suffix,
              index: i2,
              url
            });
          }
        } else {
          currentTempSentences.push({
            text: currentText,
            prefix: currentPrefix,
            suffix: "",
            from,
            to,
            index: i2,
            url
          });
        }
      }
      if (currentTempSentences.length > 0 && j5 < textArrSplitedByNewLine.length - 1) {
        currentTempSentences[currentTempSentences.length - 1].suffix += "\n";
      }
    }
    allTempSentences.push(...currentTempSentences);
  }
  return allTempSentences;
}
function isSameTargetLanguage(sourceLanguage, targetLanguage) {
  const finalSourceLanguage = formatLanguage(sourceLanguage);
  const finalTargetLanguage = formatLanguage(targetLanguage);
  let isSame = finalSourceLanguage === finalTargetLanguage;
  if (isSame) {
    return true;
  }
  isSame = finalSourceLanguage.startsWith("zh") && finalTargetLanguage.startsWith("zh");
  return isSame;
}
function splitSentence(text, maxLength, sentences) {
  const boundaries = [".", "?", "!", "\u3002", "\uFF1F", "\uFF01"];
  const boundaryIndex = boundaries.reduce((acc, boundary) => {
    const index = text.lastIndexOf(boundary, maxLength);
    return index > acc ? index : acc;
  }, -1);
  if (boundaryIndex === -1) {
    sentences.push({
      text: text.slice(0, maxLength),
      prefix: "",
      suffix: ""
    });
    if (text.length > maxLength) {
      splitSentence(text.slice(maxLength), maxLength, sentences);
    }
  } else {
    const theText = text.slice(0, boundaryIndex + 1);
    if (theText.startsWith(" ")) {
      sentences.push({
        text: theText.slice(1),
        prefix: " ",
        suffix: ""
      });
    } else {
      sentences.push({
        text: theText,
        prefix: "",
        suffix: ""
      });
    }
    if (boundaryIndex + 1 < text.length) {
      splitSentence(text.slice(boundaryIndex + 1), maxLength, sentences);
    }
  }
  return sentences;
}
function mergeUrl(defaultUrl, customUrl) {
  const defaultUrlObj = new URL(defaultUrl);
  if (!customUrl.startsWith("http")) {
    customUrl = "https://" + customUrl;
  }
  const customUrlObj = new URL(customUrl);
  if (customUrlObj.pathname !== "/") {
    return customUrlObj.toString();
  } else {
    defaultUrlObj.host = customUrlObj.host;
    if (customUrlObj.port) {
      defaultUrlObj.port = customUrlObj.port;
    }
    if (customUrlObj.protocol) {
      defaultUrlObj.protocol = customUrlObj.protocol;
    }
    if (customUrlObj.username) {
      defaultUrlObj.username = customUrlObj.username;
    }
    if (customUrlObj.password) {
      defaultUrlObj.password = customUrlObj.password;
    }
    return defaultUrlObj.toString();
  }
}

// services/cache.ts
var dbNames = [];
async function openIndexedDB(dbName, _storageName) {
  return await new Promise((resolve, reject) => {
    const name = dbName;
    const version = 1;
    const request3 = indexedDB.open(name, version);
    request3.onsuccess = (_event) => {
      resolve(request3.result);
    };
    request3.onerror = (event) => {
      console.error(
        "onerror: Error opening the database, switching to non-database mode",
        event
      );
      reject();
    };
    request3.onupgradeneeded = (_event) => {
      const db = request3.result;
      const storageName = _storageName ? _storageName : "cache";
      db.createObjectStore(storageName, {
        keyPath: "key"
      });
    };
  });
}
async function setParagraphCache(payload) {
  const storageName = `${brandId}-${payload.service}@${payload.from}->${payload.to}`;
  const result = await addInDB(storageName, payload);
  return result;
}
async function queryParagraphCache(payload) {
  const payload_hash = md5(payload.originalText);
  const storageName = `${brandId}-${payload.service}@${payload.from}->${payload.to}`;
  const result = await queryInDB(storageName, payload_hash);
  return result;
}
async function queryInDB(dbName, origTextHash) {
  const db = await openIndexedDB(dbName);
  return await new Promise((resolve, reject) => {
    if (!db)
      return reject();
    const storageName = "cache";
    const objectStore = db.transaction([storageName], "readonly").objectStore(storageName);
    const request3 = objectStore.get(origTextHash);
    request3.onsuccess = (_event) => {
      db.close();
      const result = request3.result;
      resolve(result);
    };
    request3.onerror = (event) => {
      db.close();
      console.error("queryInDB->onerror:", event);
      reject();
    };
  });
}
async function addInDB(dbName, cacheEntry) {
  const db = await openIndexedDB(dbName);
  const names = await getAllDBNames();
  if (!names.includes(dbName)) {
    await addCacheList(dbName);
  }
  return await new Promise((resolve) => {
    if (!db)
      return resolve(false);
    const storageName = "cache";
    const objectStore = db.transaction([storageName], "readwrite").objectStore(storageName);
    const request3 = objectStore.put(cacheEntry);
    request3.onsuccess = (_event) => {
      db.close();
      resolve(true);
    };
    request3.onerror = (event) => {
      console.error("addInDB->onerror:", event);
      db.close();
      resolve(false);
    };
  });
}
async function addCacheList(dbName) {
  const storageName = "cache_list";
  const db = await openIndexedDB(brandId + "-cacheList", storageName);
  const objectStore = db.transaction([storageName], "readwrite").objectStore(storageName);
  const request3 = objectStore.put({ key: dbName });
  request3.onsuccess = (_event) => {
    db.close();
    dbNames.push(dbName);
  };
  request3.onerror = (event) => {
    db.close();
    console.error(event);
  };
}
async function getAllDBNames() {
  if (dbNames && dbNames.length > 0) {
    return dbNames;
  }
  const db = await openIndexedDB(brandId + "-cacheList", "cache_list");
  dbNames = await new Promise((resolve) => {
    const storageName = "cache_list";
    const objectStore = db.transaction([storageName], "readonly").objectStore(storageName);
    const request3 = objectStore.getAllKeys();
    request3.onsuccess = (_event) => {
      db.close();
      resolve(request3.result);
    };
    request3.onerror = (event) => {
      db.close();
      console.error(event);
      resolve([]);
    };
  });
  return dbNames;
}

// utils/detect_chinese.ts
var chineseRegex = /[\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u3005\u3007\u3021-\u3029\u3038-\u303B\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFA6D\uFA70-\uFAD9]|\uD81B[\uDFE2\uDFE3\uDFF0\uDFF1]|[\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF]/g;
var japaneseRegex = /[\u3041-\u3096\u309D-\u309F]|\uD82C[\uDC01-\uDD1F\uDD32\uDD50-\uDD52]|\uD83C\uDE00|[\u30A1-\u30FA\u30FD-\u30FF\u31F0-\u31FF\u32D0-\u32FE\u3300-\u3357\uFF66-\uFF6F\uFF71-\uFF9D]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00\uDD20-\uDD22\uDD55\uDD64-\uDD67]|[㐀-䶵一-龯]/g;
var koreanRegex = /[\u1100-\u11FF\u302E\u302F\u3131-\u318E\u3200-\u321E\u3260-\u327E\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uFFA0-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/g;
var punctuationRegex = /(\s+)|([\p{P}\p{S}])/gu;
var regexGroups = [
  ["zh-CN", chineseRegex],
  [
    "ja",
    japaneseRegex
  ],
  ["ko", koreanRegex]
];
function detectChinese(text) {
  if (!text) {
    return "auto";
  }
  let maxCountLang = "auto";
  let currentMaxCount = 0;
  let punctuationMatchesLength = 0;
  const punctuationMatches = text.match(punctuationRegex);
  if (punctuationMatches) {
    punctuationMatchesLength = punctuationMatches.reduce((sum, item) => {
      return sum + item.length;
    }, 0);
  }
  const allLettersLength = text.length - punctuationMatchesLength;
  for (const group of regexGroups) {
    const regex = group[1];
    const lang = group[0];
    const matches = text.match(regex);
    const langLength = matches ? matches.length : 0;
    if (langLength > currentMaxCount) {
      currentMaxCount = langLength;
      maxCountLang = lang;
    }
  }
  if (currentMaxCount * 2.5 / allLettersLength > 0.5) {
    return maxCountLang;
  }
  return "auto";
}

// dom/current_language.ts
var currentPageLanguage = "auto";
var currentPageLanguageByClient = "auto";
var currentPageLanguageByRemote = "auto";
function setCurrentPageLanguage(lang) {
  currentPageLanguage = lang;
}
function setCurrentPageLanguageByClient(lang) {
  currentPageLanguageByClient = lang;
}
function getCurrentPageLanguage() {
  if (currentPageLanguageByClient !== "auto") {
    return currentPageLanguageByClient;
  }
  if (currentPageLanguageByRemote !== "auto") {
    return currentPageLanguageByRemote;
  }
  return currentPageLanguage;
}
function getCurrentPageLanguageByClient() {
  return currentPageLanguageByClient;
}

// messager.ts
var listeners2 = /* @__PURE__ */ new Map();
var Messager = class {
  constructor(fromType, debug = false) {
    this.logger = new Logger();
    if (debug) {
      this.logger.setLevel("debug");
    }
    this.fromType = fromType;
    if (!listeners2.has(fromType)) {
      listeners2.set(fromType, /* @__PURE__ */ new Map());
      browserAPI.runtime.onMessage.addListener(
        // @ts-ignore: it's ok
        (message, sender, sendResponse) => {
          let from = message.from;
          const to = message.to;
          let tabId;
          let tabUrl;
          let tabActive;
          if (sender.tab && sender.tab.id) {
            tabId = sender.tab.id;
            from = `${from}:${tabId}`;
            tabUrl = sender.tab.url;
            tabActive = sender.tab.active;
          }
          this.logger.debug(
            `${message.to} received message [${message.payload.method}] from ${message.from}`,
            message.payload.data ? message.payload.data : " "
          );
          const parsedTo = parseType(to);
          const { type: toType, name: toName } = parsedTo;
          if (toType !== fromType) {
            return false;
          }
          const parsedMessageFrom = parseType(from);
          const currentListener = listeners2.get(toType);
          const connectionInfo = currentListener.get(toName);
          if (!connectionInfo) {
            this.logger.debug(
              `no message handler for ${toType}:${to}, but it's ok`
            );
            return false;
          }
          const { messageHandler, sync } = connectionInfo;
          const messageAuthor = {
            type: fromType,
            name: parsedMessageFrom.name,
            id: tabId,
            url: tabUrl,
            active: tabActive
          };
          if (sync) {
            try {
              const handlerResult = messageHandler(
                message.payload,
                messageAuthor
              );
              sendResponse({
                ok: true,
                data: handlerResult
              });
            } catch (e3) {
              sendResponse({
                ok: false,
                errorName: e3.name,
                errorMessage: e3.message,
                errorDetails: e3.details
              });
            }
            return false;
          } else {
            messageHandler(
              message.payload,
              messageAuthor
            ).then((data) => {
              sendResponse({
                ok: true,
                data
              });
            }).catch(
              (e3) => {
                sendResponse({
                  ok: false,
                  errorName: e3.name,
                  errorMessage: e3.message,
                  errorDetails: e3.details
                });
              }
            );
            return true;
          }
        }
      );
    }
  }
  getConnection(name, messageHandler, options2) {
    let sync = false;
    if (options2 && options2.sync) {
      sync = true;
    }
    const fromType = this.fromType;
    const currentListeners = listeners2.get(fromType);
    if (!currentListeners.has(name)) {
      const connection2 = new Connection(`${fromType}:${name}`, this.logger);
      listeners2.get(fromType).set(name, {
        messageHandler,
        sync,
        connectionInstance: connection2
      });
      return connection2;
    } else {
      return currentListeners.get(name).connectionInstance;
    }
  }
};
var Connection = class {
  constructor(from, logger) {
    this.from = from;
    this.logger = logger;
  }
  async sendMessage(to, messagePayload) {
    const parsedTo = parseType(to);
    const { type, id } = parsedTo;
    if (type !== "content_script") {
      const message = {
        to,
        from: this.from,
        payload: messagePayload
      };
      this.logger.debug(
        `${message.from} send message [${message.payload.method}] to ${message.to}`,
        message.payload.data ? message.payload.data : " "
      );
      try {
        const response = await browserAPI.runtime.sendMessage(message);
        return handleResponse(message, response, this.logger);
      } catch (e3) {
        if (type === "popup") {
          const errorMessage = `popup ${to} is not active, so the message does not send, ignore this error, ${JSON.stringify(messagePayload)}`;
          this.logger.debug(
            errorMessage,
            messagePayload,
            to,
            e3
          );
          return Promise.resolve({
            message: errorMessage
          });
        } else {
          throw e3;
        }
      }
    } else {
      const message = {
        from: this.from,
        to,
        payload: messagePayload
      };
      this.logger.debug(
        `${message.from} send message [${message.payload.method}] to ${message.to}`,
        message.payload.data ? message.payload.data : " "
      );
      const response = await browserAPI.tabs.sendMessage(id, message);
      return handleResponse(message, response, this.logger);
    }
  }
};
function handleResponse(message, response, logger) {
  if (response.ok) {
    logger.debug(
      `${message.from} received response from ${message.to}:`,
      response.data ? response.data : " "
    );
    return response.data;
  } else {
    throw new CommonError(
      response.errorName || "UnknownError",
      response.errorMessage || "Unknown error",
      response.errorDetails
    );
  }
}
function parseType(str) {
  const parts = str.split(":");
  if (parts.length < 2) {
    throw new Error("not a valid to string");
  }
  const messageTo = {
    type: parts[0],
    name: parts[1]
  };
  if (parts[0] === "content_script") {
    const tabId = parseInt(parts[2]);
    if (!isNaN(tabId)) {
      messageTo.id = tabId;
    } else {
      throw new Error("tab id not a valid number");
    }
  }
  return messageTo;
}

// content_message_listeners.ts
var asyncMessageHandler = async function(payload, _author) {
  const { method, data } = payload;
  if (method === "translateTheWholePage") {
    await translateTheWholePage();
  } else if (method === "translateTheMainPage") {
    await translateTheMainPage();
  } else if (method === "translateToThePageEndImmediately") {
    await translateToThePageEndImmediately();
  } else if (method === "toggleTranslatePage") {
    await toggleTranslatePage();
  } else if (method === "toggleTranslateTheWholePage") {
    await toggleTranslateTheWholePage();
  } else if (method === "toggleTranslateTheMainPage") {
    await toggleTranslateTheMainPage();
  } else if (method === "translatePage") {
    await translatePage();
  } else if (method === "toggleTranslationMask") {
    await toggleTranslationMask();
  } else if (method === "restorePage") {
    restorePage();
  } else if (method === "showTranslationOnly") {
    showTranslationOnly();
  } else if (method === "setCurrentPageLanguageByClient") {
    setCurrentPageLanguageByClient(data);
  }
};
var syncMessageHandler = function(payload, _author) {
  const { method, data } = payload;
  log_default.debug(
    `content script received sync message: ${method}`,
    data ? data : " "
  );
  if (method === "ping") {
    return "pong";
  } else if (method === "getPageStatus") {
    const pageStatus2 = getPageStatus();
    return pageStatus2;
  } else if (method === "getCurrentPageLanguage") {
    const language = getCurrentPageLanguage();
    return language;
  }
};
var connection;
var syncConnection;
function setupMessageListeners() {
  const asyncConnection = getConnection();
  const isInIframe = getIsInIframe();
  if (!isInIframe) {
    getSyncConnection();
  }
  asyncConnection.sendMessage("popup:main_sync", { method: "ready" }).catch(
    (_e3) => {
    }
  );
}
function getConnection() {
  if (connection) {
    return connection;
  }
  const messenger = new Messager("content_script", false);
  connection = messenger.getConnection("main", asyncMessageHandler);
  return connection;
}
function getSyncConnection() {
  if (syncConnection) {
    return syncConnection;
  }
  const messenger = new Messager("content_script", false);
  syncConnection = messenger.getConnection("main_sync", syncMessageHandler, {
    sync: true
  });
  return syncConnection;
}

// browser_proxy.ts
async function sendMessage(options2) {
  const c3 = getConnection();
  const response = await c3.sendMessage(
    "background:main",
    options2
  );
  return response;
}
function request2(options2) {
  if (isMonkey() || isDeno()) {
    options2.fetchPolyfill = globalThis.GM_fetch;
    return request(options2);
  }
  return sendMessage({
    method: "fetch",
    data: options2
  });
}
function getConfig2() {
  if (isMonkey()) {
    return getConfig();
  }
  return sendMessage(
    {
      method: "getConfig"
    }
  );
}
function getLocalConfig2() {
  if (isMonkey()) {
    return getLocalConfig();
  }
  return sendMessage(
    {
      method: "getLocalConfig"
    }
  );
}
function setLocalConfig2(config) {
  if (isMonkey()) {
    return setLocalConfig(config);
  }
  return sendMessage(
    {
      method: "setLocalConfig",
      data: config
    }
  );
}
function setBuildinConfig2(config) {
  if (isMonkey()) {
    return setBuildinConfig(config);
  }
  return sendMessage(
    {
      method: "setBuildinConfig",
      data: config
    }
  );
}
function detectLanguage(options2) {
  if (options2.text) {
    const chineseLike = detectChinese(options2.text);
    if (chineseLike !== "auto") {
      return Promise.resolve(chineseLike);
    }
  }
  if (isMonkey()) {
    const result = browserAPI.extra.detectLanguage(
      options2.text,
      options2.minLength
    );
    return Promise.resolve(result);
  }
  return sendMessage(
    {
      method: "detectLanguage",
      data: options2
    }
  );
}
function detectTabLanguage() {
  return sendMessage(
    {
      method: "detectTabLanguage"
    }
  );
}
function sendPageTranslatedStatus(status) {
  if (isMonkey()) {
    const event = new CustomEvent(pageTranslatedStatusEventName, {
      detail: status
    });
    document.dispatchEvent(event);
    return;
  }
  const c3 = getConnection();
  c3.sendMessage("popup:main_sync", {
    method: "setPageStatus",
    data: status
  }).catch((_e3) => {
  });
}
function queryDb(query) {
  if (isMonkey()) {
    return queryParagraphCache(query);
  }
  return sendMessage(
    {
      method: "queryParagraphCache",
      data: query
    }
  );
}
async function setDbStore(params) {
  if (isMonkey()) {
    await setParagraphCache(params);
    return;
  }
  return sendMessage(
    {
      method: "setParagraphCache",
      data: params
    }
  );
}
async function mockRequest() {
  if (isMonkey()) {
    return Promise.resolve();
  }
  await sendMessage({
    method: "mockRequest"
  });
  return;
}
function openOptionsPage(newTab = false) {
  if (isMonkey()) {
    browserAPI.runtime.openOptionsPage(newTab);
    return Promise.resolve();
  }
  return sendMessage({
    method: "openOptionsPage"
  });
}
function openAboutPage(newTab = false) {
  if (isMonkey()) {
    browserAPI.extra.openAboutPage(newTab);
    return Promise.resolve();
  }
  return sendMessage({
    method: "openAboutPage"
  });
}
function autoSyncLatestConfig() {
  if (isMonkey()) {
    log_default.warn(`autoSyncLatestConfig is not support in monkey`);
    return Promise.resolve();
  } else {
    return sendMessage({
      method: "autoSyncLatestConfig"
    });
  }
}

// dom/detect_page_language.ts
async function detectPageLanguage() {
  let lang = "auto";
  if (document.body && document.body.textContent && document.body.textContent.trim()) {
    lang = await detectLanguage({
      text: getMainText(document.body)
    });
  }
  if (lang === "auto" && document.documentElement && document.documentElement.lang) {
    lang = formatLanguage(document.documentElement.lang);
  }
  return lang;
}

// dom/get_containers.ts
function getContainers(root2, ctx) {
  if (!(root2 && root2.textContent && root2.textContent.trim())) {
    return [];
  }
  const { rule, state: { translationArea } } = ctx;
  let contentContainers = [];
  if (translationArea === "body") {
    return [root2];
  }
  if (rule && rule.selectors.length > 0) {
    const containers = rule.selectors.map((selector) => {
      const isMatch = root2.matches(selector);
      let elements = [];
      if (isMatch) {
        elements = [root2];
      } else {
        elements = root2.querySelectorAll(
          selector
        );
      }
      for (const element of elements) {
        if (!isMarked(element, specifiedTargetContainerElementAttributeName)) {
          setAttribute(
            element,
            specifiedTargetContainerElementAttributeName,
            "1"
          );
        }
      }
      return Array.from(elements);
    }).flat();
    contentContainers.push(
      ...containers.map((container) => ({
        element: container,
        reserve: true
      }))
    );
  } else {
    if (rule && rule.additionalSelectors.length > 0) {
      const additionalElements = getElementsBySelectors(
        root2,
        rule.additionalSelectors
      );
      for (const element of additionalElements) {
        if (!isMarked(element, specifiedTargetContainerElementAttributeName)) {
          setAttribute(
            element,
            specifiedTargetContainerElementAttributeName,
            "1"
          );
        }
      }
      contentContainers.push(
        ...additionalElements.map((element) => ({
          element,
          reserve: true
        }))
      );
    }
    const articleElements = getElementsBySelectors(root2, ["article"]);
    contentContainers.push(
      ...articleElements.map((element) => ({
        element,
        reserve: true
      }))
    );
    let mains;
    if (contentContainers.length === 0) {
      mains = root2.querySelectorAll("[role=main]");
      if (mains.length === 0) {
        mains = root2.querySelectorAll("main");
      }
      if (mains.length === 0) {
        mains = root2.querySelectorAll(".main");
      }
      if (mains.length > 0) {
        const mainsArray = Array.from(mains);
        contentContainers = contentContainers.concat(
          mainsArray.map((main3) => ({
            element: main3,
            reserve: true
          }))
        );
      }
    }
    const detectedContainers = [];
    const treeFilter = (node) => {
      if (node.nodeType === Node.ELEMENT_NODE) {
        if (isExcludeElement(node, ctx.rule, false)) {
          return NodeFilter.FILTER_REJECT;
        }
      }
      if (node.nodeType === Node.TEXT_NODE) {
        const trimedText = node.textContent ? node.textContent.trim() : "";
        if (trimedText.length >= rule.containerMinTextCount) {
          let parentNode = node.parentNode;
          if (parentNode && parentNode.parentNode) {
            parentNode = parentNode.parentNode;
          }
          if (parentNode && parentNode.nodeType === Node.ELEMENT_NODE) {
            if (!detectedContainers.includes(parentNode)) {
              detectedContainers.push(parentNode);
            }
          }
        }
      }
      return NodeFilter.FILTER_ACCEPT;
    };
    const walk = document.createTreeWalker(
      root2,
      NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
      treeFilter
    );
    while (walk.nextNode()) {
    }
    contentContainers.push(
      ...detectedContainers.map((element) => ({
        element,
        reserve: false
      }))
    );
  }
  const finalContainers = duplicatedElements(root2, contentContainers, rule);
  finalContainers.sort(function(a4, b4) {
    return a4.compareDocumentPosition(b4) & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
  });
  return finalContainers;
}

// dom/unmount.ts
var cleanQueue = [];
function addToUnmountQueue(fn) {
  cleanQueue.push(fn);
}
function clean() {
  cleanQueue.forEach((fn) => fn());
  cleanQueue = [];
}

// dom/elements_to_paragraph.ts
function elementsToParagraph(elements, isPreWhitespace, rootFrame, ctx) {
  const variables = [];
  const { rule } = ctx;
  const delimiters = getPlaceholderDelimiters(ctx);
  if (elements.length === 0) {
    return null;
  }
  elements = elements.map(
    (element) => {
      if (element.element) {
        return element;
      } else {
        return {
          element
        };
      }
    }
  );
  const isForceTranslate = elements.some(
    (element) => {
      return element.forceTranslate;
    }
  );
  let text = "";
  let isHasMeaningfulText = isForceTranslate;
  for (let i2 = 0; i2 < elements.length; i2++) {
    const elementState = elements[i2];
    const element = elementState.element;
    if (elementState.text) {
      text += elementState.text;
      if (elementState.variables && elementState.variables.length > 0) {
        variables.push(...elementState.variables);
      }
      continue;
    }
    if (typeof element === "string") {
      text += element;
      continue;
    }
    let rawText = "";
    if (isContainsSelectors(
      element,
      `[${sourceElementExcludeAttributeNameForSelector}]`
    )) {
      rawText = getTextWithExcludeElement(element) || "";
    } else {
      rawText = element.innerText || "";
    }
    let isStartWithSpace = rawText.startsWith(" ");
    let isEndWithSpace = rawText.endsWith(" ");
    if (element.tagName === "A") {
      isStartWithSpace = true;
      isEndWithSpace = true;
    }
    const isStayOriginal = isStayOriginalElement(element, rule);
    if (rawText === "" || isStayOriginal) {
      if (isStayOriginal) {
        isStartWithSpace = true;
        isEndWithSpace = true;
      }
      const variable = {
        type: "element",
        value: element
      };
      variables.push(variable);
      const index = variables.length - 1;
      const delimiter = `${delimiters[0]}${index}${delimiters[1]}`;
      text += (isStartWithSpace ? " " : "") + delimiter + (isEndWithSpace ? " " : "");
      continue;
    }
    if (isExcludeElement(element, rule, true)) {
      continue;
    } else {
      const finalText = isPreWhitespace ? rawText : rawText.trim().replace(/\n/g, " ");
      if (isUrl(finalText) || isHashTag(finalText) || isAtTag(finalText) || isStockTag(finalText)) {
        const variable = {
          type: "element",
          value: element
        };
        variables.push(variable);
        const index = variables.length - 1;
        const delimiter = `${delimiters[0]}${index}${delimiters[1]}`;
        text += (isStartWithSpace ? " " : "") + delimiter + (isEndWithSpace ? " " : "");
      } else {
        isHasMeaningfulText = true;
        text += (isStartWithSpace ? " " : "") + finalText + (isEndWithSpace ? " " : "");
      }
    }
    if (typeof element !== "string") {
      const whitespace = getWhitespace(
        element.nextSibling,
        isPreWhitespace
      );
      if (whitespace) {
        text += whitespace;
      }
    }
  }
  if (!isHasMeaningfulText) {
    return null;
  }
  let inline = false;
  const wordCount = text.split(" ").length;
  const lineCount = text.split("\n").length;
  if (wordCount <= rule.blockMinWordCount && text.length <= rule.blockMinTextCount && lineCount < 2) {
    inline = true;
  }
  const finalElements = elements.map(
    (element) => element.element
  );
  const lastElement = getLastHTMLElement(elements);
  let isVertical = false;
  if (lastElement) {
    const computedStyle = globalThis.getComputedStyle(lastElement);
    const writtingMode = computedStyle.writingMode;
    isVertical = writtingMode ? writtingMode.includes("vertical") : false;
  }
  const paragraph = {
    rootFrame,
    isVertical,
    elements: finalElements,
    text,
    variables,
    inline,
    preWhitespace: isPreWhitespace
  };
  if (isForceTranslate || isNeedToTranslate(
    paragraph,
    ctx.state.translationArea === "body" ? 2 : rule.paragraphMinTextCount,
    ctx.state.translationArea === "body" ? 1 : rule.paragraphMinWordCount,
    ctx
  )) {
    return paragraph;
  }
  return null;
}
function getTextWithExcludeElement(element) {
  let finalText = "";
  const filterExcludeElement = (node) => {
    if (node.nodeType === Node.ELEMENT_NODE) {
      if (isMarked(node, sourceElementExcludeAttributeName, true)) {
        return NodeFilter.FILTER_REJECT;
      } else {
        return NodeFilter.FILTER_ACCEPT;
      }
    } else if (node.nodeType === Node.TEXT_NODE) {
      if (node.textContent && node.textContent.trim() !== "") {
        finalText += node.textContent.replace(/\s+/g, " ");
      }
      return NodeFilter.FILTER_REJECT;
    }
    return NodeFilter.FILTER_ACCEPT;
  };
  const treeWalker = document.createTreeWalker(
    element,
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT,
    filterExcludeElement
  );
  while (treeWalker.nextNode()) {
  }
  return finalText;
}

// dom/get_paragraphs.ts
var paragraphAutoIncreaceId = 1;
var paragraphEntities = /* @__PURE__ */ new Map();
function getParagraphEntities() {
  return paragraphEntities;
}
function getParagraph(id) {
  return paragraphEntities.get(id);
}
function setParagraph(id, paragraph) {
  paragraphEntities.set(id, paragraph);
}
function cleanParagraphs() {
  paragraphEntities.clear();
}
function isMarkedByParagraph(targetElement) {
  if (!isMarked(targetElement, sourceElementMarkAttributeName)) {
    return false;
  }
  if (isMarked(targetElement, sourceElementTranslatedMarkAttributeName)) {
    return true;
  }
  const markId = getAttribute(
    targetElement,
    sourceElementParagraphAttributeName
  );
  if (!markId) {
    return false;
  }
  const paragraphId = parseInt(markId);
  const isExist = paragraphEntities.has(paragraphId);
  if (!isExist) {
    const maybeTargetElement = document.getElementById(
      `${translationTargetElementWrapperClass}-${paragraphId}`
    );
    if (maybeTargetElement) {
      maybeTargetElement.remove();
    }
  }
  return isExist;
}
function addToParagraphs(paragraph, allParagraphs) {
  const newParagraph = {
    ...paragraph,
    id: paragraphAutoIncreaceId++,
    languageByClient: "auto",
    languageByLocal: "auto"
  };
  newParagraph.elements.forEach((element) => {
    if (element instanceof HTMLElement) {
      setAttribute(element, sourceElementMarkAttributeName, "1");
      setAttribute(
        element,
        sourceElementParagraphAttributeName,
        `${newParagraph.id}`
      );
    }
  });
  allParagraphs.push(newParagraph);
  paragraphEntities.set(newParagraph.id, {
    ...newParagraph,
    state: "Original",
    observers: []
  });
}
async function getParagraphs(rootFrame, containers, ctx) {
  const allParagraphs = [];
  const { targetLanguage, rule } = ctx;
  for (const container of containers) {
    if (isExcludeElement(container, rule, false)) {
      continue;
    }
    const isPreWhitespaceContainer = isMarked(
      container,
      sourcePreWhitespaceMarkAttributeName
    );
    const inlineElementGroups = [];
    if (isMarked(container, sourceAtomicBlockElementMarkAttributeName)) {
      if (!isMarkedByParagraph(container)) {
        const paragraph = elementsToParagraph(
          [container],
          true,
          rootFrame,
          ctx
        );
        if (paragraph) {
          addToParagraphs(paragraph, allParagraphs);
        }
      }
      continue;
    }
    const filter = (node2) => {
      if (!(node2.nodeType === Node.TEXT_NODE || node2.nodeType === Node.ELEMENT_NODE)) {
        return NodeFilter.FILTER_REJECT;
      }
      if (node2.nodeType === Node.ELEMENT_NODE) {
        const element = node2;
        if (element.isContentEditable) {
          return NodeFilter.FILTER_REJECT;
        }
        if (isMarkedByParagraph(
          node2
        )) {
          return NodeFilter.FILTER_REJECT;
        } else {
          setAttribute(element, sourceElementMarkAttributeName, "1");
        }
        if (isMarked(element, sourceAtomicBlockElementMarkAttributeName)) {
          if (inlineElementGroups.length > 0) {
            const paragraph2 = elementsToParagraph(
              [...inlineElementGroups],
              isPreWhitespaceContainer,
              rootFrame,
              ctx
            );
            if (paragraph2) {
              addToParagraphs(paragraph2, allParagraphs);
            }
            inlineElementGroups.length = 0;
          }
          inlineElementGroups.push(element);
          const paragraph = elementsToParagraph(
            [...inlineElementGroups],
            isPreWhitespaceContainer,
            rootFrame,
            ctx
          );
          if (paragraph) {
            addToParagraphs(paragraph, allParagraphs);
          }
          inlineElementGroups.length = 0;
          return NodeFilter.FILTER_REJECT;
        }
      }
      if (isExcludeElement(node2, rule, true)) {
        if (isMatchTags(node2.nodeName, ["CODE", "TT"]) && isMatchTags(node2.parentNode?.nodeName, ["PRE"])) {
          return NodeFilter.FILTER_REJECT;
        }
        if (isInlineElement(
          node2,
          rule
        )) {
          handleInlineElement(
            node2,
            inlineElementGroups,
            allParagraphs,
            isPreWhitespaceContainer,
            rootFrame,
            ctx
          );
          return NodeFilter.FILTER_REJECT;
        } else {
          if (inlineElementGroups.length > 0) {
            const paragraph = elementsToParagraph(
              [...inlineElementGroups],
              isPreWhitespaceContainer,
              rootFrame,
              ctx
            );
            if (paragraph) {
              addToParagraphs(paragraph, allParagraphs);
            }
            inlineElementGroups.length = 0;
          }
        }
        return NodeFilter.FILTER_REJECT;
      }
      if (isMatchTags(node2.nodeName, ["PRE"])) {
        if (node2.classList.contains("code")) {
          return NodeFilter.FILTER_REJECT;
        }
        return NodeFilter.FILTER_REJECT;
      }
      if (isInlineElement(
        node2,
        rule
      )) {
        handleInlineElement(
          node2,
          inlineElementGroups,
          allParagraphs,
          isPreWhitespaceContainer,
          rootFrame,
          ctx
        );
        return NodeFilter.FILTER_REJECT;
      }
      return NodeFilter.FILTER_ACCEPT;
    };
    const elementIter = document.createTreeWalker(
      container,
      NodeFilter.SHOW_ELEMENT,
      filter
    );
    let node = elementIter.nextNode();
    while (node) {
      if (inlineElementGroups.length > 0) {
        const paragraph = elementsToParagraph(
          [...inlineElementGroups],
          isPreWhitespaceContainer,
          rootFrame,
          ctx
        );
        if (paragraph) {
          addToParagraphs(paragraph, allParagraphs);
        }
        inlineElementGroups.length = 0;
      }
      node = elementIter.nextNode();
    }
    if (inlineElementGroups.length > 0) {
      const paragraph = elementsToParagraph(
        [...inlineElementGroups],
        isPreWhitespaceContainer,
        rootFrame,
        ctx
      );
      if (paragraph) {
        addToParagraphs(paragraph, allParagraphs);
      }
      inlineElementGroups.length = 0;
    }
  }
  const promises = allParagraphs.map((paragraph) => {
    const { text } = paragraph;
    return detectLanguage({
      text,
      minLength: 10
    });
  });
  const results = await Promise.all(promises);
  const filterdParagraphs = [];
  const excludeLanguages = ctx?.config?.translationLanguagePattern?.excludeMatches || [];
  let currentPageLanguageByClient2 = "auto";
  if (!ctx.state.isDetectParagraphLanguage) {
    currentPageLanguageByClient2 = getCurrentPageLanguageByClient();
  }
  const currentPageLanguageByLocal = getCurrentPageLanguage();
  results.forEach((result, index) => {
    let currentLanguageByLocal = result;
    if (currentLanguageByLocal === "auto") {
      currentLanguageByLocal = currentPageLanguageByLocal;
    }
    const newParagraph = {
      ...allParagraphs[index],
      languageByLocal: currentLanguageByLocal,
      languageByClient: currentPageLanguageByClient2 || "auto"
    };
    if (newParagraph.text.length < ctx.rule.languageDetectMinTextCount) {
      newParagraph.languageByLocal = "auto";
    }
    paragraphEntities.set(newParagraph.id, {
      ...newParagraph,
      state: "Original",
      observers: []
    });
    const isSame = isSameTargetLanguage(result, targetLanguage);
    if (!isSame) {
      if (excludeLanguages.length > 0) {
        const isExclude = excludeLanguages.some((language) => {
          return isSameTargetLanguage(result, language);
        });
        if (isExclude) {
          return;
        }
      }
      filterdParagraphs.push(newParagraph);
    }
  });
  return filterdParagraphs;
}
function getInlineElementsOfInlineElement(root2, isPreWhitespaceContainer, rootFrame, ctx) {
  let elementState = {
    element: root2
  };
  const treeWalker = document.createTreeWalker(
    root2,
    NodeFilter.SHOW_TEXT,
    null
  );
  let node = null;
  let isWhiteSpaceNodeOfLastElement = false;
  let fullText = "";
  let variables = [];
  let elements = [];
  while (node = treeWalker.nextNode()) {
    const rawText = node.textContent || "";
    const textContent = rawText.trim();
    if (!isWhiteSpaceNodeOfLastElement && rawText.length > 0 && textContent.length === 0) {
      isWhiteSpaceNodeOfLastElement = true;
      fullText += " ";
      elements.push(" ");
      continue;
    }
    if (textContent.length > 0) {
      const parent = node.parentElement;
      if (parent === root2) {
        const text = textContent.replace(/\s+/g, " ");
        fullText += text;
        elements.push(text);
      } else {
        elements.push(parent);
        const parentElementParagraph = elementsToParagraph(
          [{
            element: parent,
            forceTranslate: true
          }],
          isPreWhitespaceContainer,
          rootFrame,
          ctx
        );
        if (parentElementParagraph) {
          fullText += parentElementParagraph.text;
          if (parentElementParagraph) {
            if (parentElementParagraph.variables) {
              variables = variables.concat(parentElementParagraph.variables);
            }
          }
        }
      }
      isWhiteSpaceNodeOfLastElement = false;
    }
  }
  const lastElement = elements[elements.length - 1];
  if (lastElement && typeof lastElement !== "string") {
    const whitespace = getWhitespace(
      lastElement.nextSibling,
      isPreWhitespaceContainer
    );
    if (whitespace) {
      elements.push(whitespace);
      fullText += " ";
    }
  }
  if (typeof elements[elements.length - 1] !== "string") {
    const whitespace = getWhitespace(
      root2.nextSibling,
      isPreWhitespaceContainer
    );
    if (whitespace) {
      elements.push(whitespace);
      fullText += " ";
    }
  }
  elementState.text = fullText;
  elementState.variables = variables;
  return elementState;
}
function handleInlineElement(node, inlineElementGroups, allParagraphs, isPreWhitespaceContainer, rootFrame, ctx) {
  const previouseElement = node.previousElementSibling;
  if (previouseElement && !isInlineElement(
    previouseElement,
    ctx.rule
  )) {
    if (inlineElementGroups.length > 0) {
      const paragraph = elementsToParagraph(
        [...inlineElementGroups],
        isPreWhitespaceContainer,
        rootFrame,
        ctx
      );
      if (paragraph) {
        addToParagraphs(paragraph, allParagraphs);
      }
      inlineElementGroups.length = 0;
    }
  }
  const isExcludeElementBool = isExcludeElement(
    node,
    ctx.rule,
    false
  );
  if (isExcludeElementBool) {
    if (!isMetaElement(node, ctx.rule)) {
      inlineElementGroups.push(node);
    }
  } else if (!isStayOriginalElement(node, ctx.rule)) {
    if (isContainsSelectors(node, ["code", "tt"])) {
      inlineElementGroups.push(
        getInlineElementsOfInlineElement(
          node,
          isPreWhitespaceContainer,
          rootFrame,
          ctx
        )
      );
    } else {
      inlineElementGroups.push(node);
    }
  } else {
    inlineElementGroups.push(node);
  }
}

// dom/get_pdf_paragraphs.ts
async function getParagraphs2(rootFrame, containers, ctx, targetContainers) {
  const allParagraphs = [];
  const { rule } = ctx;
  for (let i2 = 0; i2 < containers.length; i2++) {
    const container = containers[i2];
    const targetContainer = targetContainers[i2];
    if (!targetContainer) {
      throw new Error("targetContainer is null");
    }
    const inlineElementGroups = [];
    let isFirstElementOfParagraph = true;
    let lastLineFirstElementInfo = null;
    const pdfContainerFilter = function(node2) {
      const element = node2;
      if (isMatchTags(element.nodeName, ["DIV", "BR"])) {
        isFirstElementOfParagraph = true;
        return NodeFilter.FILTER_REJECT;
      }
      if (element.classList.contains("markedContent")) {
        return NodeFilter.FILTER_ACCEPT;
      }
      if (isMarkedByParagraph2(
        node2
      )) {
        return NodeFilter.FILTER_REJECT;
      } else {
        setAttribute(element, sourceElementMarkAttributeName, "1");
      }
      if (isInlineElement(element, rule)) {
        const lastElement = getLastHTMLElement(inlineElementGroups);
        const currentElementStyle = globalThis.getComputedStyle(element);
        if (!lastElement) {
          inlineElementGroups.push(formatElement(element, currentElementStyle));
        } else {
          const lastElementStyle = globalThis.getComputedStyle(lastElement);
          const lastElementInfo = getElementInfoByComputedStyle(
            lastElementStyle
          );
          const currentElementInfo = getElementInfoByComputedStyle(
            currentElementStyle
          );
          const distanceInfo = getDistance(currentElementInfo, lastElementInfo);
          let isNewParagraph = false;
          if (isFirstElementOfParagraph && lastLineFirstElementInfo) {
            const firstElementBetweenThisLineAndLastLineDistanceInfo = getDistance(currentElementInfo, lastLineFirstElementInfo);
            if (firstElementBetweenThisLineAndLastLineDistanceInfo.left >= 1.5 && lastLineFirstElementInfo.left > -3) {
              isNewParagraph = true;
            }
          }
          if (!isNewParagraph && isFirstElementOfParagraph) {
            const currentText = element.innerText || element.textContent || "";
            const trimedText = currentText.trim();
            if (trimedText.startsWith("\u2022") || trimedText.charCodeAt(0) === 61623) {
              isNewParagraph = true;
            } else if (/^\d+\./.test(trimedText)) {
              isNewParagraph = true;
            }
          }
          if (!isNewParagraph && isFirstElementOfParagraph) {
            const lastElement2 = getLastHTMLElement(inlineElementGroups);
            if (lastElement2) {
              const maxRight = getHTMLElements(inlineElementGroups).reduce(
                (max, element2) => {
                  const elementInfo = getElementInfoByComputedStyle(
                    globalThis.getComputedStyle(element2)
                  );
                  return Math.max(max, elementInfo.right);
                },
                0
              );
              const rightDistance = maxRight - lastElementInfo.right;
              if (rightDistance > rule.pdfNewParagraphIndentRightIndentPx) {
                isNewParagraph = true;
              }
            }
          }
          if (isFirstElementOfParagraph) {
            lastLineFirstElementInfo = currentElementInfo;
            isFirstElementOfParagraph = false;
          }
          if (!isNewParagraph) {
            isNewParagraph = getIsNewParagraph(distanceInfo, rule);
          }
          if (isNewParagraph) {
            tryToAddToParagraph(
              inlineElementGroups,
              allParagraphs,
              rootFrame,
              ctx,
              targetContainer
            );
          }
          inlineElementGroups.push(formatElement(element, currentElementStyle));
          inlineElementGroups.push(" ");
        }
        return NodeFilter.FILTER_REJECT;
      } else {
      }
      return NodeFilter.FILTER_ACCEPT;
    };
    const elementIter = document.createTreeWalker(
      container,
      NodeFilter.SHOW_ELEMENT,
      pdfContainerFilter
    );
    let node = elementIter.nextNode();
    while (node) {
      node = elementIter.nextNode();
    }
    tryToAddToParagraph(
      inlineElementGroups,
      allParagraphs,
      rootFrame,
      ctx,
      targetContainer
    );
  }
  return allParagraphs;
}
function tryToAddToParagraph(inlineElementGroups, allParagraphs, rootFrame, ctx, targetContainer) {
  if (inlineElementGroups.length > 0) {
    const paragraph = elementsToParagraph(
      [...inlineElementGroups],
      false,
      rootFrame,
      ctx
    );
    if (paragraph) {
      paragraph.isPdf = true;
      paragraph.targetContainer = targetContainer;
      paragraph.inline = false;
      addToParagraphs(paragraph, allParagraphs);
    }
    inlineElementGroups.length = 0;
  }
}
function getElementInfoByComputedStyle(style) {
  return {
    top: parseFloat(style.top.slice(0, -2)),
    left: parseFloat(style.left.slice(0, -2)),
    right: parseFloat(style.left.slice(0, -2)) + parseFloat(style.width.slice(0, -2)),
    fontSize: parseFloat(style.fontSize.slice(0, -2))
  };
}
function getIsNewParagraph(distance, rule) {
  if (distance.fontSize > 2 || distance.fontSize < -2) {
    return true;
  }
  if (distance.top >= rule.pdfNewParagraphLineHeight || distance.top <= rule.pdfNewParagraphLineHeight * -1) {
    return true;
  }
  return false;
}
function getDistance(elementInfo1, elementInfo2) {
  const elementBasedFontSize = elementInfo2.fontSize;
  const currentElementFontSize = elementInfo1.fontSize;
  return {
    top: (elementInfo1.top - elementInfo2.top) / elementBasedFontSize,
    left: (elementInfo1.left - elementInfo2.left) / elementBasedFontSize,
    fontSize: currentElementFontSize - elementBasedFontSize
  };
}
function formatElement(element, style) {
  const fontFamily = style.fontFamily;
  if (fontFamily === "monospace") {
    return {
      element,
      isStayOriginal: true,
      targetTagName: "code"
    };
  } else {
    return element;
  }
}
function isMarkedByParagraph2(targetElement) {
  if (!isMarked(targetElement, sourceElementMarkAttributeName)) {
    return false;
  }
  if (isMarked(targetElement, sourceElementTranslatedMarkAttributeName)) {
    return true;
  }
  const markId = getAttribute(
    targetElement,
    sourceElementParagraphAttributeName
  );
  if (!markId) {
    return false;
  }
  const paragraphId = parseInt(markId);
  const paragraphEntities2 = getParagraphEntities();
  const isExist = paragraphEntities2.has(paragraphId);
  if (!isExist) {
    const maybeTargetElement = document.getElementById(
      `${translationTargetElementWrapperClass}-${paragraphId}`
    );
    if (maybeTargetElement) {
      maybeTargetElement.remove();
    }
  }
  return isExist;
}

// utils/escape_html.ts
function escapeHTML(htmlStr) {
  return htmlStr.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
}

// dom/paragraph_to_html.ts
function getTranslationWrapperClassNames(translationTheme, isInline, additonalClassNames = [], isPreWhitespace, isPdf) {
  const classList = ["notranslate"];
  if (isPreWhitespace) {
    classList.push(
      translationTargetTranslationElementPreWhitespaceWrapperClass
    );
  }
  if (translationTheme) {
    classList.push(
      `${brandId}-target-translation-theme-${translationTheme}`
    );
    if (isInline) {
      classList.push(
        `${translationTargetTranslationElementInlineWrapperClass}-theme-${translationTheme}`
      );
    } else {
      classList.push(
        `${translationTargetTranslationElementBlockWrapperClass}-theme-${translationTheme}`
      );
    }
  }
  if (additonalClassNames.length > 0) {
    classList.push(...additonalClassNames);
  }
  if (isInline) {
    classList.push(translationTargetTranslationElementInlineWrapperClass);
  } else {
    classList.push(translationTargetTranslationElementBlockWrapperClass);
    if (isPdf) {
      classList.push(translationTargetTranslationPdfElementBlockWrapperClass);
    }
  }
  return classList;
}
function getTranslationInnerClassNames(translationTheme) {
  const innerClassList = [
    "notranslate",
    translationTargetInnerElementWrapperClass
  ];
  if (translationTheme) {
    innerClassList.push(
      `${brandId}-target-translation-theme-${translationTheme}-inner`
    );
  }
  return innerClassList;
}
function paragraphToHtml(sourceItem, sentence, ctx) {
  const { rule, state } = ctx;
  const { translationTheme } = state;
  let { variables, isVertical } = sourceItem;
  variables = variables || [];
  const { text: targetText } = sentence;
  const { wrapperPrefix, wrapperSuffix } = rule;
  const delimiters = getPlaceholderDelimiters(ctx);
  const position = "afterend";
  const regex = new RegExp(`${delimiters[0]}(\\d+)${delimiters[1]}`, "g");
  let html = escapeHTML(targetText);
  if (variables.length > 0) {
    html = html.replace(regex, (match) => {
      const matchPositonAtHtml = html.indexOf(match);
      const isStartWhiteSpace = html[matchPositonAtHtml - 1] === " ";
      const isEndWhiteSpace = html[matchPositonAtHtml + match.length] === " ";
      const matchNumberStr = match.slice(
        delimiters[0].length,
        -delimiters[1].length
      );
      const matchNumber = Number(matchNumberStr);
      if (isNaN(matchNumber)) {
        return match;
      }
      const variable = variables[Number(matchNumber)];
      if (variable && variable.type === "element") {
        let variableHtml = variable.value.outerHTML;
        if (!isStartWhiteSpace) {
          variableHtml = " " + variableHtml;
        }
        if (!isEndWhiteSpace) {
          variableHtml = variableHtml + " ";
        }
        return variableHtml;
      } else {
        log_default.error("variable type not supported", variable, match);
      }
      return match;
    });
  }
  const classList = getTranslationWrapperClassNames(
    translationTheme,
    sourceItem.inline,
    rule.translationClasses || [],
    sourceItem.preWhitespace,
    ctx.rule.isPdf
  );
  if (isVertical) {
    classList.push(translationTargetTranslationElementVerticalBlockClass);
  }
  const innerClassList = getTranslationInnerClassNames(
    translationTheme
  );
  let blockStyleStr = "";
  if (rule.translationBlockStyle) {
    blockStyleStr = `style="${rule.translationBlockStyle}"`;
  }
  html = `<span ${blockStyleStr} class="${classList.join(" ")}"><span class="${innerClassList.join(" ")}">${html}</span></span>`;
  if (!sourceItem.inline) {
    if (wrapperPrefix === "smart") {
      html = `<br />${html}`;
    } else {
      html = `${wrapperPrefix}${html}`;
    }
    if (wrapperSuffix === "smart") {
      html = `${html}`;
    } else {
      html = `${html}${wrapperSuffix}`;
    }
  }
  if (sourceItem.inline) {
    html = `<span class="notranslate">&#160;</span>${html}`;
  }
  return {
    html,
    position
  };
}

// dom/normalize_container.ts
function normalizeContainer(containers, rule) {
  const hiddenElements = [];
  for (const container of containers) {
    if (isMarked(container, sourceAtomicBlockElementMarkAttributeName)) {
      continue;
    }
    setAttribute(container, targetContainerElementAttributeName, "1");
    container.normalize();
    if (rule.lineBreakMaxTextCount > 0) {
      const treeFilter = (node) => {
        if (node.nodeType === Node.ELEMENT_NODE) {
          if (isExcludeElement(node, rule, true)) {
            return NodeFilter.FILTER_REJECT;
          }
        }
        if (node.nodeType === Node.TEXT_NODE) {
          const trimedText = node.textContent ? node.textContent.trim() : "";
          if (trimedText.length >= rule.lineBreakMaxTextCount) {
            addLineBreakToText(node, rule.lineBreakMaxTextCount);
          }
        }
        return NodeFilter.FILTER_ACCEPT;
      };
      const walk = document.createTreeWalker(
        container,
        NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
        treeFilter
      );
      while (walk.nextNode()) {
      }
    }
    const isExcludePre = rule.excludeTags.includes("PRE") || rule.additionalExcludeTags.includes("PRE");
    if (!isExcludePre && rule.isTransformPreTagNewLine) {
      const preTags = container.querySelectorAll("pre");
      for (const preTag of preTags) {
        formatPreHtml(preTag);
      }
    }
    if (rule.preWhitespaceDetectedTags.includes(container.tagName)) {
      if (!hasMark(container, sourcePreWhitespaceMarkAttributeName)) {
        if (isPreElementByStyle(container)) {
          setAttribute(container, sourcePreWhitespaceMarkAttributeName, "1");
          if (rule.isTransformPreTagNewLine) {
            formatPreHtml(container);
          }
        } else {
          setAttribute(container, sourcePreWhitespaceMarkAttributeName, "0");
        }
      }
    }
    wrapTextNode(
      0,
      container,
      rule,
      hiddenElements
    );
  }
  return {
    hiddenElements
  };
}
function wrapTextNode(depth, root2, rule, displayNoneElements = []) {
  if (isMarked(root2, sourceAtomicBlockElementMarkAttributeName)) {
    return;
  }
  let isSingleInlineElement = false;
  if (depth === 0) {
    const isStayOriginal = isStayOriginalElement(root2, rule);
    if (root2.childNodes && root2.childNodes.length === 1 && root2.nodeType === Node.ELEMENT_NODE && isInlineElement(
      root2,
      rule
    ) && !isStayOriginal) {
      isSingleInlineElement = true;
    }
  }
  if (root2 && root2.childNodes && root2.childNodes.length > 0) {
    for (const node of root2.childNodes) {
      if (node.nodeType === Node.ELEMENT_NODE) {
        if (!isExcludeElement(node, rule, false)) {
          const computedStyle = globalThis.getComputedStyle(
            node
          );
          let tempIsExcludeElement = false;
          if (computedStyle.display === "none") {
            displayNoneElements.push(node);
            tempIsExcludeElement = true;
          }
          if (!tempIsExcludeElement) {
            const clip = computedStyle.clip;
            const zIndex = computedStyle.zIndex;
            const height = computedStyle.height;
            const width = computedStyle.width;
            let formatedZIndex = 0;
            if (zIndex.startsWith("-")) {
              const zIndexNumber = parseInt(zIndex);
              if (!isNaN(zIndexNumber)) {
                formatedZIndex = zIndexNumber;
              }
            }
            if (clip === "rect(1px, 1px, 1px, 1px)" || formatedZIndex < 0) {
              tempIsExcludeElement = true;
            }
            if (!tempIsExcludeElement && node.nodeName !== "BR") {
              const heightNumber = parseInt(height);
              const widthNumber = parseInt(width);
              if (!isNaN(heightNumber) && !isNaN(widthNumber) && (heightNumber > 0 && heightNumber < 8 || widthNumber > 0 && widthNumber <= 8)) {
                tempIsExcludeElement = true;
              }
            }
          }
          if (tempIsExcludeElement) {
            setAttribute(
              node,
              sourceElementExcludeAttributeName,
              "1",
              true
            );
            continue;
          } else {
            if (isMatchTags(node.nodeName, ["DIV"])) {
              const nodeElement = node;
              if (node && nodeElement.style && nodeElement.style.display && nodeElement.style.display === "initial") {
                continue;
              }
              if (computedStyle.display === "inline" || computedStyle.display === "inline-flex") {
                if (!isMarked(
                  node,
                  sourceBlockElementMarkAttributeName
                )) {
                  setAttribute(
                    node,
                    sourceInlineElementMarkAttributeName,
                    "1"
                  );
                  continue;
                }
              }
            } else if (isMatchTags(node.nodeName, ["SPAN", "A"])) {
              if (!computedStyle.display.startsWith("inline")) {
                if (!isMarked(
                  node,
                  sourceInlineElementMarkAttributeName
                )) {
                  setAttribute(
                    node,
                    sourceBlockElementMarkAttributeName,
                    "1"
                  );
                  wrapTextNode(
                    depth + 1,
                    node,
                    rule,
                    displayNoneElements
                  );
                }
                continue;
              }
            } else if (isUnknowTag(node, rule)) {
              const isUnknownTagIsInlineElement = isInlineElement(
                node,
                rule
              );
              if (isUnknownTagIsInlineElement) {
                if (!isMarked(
                  node,
                  sourceBlockElementMarkAttributeName
                ) && !isMarked(
                  node,
                  sourceInlineElementMarkAttributeName
                )) {
                  setAttribute(
                    node,
                    sourceInlineElementMarkAttributeName,
                    "1"
                  );
                  continue;
                }
              } else {
                if (!isMarked(
                  node,
                  sourceBlockElementMarkAttributeName
                ) && !isMarked(
                  node,
                  sourceInlineElementMarkAttributeName
                )) {
                  setAttribute(
                    node,
                    sourceBlockElementMarkAttributeName,
                    "1"
                  );
                }
                continue;
              }
            }
            if (isInlineElement(node, rule) && !isSingleInlineElement) {
              continue;
            }
            wrapTextNode(
              depth + 1,
              node,
              rule,
              displayNoneElements
            );
          }
        } else {
          continue;
        }
      } else if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent;
        if (text && text.trim().length > 0) {
          const span = document.createElement("span");
          node.after(span);
          span.appendChild(node);
        }
      }
    }
  }
}
function isPreElementByStyle(element) {
  const style = window.getComputedStyle(element);
  return style.whiteSpace.startsWith("pre") || style.whiteSpace === "break-spaces";
}
function formatPreHtml(preElement) {
  const html = preElement.innerHTML;
  const newHtml = html.replace(/\n/g, "<br />");
  preElement.innerHTML = newHtml;
}
function addLineBreakToText(textNode, maxLength) {
  const text = textNode.textContent || "";
  const trimedText = text.trim();
  if (trimedText.length <= maxLength) {
    return;
  }
  const boundaries = [".", "?", "!", "\u3002", "\uFF1F", "\uFF01"];
  let boundaryIndex = boundaries.reduce((acc, boundary) => {
    const index = text.lastIndexOf(boundary, maxLength);
    return index > acc ? index : acc;
  }, -1);
  if (boundaryIndex === -1) {
    if (text.length > maxLength + 20) {
      addLineBreakToText(textNode, maxLength + 20);
    }
  } else {
    const theText = text.slice(boundaryIndex + 1);
    boundaryIndex++;
    if (theText.startsWith(" ")) {
      boundaryIndex++;
    }
    const theLastTextNode = textNode.splitText(boundaryIndex);
    const br = document.createElement("br");
    theLastTextNode.parentNode?.insertBefore(br, theLastTextNode);
    if (boundaryIndex + 1 < text.length) {
      addLineBreakToText(theLastTextNode, maxLength);
    }
  }
}

// dom/normalize_pdf_container.ts
function normalizeContainer2(containers, _rule) {
  let targetContainers = [];
  for (const container of containers) {
    let maxRight = 0;
    let minLeft = 1e5;
    const rightContainer = document.createElement("div");
    const treeFilter = (node) => {
      const element = node;
      if (isMatchTags(element.nodeName, ["DIV", "BR"])) {
        return NodeFilter.FILTER_REJECT;
      }
      if (element.classList.contains("markedContent")) {
        return NodeFilter.FILTER_ACCEPT;
      }
      if (isMatchTags(element.nodeName, ["SPAN"])) {
        const rect = element.getBoundingClientRect();
        const style = globalThis.getComputedStyle(element);
        const right = rect.right;
        const left = rect.left;
        const top = style.top.slice(0, -2);
        const fontsize = style.fontSize.slice(0, -2);
        if (right > maxRight) {
          maxRight = right;
        }
        if (left < minLeft) {
          minLeft = left;
        }
        setAttribute(element, sourceElementLeft, `${left}`);
        setAttribute(element, sourceElementRight, `${right}`);
        setAttribute(element, sourceElementTop, top);
        setAttribute(element, sourceElementFontSize, fontsize);
        return NodeFilter.FILTER_ACCEPT;
      } else {
        return NodeFilter.FILTER_ACCEPT;
      }
    };
    const walk = document.createTreeWalker(
      container,
      NodeFilter.SHOW_ELEMENT,
      treeFilter
    );
    while (walk.nextNode()) {
    }
    let realWidth = maxRight - minLeft;
    if (realWidth < 600) {
      realWidth = 600;
    }
    targetContainers.push(rightContainer);
    rightContainer.style.left = maxRight + "px";
    rightContainer.style.width = maxRight + "px";
    rightContainer.classList.add(translationPdfTargetContainerClass);
    if (container.childNodes.length > 0) {
      container.insertBefore(rightContainer, container.childNodes[0]);
    }
  }
  return { targetContainers };
}

// services/translation.ts
var Translation = class {
  constructor(serviceConfig, generalConfig) {
    this.maxTextLength = 1800;
    this.throttleLimit = 3;
    this.isSupportList = true;
    this.maxTextGroupLength = 200;
    this.serviceConfig = serviceConfig;
    this.generalConfig = generalConfig;
  }
  static getAllProps() {
    return [];
  }
  static getProps() {
    return [];
  }
  async init() {
  }
  getMaxTextGroupLength() {
    return this.maxTextGroupLength;
  }
  translate(_payload) {
    throw new Error("Not implemented");
  }
  translateList(_payload) {
    throw new Error("Not implemented");
  }
  async multipleTranslate(payload, options2, everySentenceCallback) {
    if (payload.sentences.length === 0) {
      return {
        sentences: []
      };
    }
    const { sentences } = payload;
    const respondedSentences = [];
    let tempSentenceGroups = [];
    let currentSentenceIndex = 0;
    const sent = /* @__PURE__ */ new Set();
    let globalError = null;
    const languages2 = /* @__PURE__ */ new Set();
    for (const sentence of sentences) {
      if (sentence.from && sentence.from !== "auto") {
        languages2.add(sentence.from);
      }
    }
    let isMultipleLanguage = false;
    if (languages2.size > 1) {
      isMultipleLanguage = true;
    }
    try {
      tempSentenceGroups = splitSentences(
        sentences,
        this.maxTextLength,
        this.maxTextGroupLength
      );
    } catch (e3) {
      if (everySentenceCallback) {
        if (sent.has(currentSentenceIndex)) {
          currentSentenceIndex++;
        }
        for (let i2 = currentSentenceIndex; i2 < sentences.length; i2++) {
          const sentence = sentences[i2];
          everySentenceCallback(e3, null, sentence);
        }
        globalError = e3;
      } else {
        globalError = e3;
      }
    }
    const throttle = m2({
      limit: this.throttleLimit,
      interval: 1e3
    });
    log_default.debug(
      "tempSentenceGroups",
      tempSentenceGroups.map((item) => {
        return item;
      })
    );
    for (let i2 = 0; i2 < tempSentenceGroups.length; i2++) {
      const tempSentenceGroup = tempSentenceGroups[i2];
      const url = tempSentenceGroup.url;
      const throttled = throttle(async () => {
        let finalFrom = tempSentenceGroup.from;
        if (isMultipleLanguage) {
          finalFrom = "auto";
        }
        if (tempSentenceGroup.fromByClient && tempSentenceGroup.fromByClient !== "auto") {
          finalFrom = tempSentenceGroup.fromByClient;
        }
        if (this.isSupportList) {
          const result2 = await this.translateList({
            text: tempSentenceGroup.tempSentences.map((item) => item.text),
            from: finalFrom,
            to: tempSentenceGroup.to,
            url,
            options: options2
          });
          return result2;
        } else {
          const mergedText = tempSentenceGroup.tempSentences.map(
            (item) => item.text
          ).join(translationTextSeparator);
          const result2 = await this.translate({
            text: mergedText,
            from: finalFrom,
            to: tempSentenceGroup.to,
            url,
            options: options2
          });
          const { text } = result2;
          const translatedTexts2 = text.split(
            translationTextSeparator
          );
          return {
            text: translatedTexts2,
            from: result2.from,
            to: result2.to
          };
        }
      });
      let result;
      try {
        result = await throttled();
      } catch (e3) {
        if (everySentenceCallback) {
          if (sent.has(currentSentenceIndex)) {
            currentSentenceIndex++;
          }
          for (let i3 = currentSentenceIndex; i3 < sentences.length; i3++) {
            const sentence = sentences[i3];
            everySentenceCallback(e3, null, sentence);
          }
          globalError = e3;
          continue;
        } else {
          globalError = e3;
          continue;
        }
      }
      const { text: translatedTexts } = result;
      for (let j5 = 0; j5 < translatedTexts.length; j5++) {
        try {
          const translatedText = translatedTexts[j5];
          const tempSentence = tempSentenceGroup.tempSentences[j5];
          const { index, prefix, suffix } = tempSentence;
          if (respondedSentences[index] === void 0) {
            respondedSentences[index] = {
              ...sentences[index],
              from: tempSentenceGroup.from,
              to: tempSentenceGroup.to,
              text: prefix + translatedText + suffix
            };
          } else {
            respondedSentences[index].text += prefix + translatedText + suffix;
          }
          if (index !== currentSentenceIndex) {
            if (everySentenceCallback) {
              sent.add(currentSentenceIndex);
              everySentenceCallback(
                null,
                respondedSentences[currentSentenceIndex],
                sentences[currentSentenceIndex]
              );
            }
          }
          currentSentenceIndex = index;
        } catch (e3) {
          if (everySentenceCallback) {
            if (sent.has(currentSentenceIndex)) {
              currentSentenceIndex++;
            }
            for (let i3 = currentSentenceIndex; i3 < sentences.length; i3++) {
              const sentence = sentences[i3];
              everySentenceCallback(e3, null, sentence);
            }
            throw e3;
          } else {
            throw e3;
          }
        }
      }
    }
    if (everySentenceCallback && !sent.has(currentSentenceIndex) && respondedSentences[currentSentenceIndex] && sentences[currentSentenceIndex]) {
      everySentenceCallback(
        null,
        respondedSentences[currentSentenceIndex],
        sentences[currentSentenceIndex]
      );
    }
    if (globalError) {
      throw globalError;
    }
    return {
      sentences: respondedSentences
    };
  }
  detectLanguageLocally(text) {
    return detectLanguage({
      text,
      minLength: 18
    });
  }
  detectLanguageRemotely(_text) {
    return Promise.resolve("auto");
  }
  detectLanguage(text) {
    if (text.length >= 50) {
      return this.detectLanguageLocally(text);
    } else {
      return this.detectLanguageRemotely(text);
    }
  }
};

// libs/sha256.js
var ERROR = "input is invalid type";
var WINDOW = typeof window === "object";
var root = WINDOW ? window : {};
if (root.JS_SHA256_NO_WINDOW) {
  WINDOW = false;
}
var WEB_WORKER = !WINDOW && typeof self === "object";
var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
if (NODE_JS) {
  root = global;
} else if (WEB_WORKER) {
  root = self;
}
var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
var AMD = typeof define === "function" && define.amd;
var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
var HEX_CHARS = "0123456789abcdef".split("");
var EXTRA = [-2147483648, 8388608, 32768, 128];
var SHIFT = [24, 16, 8, 0];
var K5 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
var blocks = [];
if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
  Array.isArray = function(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  };
}
if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
  ArrayBuffer.isView = function(obj) {
    return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
  };
}
var createOutputMethod = function(outputType, is224) {
  return function(message) {
    return new Sha256(is224, true).update(message)[outputType]();
  };
};
var createMethod = function(is224) {
  var method = createOutputMethod("hex", is224);
  method.create = function() {
    return new Sha256(is224);
  };
  method.update = function(message) {
    return method.create().update(message);
  };
  for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
    var type = OUTPUT_TYPES[i2];
    method[type] = createOutputMethod(type, is224);
  }
  return method;
};
var createHmacOutputMethod = function(outputType, is224) {
  return function(key, message) {
    return new HmacSha256(key, is224, true).update(message)[outputType]();
  };
};
var createHmacMethod = function(is224) {
  var method = createHmacOutputMethod("hex", is224);
  method.create = function(key) {
    return new HmacSha256(key, is224);
  };
  method.update = function(key, message) {
    return method.create(key).update(message);
  };
  for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
    var type = OUTPUT_TYPES[i2];
    method[type] = createHmacOutputMethod(type, is224);
  }
  return method;
};
function Sha256(is224, sharedMemory) {
  if (sharedMemory) {
    blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
    this.blocks = blocks;
  } else {
    this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  }
  if (is224) {
    this.h0 = 3238371032;
    this.h1 = 914150663;
    this.h2 = 812702999;
    this.h3 = 4144912697;
    this.h4 = 4290775857;
    this.h5 = 1750603025;
    this.h6 = 1694076839;
    this.h7 = 3204075428;
  } else {
    this.h0 = 1779033703;
    this.h1 = 3144134277;
    this.h2 = 1013904242;
    this.h3 = 2773480762;
    this.h4 = 1359893119;
    this.h5 = 2600822924;
    this.h6 = 528734635;
    this.h7 = 1541459225;
  }
  this.block = this.start = this.bytes = this.hBytes = 0;
  this.finalized = this.hashed = false;
  this.first = true;
  this.is224 = is224;
}
Sha256.prototype.update = function(message) {
  if (this.finalized) {
    return;
  }
  var notString, type = typeof message;
  if (type !== "string") {
    if (type === "object") {
      if (message === null) {
        throw new Error(ERROR);
      } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
        message = new Uint8Array(message);
      } else if (!Array.isArray(message)) {
        if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
          throw new Error(ERROR);
        }
      }
    } else {
      throw new Error(ERROR);
    }
    notString = true;
  }
  var code2, index = 0, i2, length = message.length, blocks2 = this.blocks;
  while (index < length) {
    if (this.hashed) {
      this.hashed = false;
      blocks2[0] = this.block;
      blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
    }
    if (notString) {
      for (i2 = this.start; index < length && i2 < 64; ++index) {
        blocks2[i2 >> 2] |= message[index] << SHIFT[i2++ & 3];
      }
    } else {
      for (i2 = this.start; index < length && i2 < 64; ++index) {
        code2 = message.charCodeAt(index);
        if (code2 < 128) {
          blocks2[i2 >> 2] |= code2 << SHIFT[i2++ & 3];
        } else if (code2 < 2048) {
          blocks2[i2 >> 2] |= (192 | code2 >> 6) << SHIFT[i2++ & 3];
          blocks2[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
        } else if (code2 < 55296 || code2 >= 57344) {
          blocks2[i2 >> 2] |= (224 | code2 >> 12) << SHIFT[i2++ & 3];
          blocks2[i2 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i2++ & 3];
          blocks2[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
        } else {
          code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index) & 1023);
          blocks2[i2 >> 2] |= (240 | code2 >> 18) << SHIFT[i2++ & 3];
          blocks2[i2 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i2++ & 3];
          blocks2[i2 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i2++ & 3];
          blocks2[i2 >> 2] |= (128 | code2 & 63) << SHIFT[i2++ & 3];
        }
      }
    }
    this.lastByteIndex = i2;
    this.bytes += i2 - this.start;
    if (i2 >= 64) {
      this.block = blocks2[16];
      this.start = i2 - 64;
      this.hash();
      this.hashed = true;
    } else {
      this.start = i2;
    }
  }
  if (this.bytes > 4294967295) {
    this.hBytes += this.bytes / 4294967296 << 0;
    this.bytes = this.bytes % 4294967296;
  }
  return this;
};
Sha256.prototype.finalize = function() {
  if (this.finalized) {
    return;
  }
  this.finalized = true;
  var blocks2 = this.blocks, i2 = this.lastByteIndex;
  blocks2[16] = this.block;
  blocks2[i2 >> 2] |= EXTRA[i2 & 3];
  this.block = blocks2[16];
  if (i2 >= 56) {
    if (!this.hashed) {
      this.hash();
    }
    blocks2[0] = this.block;
    blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
  }
  blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
  blocks2[15] = this.bytes << 3;
  this.hash();
};
Sha256.prototype.hash = function() {
  var a4 = this.h0, b4 = this.h1, c3 = this.h2, d3 = this.h3, e3 = this.h4, f4 = this.h5, g5 = this.h6, h3 = this.h7, blocks2 = this.blocks, j5, s0, s1, maj, t1, t22, ch, ab, da, cd, bc;
  for (j5 = 16; j5 < 64; ++j5) {
    t1 = blocks2[j5 - 15];
    s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
    t1 = blocks2[j5 - 2];
    s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
    blocks2[j5] = blocks2[j5 - 16] + s0 + blocks2[j5 - 7] + s1 << 0;
  }
  bc = b4 & c3;
  for (j5 = 0; j5 < 64; j5 += 4) {
    if (this.first) {
      if (this.is224) {
        ab = 300032;
        t1 = blocks2[0] - 1413257819;
        h3 = t1 - 150054599 << 0;
        d3 = t1 + 24177077 << 0;
      } else {
        ab = 704751109;
        t1 = blocks2[0] - 210244248;
        h3 = t1 - 1521486534 << 0;
        d3 = t1 + 143694565 << 0;
      }
      this.first = false;
    } else {
      s0 = (a4 >>> 2 | a4 << 30) ^ (a4 >>> 13 | a4 << 19) ^ (a4 >>> 22 | a4 << 10);
      s1 = (e3 >>> 6 | e3 << 26) ^ (e3 >>> 11 | e3 << 21) ^ (e3 >>> 25 | e3 << 7);
      ab = a4 & b4;
      maj = ab ^ a4 & c3 ^ bc;
      ch = e3 & f4 ^ ~e3 & g5;
      t1 = h3 + s1 + ch + K5[j5] + blocks2[j5];
      t22 = s0 + maj;
      h3 = d3 + t1 << 0;
      d3 = t1 + t22 << 0;
    }
    s0 = (d3 >>> 2 | d3 << 30) ^ (d3 >>> 13 | d3 << 19) ^ (d3 >>> 22 | d3 << 10);
    s1 = (h3 >>> 6 | h3 << 26) ^ (h3 >>> 11 | h3 << 21) ^ (h3 >>> 25 | h3 << 7);
    da = d3 & a4;
    maj = da ^ d3 & b4 ^ ab;
    ch = h3 & e3 ^ ~h3 & f4;
    t1 = g5 + s1 + ch + K5[j5 + 1] + blocks2[j5 + 1];
    t22 = s0 + maj;
    g5 = c3 + t1 << 0;
    c3 = t1 + t22 << 0;
    s0 = (c3 >>> 2 | c3 << 30) ^ (c3 >>> 13 | c3 << 19) ^ (c3 >>> 22 | c3 << 10);
    s1 = (g5 >>> 6 | g5 << 26) ^ (g5 >>> 11 | g5 << 21) ^ (g5 >>> 25 | g5 << 7);
    cd = c3 & d3;
    maj = cd ^ c3 & a4 ^ da;
    ch = g5 & h3 ^ ~g5 & e3;
    t1 = f4 + s1 + ch + K5[j5 + 2] + blocks2[j5 + 2];
    t22 = s0 + maj;
    f4 = b4 + t1 << 0;
    b4 = t1 + t22 << 0;
    s0 = (b4 >>> 2 | b4 << 30) ^ (b4 >>> 13 | b4 << 19) ^ (b4 >>> 22 | b4 << 10);
    s1 = (f4 >>> 6 | f4 << 26) ^ (f4 >>> 11 | f4 << 21) ^ (f4 >>> 25 | f4 << 7);
    bc = b4 & c3;
    maj = bc ^ b4 & d3 ^ cd;
    ch = f4 & g5 ^ ~f4 & h3;
    t1 = e3 + s1 + ch + K5[j5 + 3] + blocks2[j5 + 3];
    t22 = s0 + maj;
    e3 = a4 + t1 << 0;
    a4 = t1 + t22 << 0;
  }
  this.h0 = this.h0 + a4 << 0;
  this.h1 = this.h1 + b4 << 0;
  this.h2 = this.h2 + c3 << 0;
  this.h3 = this.h3 + d3 << 0;
  this.h4 = this.h4 + e3 << 0;
  this.h5 = this.h5 + f4 << 0;
  this.h6 = this.h6 + g5 << 0;
  this.h7 = this.h7 + h3 << 0;
};
Sha256.prototype.hex = function() {
  this.finalize();
  var h0 = this.h0, h1 = this.h1, h22 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
  var hex2 = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h22 >> 28 & 15] + HEX_CHARS[h22 >> 24 & 15] + HEX_CHARS[h22 >> 20 & 15] + HEX_CHARS[h22 >> 16 & 15] + HEX_CHARS[h22 >> 12 & 15] + HEX_CHARS[h22 >> 8 & 15] + HEX_CHARS[h22 >> 4 & 15] + HEX_CHARS[h22 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
  if (!this.is224) {
    hex2 += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
  }
  return hex2;
};
Sha256.prototype.toString = Sha256.prototype.hex;
Sha256.prototype.digest = function() {
  this.finalize();
  var h0 = this.h0, h1 = this.h1, h22 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
  var arr = [
    h0 >> 24 & 255,
    h0 >> 16 & 255,
    h0 >> 8 & 255,
    h0 & 255,
    h1 >> 24 & 255,
    h1 >> 16 & 255,
    h1 >> 8 & 255,
    h1 & 255,
    h22 >> 24 & 255,
    h22 >> 16 & 255,
    h22 >> 8 & 255,
    h22 & 255,
    h3 >> 24 & 255,
    h3 >> 16 & 255,
    h3 >> 8 & 255,
    h3 & 255,
    h4 >> 24 & 255,
    h4 >> 16 & 255,
    h4 >> 8 & 255,
    h4 & 255,
    h5 >> 24 & 255,
    h5 >> 16 & 255,
    h5 >> 8 & 255,
    h5 & 255,
    h6 >> 24 & 255,
    h6 >> 16 & 255,
    h6 >> 8 & 255,
    h6 & 255
  ];
  if (!this.is224) {
    arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
  }
  return arr;
};
Sha256.prototype.array = Sha256.prototype.digest;
Sha256.prototype.arrayBuffer = function() {
  this.finalize();
  var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
  var dataView = new DataView(buffer);
  dataView.setUint32(0, this.h0);
  dataView.setUint32(4, this.h1);
  dataView.setUint32(8, this.h2);
  dataView.setUint32(12, this.h3);
  dataView.setUint32(16, this.h4);
  dataView.setUint32(20, this.h5);
  dataView.setUint32(24, this.h6);
  if (!this.is224) {
    dataView.setUint32(28, this.h7);
  }
  return buffer;
};
function HmacSha256(key, is224, sharedMemory) {
  var i2, type = typeof key;
  if (type === "string") {
    var bytes = [], length = key.length, index = 0, code2;
    for (i2 = 0; i2 < length; ++i2) {
      code2 = key.charCodeAt(i2);
      if (code2 < 128) {
        bytes[index++] = code2;
      } else if (code2 < 2048) {
        bytes[index++] = 192 | code2 >> 6;
        bytes[index++] = 128 | code2 & 63;
      } else if (code2 < 55296 || code2 >= 57344) {
        bytes[index++] = 224 | code2 >> 12;
        bytes[index++] = 128 | code2 >> 6 & 63;
        bytes[index++] = 128 | code2 & 63;
      } else {
        code2 = 65536 + ((code2 & 1023) << 10 | key.charCodeAt(++i2) & 1023);
        bytes[index++] = 240 | code2 >> 18;
        bytes[index++] = 128 | code2 >> 12 & 63;
        bytes[index++] = 128 | code2 >> 6 & 63;
        bytes[index++] = 128 | code2 & 63;
      }
    }
    key = bytes;
  } else {
    if (type === "object") {
      if (key === null) {
        throw new Error(ERROR);
      } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
        key = new Uint8Array(key);
      } else if (!Array.isArray(key)) {
        if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
          throw new Error(ERROR);
        }
      }
    } else {
      throw new Error(ERROR);
    }
  }
  if (key.length > 64) {
    key = new Sha256(is224, true).update(key).array();
  }
  var oKeyPad = [], iKeyPad = [];
  for (i2 = 0; i2 < 64; ++i2) {
    var b4 = key[i2] || 0;
    oKeyPad[i2] = 92 ^ b4;
    iKeyPad[i2] = 54 ^ b4;
  }
  Sha256.call(this, is224, sharedMemory);
  this.update(iKeyPad);
  this.oKeyPad = oKeyPad;
  this.inner = true;
  this.sharedMemory = sharedMemory;
}
HmacSha256.prototype = new Sha256();
HmacSha256.prototype.finalize = function() {
  Sha256.prototype.finalize.call(this);
  if (this.inner) {
    this.inner = false;
    var innerHash = this.array();
    Sha256.call(this, this.is224, this.sharedMemory);
    this.update(this.oKeyPad);
    this.update(innerHash);
    Sha256.prototype.finalize.call(this);
  }
};
var exports = createMethod();
exports.sha256 = exports;
exports.sha224 = createMethod(true);
exports.sha256.hmac = createHmacMethod();
exports.sha224.hmac = createHmacMethod(true);
var sha256_default = exports;

// utils/sha256.ts
var sha256Fn = sha256_default.sha256;
function sha256(message) {
  return Promise.resolve(sha256Fn(message));
}
function hex(hashBuffer) {
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map((b4) => b4.toString(16).padStart(2, "0")).join(
    ""
  );
  return hashHex;
}
function hmacSha256(str, keyString) {
  const hash = sha256Fn.hmac.create(keyString);
  hash.update(str);
  return Promise.resolve(hash.array());
}
async function hmacSha256ByString(str, keyString) {
  const sig = await hmacSha256(str, keyString);
  return hex(sig);
}
async function hmacSha256ByArrayBuffer(str, keyString) {
  const buffer = decodeHex(keyString);
  const sig = await hmacSha256(str, buffer);
  return hex(sig);
}
function decodeHex(string) {
  const bytes = [];
  string.replace(/../g, function(pair) {
    bytes.push(parseInt(pair, 16));
    return "";
  });
  return new Uint8Array(bytes).buffer;
}

// services/tencent.ts
var langMap2 = [
  ["auto", "auto"],
  ["zh-CN", "zh"],
  ["zh-TW", "zh-TW"],
  ["de", "de"],
  ["en", "en"],
  ["es", "es"],
  ["fr", "fr"],
  ["id", "id"],
  ["it", "it"],
  ["ja", "jp"],
  ["ko", "kr"],
  ["ms", "ms"],
  ["pt", "pt"],
  ["ru", "ru"],
  ["th", "th"],
  ["tr", "tr"],
  ["vi", "vi"]
];
var _Tencent = class extends Translation {
  constructor(serviceConfig, generalConfig) {
    super(serviceConfig, generalConfig);
    this.secretId = "";
    this.secretKey = "";
    this.isSupportList = true;
    if (!serviceConfig || !serviceConfig.secretId || !serviceConfig.secretKey) {
      throw new Error("secretId and secretKey are required");
    }
    this.secretId = serviceConfig.secretId?.trim();
    this.secretKey = serviceConfig.secretKey?.trim();
  }
  static getUTCDate(dateObj) {
    const year = dateObj.getUTCFullYear();
    const month = `${dateObj.getUTCMonth() + 1}`.padStart(2, "0");
    const date = `${dateObj.getUTCDate()}`.padStart(2, "0");
    return `${year}-${month}-${date}`;
  }
  static getAllProps() {
    return [{
      name: "secretId",
      required: true,
      type: "text"
    }, {
      name: "secretKey",
      required: true,
      type: "password"
    }];
  }
  async translate(payload) {
    const { text, from, to } = payload;
    const RequestPayload = JSON.stringify({
      ProjectId: 0,
      Source: _Tencent.langMap.get(from) || "auto",
      SourceText: text,
      Target: _Tencent.langMap.get(to) || to
    });
    const data = await this.signedRequest({
      secretId: this.secretId,
      secretKey: this.secretKey,
      action: "TextTranslate",
      payload: RequestPayload,
      service: "tmt",
      version: "2018-03-21"
    });
    return {
      text: data.Response.TargetText,
      from: _Tencent.langMapReverse.get(data.Response.Source) || from,
      to: _Tencent.langMapReverse.get(data.Response.Target) || to
    };
  }
  async translateList(payload) {
    const { text, from, to } = payload;
    const RequestPayload = JSON.stringify({
      ProjectId: 0,
      Source: _Tencent.langMap.get(from) || "auto",
      SourceTextList: text,
      Target: _Tencent.langMap.get(to) || to
    });
    const data = await this.signedRequest({
      secretId: this.secretId,
      secretKey: this.secretKey,
      action: "TextTranslateBatch",
      payload: RequestPayload,
      service: "tmt",
      version: "2018-03-21"
    });
    return {
      text: data.Response.TargetTextList,
      from: _Tencent.langMapReverse.get(data.Response.Source) || from,
      to: _Tencent.langMapReverse.get(data.Response.Target) || to
    };
  }
  async signedRequest({
    secretId,
    secretKey,
    action,
    payload,
    service,
    version
  }) {
    const host = `${service}.tencentcloudapi.com`;
    const now = /* @__PURE__ */ new Date();
    const timestamp = `${(/* @__PURE__ */ new Date()).valueOf()}`.slice(0, 10);
    const CanonicalRequest = [
      "POST",
      "/",
      "",
      "content-type:application/json; charset=utf-8",
      `host:${host}`,
      "",
      "content-type;host",
      await sha256(payload)
    ].join("\n");
    const datestamp = _Tencent.getUTCDate(now);
    const StringToSign = [
      "TC3-HMAC-SHA256",
      timestamp,
      `${datestamp}/${service}/tc3_request`,
      await sha256(CanonicalRequest)
    ].join("\n");
    const SecretDate = await hmacSha256ByString(datestamp, `TC3${secretKey}`);
    const SecretService = await hmacSha256ByArrayBuffer(
      service,
      SecretDate
    );
    const SecretSigning = await hmacSha256ByArrayBuffer(
      "tc3_request",
      SecretService
    );
    const Signature = await hmacSha256ByArrayBuffer(
      StringToSign,
      SecretSigning
    );
    const response = await request2({
      retry: 2,
      url: `https://${service}.tencentcloudapi.com`,
      method: "POST",
      headers: {
        "Content-Type": "application/json; charset=utf-8",
        Host: host,
        "X-TC-Action": action,
        "X-TC-Timestamp": timestamp,
        "X-TC-Region": "ap-beijing",
        "X-TC-Version": version,
        Authorization: `TC3-HMAC-SHA256 Credential=${secretId}/${datestamp}/${service}/tc3_request, SignedHeaders=content-type;host, Signature=${Signature}`
      },
      body: payload
    });
    if (response instanceof Error) {
      throw response;
    } else {
      if (response.Response && response.Response.Error && response.Response.Error.Message) {
        throw new Error(
          response.Response.Error.Message
        );
      } else {
        return response;
      }
    }
  }
};
var Tencent = _Tencent;
/** Translator lang to custom lang */
Tencent.langMap = new Map(langMap2);
/** Custom lang to translator lang */
Tencent.langMapReverse = new Map(
  langMap2.map(([translatorLang, lang]) => [lang, translatorLang])
);

// services/google.ts
var langMap3 = [
  ["auto", "auto"],
  ["zh-CN", "zh-CN"],
  ["zh-TW", "zh-TW"],
  ["en", "en"],
  ["af", "af"],
  ["am", "am"],
  ["ar", "ar"],
  ["az", "az"],
  ["be", "be"],
  ["bg", "bg"],
  ["bn", "bn"],
  ["bs", "bs"],
  ["ca", "ca"],
  ["ceb", "ceb"],
  ["co", "co"],
  ["cs", "cs"],
  ["cy", "cy"],
  ["da", "da"],
  ["de", "de"],
  ["el", "el"],
  ["eo", "eo"],
  ["es", "es"],
  ["et", "et"],
  ["eu", "eu"],
  ["fa", "fa"],
  ["fi", "fi"],
  ["fr", "fr"],
  ["fy", "fy"],
  ["ga", "ga"],
  ["gd", "gd"],
  ["gl", "gl"],
  ["gu", "gu"],
  ["ha", "ha"],
  ["haw", "haw"],
  ["he", "he"],
  ["hi", "hi"],
  ["hmn", "hmn"],
  ["hr", "hr"],
  ["ht", "ht"],
  ["hu", "hu"],
  ["hy", "hy"],
  ["id", "id"],
  ["ig", "ig"],
  ["is", "is"],
  ["it", "it"],
  ["ja", "ja"],
  ["jw", "jw"],
  ["ka", "ka"],
  ["kk", "kk"],
  ["km", "km"],
  ["kn", "kn"],
  ["ko", "ko"],
  ["ku", "ku"],
  ["ky", "ky"],
  ["la", "la"],
  ["lb", "lb"],
  ["lo", "lo"],
  ["lt", "lt"],
  ["lv", "lv"],
  ["mg", "mg"],
  ["mi", "mi"],
  ["mk", "mk"],
  ["ml", "ml"],
  ["mn", "mn"],
  ["mr", "mr"],
  ["ms", "ms"],
  ["mt", "mt"],
  ["my", "my"],
  ["ne", "ne"],
  ["nl", "nl"],
  ["no", "no"],
  ["ny", "ny"],
  ["pa", "pa"],
  ["pl", "pl"],
  ["ps", "ps"],
  ["pt", "pt"],
  ["ro", "ro"],
  ["ru", "ru"],
  ["sd", "sd"],
  ["si", "si"],
  ["sk", "sk"],
  ["sl", "sl"],
  ["sm", "sm"],
  ["sn", "sn"],
  ["so", "so"],
  ["sq", "sq"],
  ["sr", "sr"],
  ["st", "st"],
  ["su", "su"],
  ["sv", "sv"],
  ["sw", "sw"],
  ["ta", "ta"],
  ["te", "te"],
  ["tg", "tg"],
  ["th", "th"],
  ["fil", "tl"],
  ["tr", "tr"],
  ["ug", "ug"],
  ["uk", "uk"],
  ["ur", "ur"],
  ["uz", "uz"],
  ["vi", "vi"],
  ["xh", "xh"],
  ["yi", "yi"],
  ["yo", "yo"],
  ["zu", "zu"]
];
var _Google = class extends Translation {
  constructor(serviceConfig, generalConfig) {
    super(serviceConfig, generalConfig);
    this.isSupportList = false;
    this.throttleLimit = 100;
    this.apiUrl = "https://translate.googleapis.com/translate_a/single";
    if (serviceConfig && serviceConfig.apiUrl) {
      this.apiUrl = mergeUrl(this.apiUrl, serviceConfig.apiUrl);
    }
  }
  async translate(payload) {
    const { text, from, to } = payload;
    if (!text)
      return { ...payload };
    const adaptedFrom = _Google.langMap.get(from) || "auto";
    const adaptedTo = _Google.langMap.get(to) || to;
    const result = await this.fetchWithoutToken(text, adaptedFrom, adaptedTo);
    if (!result) {
      throw new Error("google translate NETWORK_ERROR");
    }
    if (!result.data[0] || result.data[0].length <= 0) {
      throw new Error("google translate API_SERVER_ERROR");
    }
    const transText = result.data[0].map((item) => item[0]).filter(Boolean).join("");
    return {
      text: transText,
      from: _Google.langMapReverse.get(result.data[2]) || "auto",
      to
    };
  }
  async fetchWithoutToken(text, from, to) {
    const params = new URLSearchParams({
      client: "gtx",
      dt: "t",
      sl: from,
      tl: to,
      q: text
    });
    const url = `https://translate.googleapis.com/translate_a/single?` + params.toString();
    const response = await request2({
      retry: 2,
      url
    });
    return { data: response };
  }
};
var Google = _Google;
Google.langMap = new Map(langMap3);
Google.langMapReverse = new Map(
  langMap3.map(([translatorLang, lang]) => [lang, translatorLang])
);

// services/d/extractors.ts
function extractSplitSentences(response) {
  return response.result.texts;
}

// services/d/hacks.ts
function calculateValidTimestamp(timestamp, iCount) {
  return iCount ? timestamp + (iCount - timestamp % iCount) : timestamp;
}
function count(sentence, part) {
  return sentence.split(part).length - 1;
}
function generateTimestamp(sentences) {
  const now = Date.now();
  let iCount = 1;
  for (const sentence of sentences) {
    iCount += count(sentence, "i");
  }
  return calculateValidTimestamp(now, iCount);
}
function randRange(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function generateId() {
  const MIN = 1e6;
  const MAX = 1e8;
  return randRange(MIN, MAX);
}

// services/d/settings.ts
var API_URL = "https://www2.deepl.com/jsonrpc";
var AUTO = "auto";
var SUPPORTED_LANGUAGES = [
  { code: "BG", language: "Bulgarian" },
  { code: "ZH", language: "Chinese" },
  { code: "CS", language: "Czech" },
  { code: "DA", language: "Danish" },
  { code: "NL", language: "Dutch" },
  { code: "EN", language: "English" },
  { code: "ET", language: "Estonian" },
  { code: "FI", language: "Finnish" },
  { code: "FR", language: "French" },
  { code: "DE", language: "German" },
  { code: "EL", language: "Greek" },
  { code: "HU", language: "Hungarian" },
  { code: "IT", language: "Italian" },
  { code: "JA", language: "Japanese" },
  { code: "LV", language: "Latvian" },
  { code: "LT", language: "Lithuanian" },
  { code: "PL", language: "Polish" },
  { code: "PT", language: "Portuguese" },
  { code: "RO", language: "Romanian" },
  { code: "RU", language: "Russian" },
  { code: "SK", language: "Slovak" },
  { code: "SL", language: "Slovenian" },
  { code: "ES", language: "Spanish" },
  { code: "SV", language: "Swedish" }
];
var SUPPORTED_FORMALITY_TONES = ["formal", "informal"];

// services/d/generators.ts
function generateSplitSentencesRequestData(text, sourceLanguage = AUTO, identifier = generateId()) {
  return {
    jsonrpc: "2.0",
    method: "LMT_split_text",
    params: {
      commonJobParams: { "mode": "translate" },
      lang: {
        lang_user_selected: sourceLanguage,
        user_preferred_langs: []
      },
      texts: text
    },
    id: identifier
  };
}
function generateJobs(sentences, beams = 1) {
  const jobs = [];
  let id = 0;
  for (let i2 = 0; i2 < sentences.length; i2++) {
    const chunks = sentences[i2].chunks;
    for (let j5 = 0; j5 < chunks.length; j5++) {
      const chunk = chunks[j5];
      jobs.push({
        kind: "default",
        _index: i2,
        // raw_en_sentence: sentence,
        sentences: [{
          id,
          text: chunk.sentences[0].text,
          prefix: chunk.sentences[0].prefix
        }],
        raw_en_context_before: chunks.slice(0, id).map(
          (chunk2) => chunk2.sentences[0].text
        ),
        raw_en_context_after: id + 1 < chunks.length ? [chunks[id + 1].sentences[0].text] : [],
        preferred_num_beams: beams
      });
      id++;
    }
  }
  return jobs;
}
function splitedResultToArray(sentences) {
  return sentences.reduce((jobs, sentence) => {
    const chunks = sentence.chunks;
    for (const chunk of chunks) {
      jobs.push(chunk.sentences[0].text);
    }
    return jobs;
  }, []);
}
function generateCommonJobParams(formality) {
  if (!formality) {
    return {};
  }
  if (!SUPPORTED_FORMALITY_TONES.includes(formality)) {
    throw new Error("Formality tone '{formality_tone}' not supported.");
  }
  return { formality };
}
function generateTranslationRequestData(sourceLanguage, targetLanguage, sentences, identifier = generateId(), alternatives = 1, formality) {
  const allSentences = splitedResultToArray(sentences);
  return {
    jsonrpc: "2.0",
    method: "LMT_handle_jobs",
    params: {
      jobs: generateJobs(sentences, alternatives),
      lang: {
        user_preferred_langs: [targetLanguage, sourceLanguage],
        source_lang_computed: sourceLanguage,
        target_lang: targetLanguage
      },
      priority: 1,
      commonJobParams: generateCommonJobParams(formality),
      timestamp: generateTimestamp(splitedResultToArray(sentences))
    },
    id: identifier
  };
}

// services/d/utils.ts
function createAbbreviationsDictionary(languages2 = SUPPORTED_LANGUAGES) {
  return languages2.reduce((acc, lang) => {
    acc[lang.code.toLowerCase()] = lang.code;
    acc[lang.language.toLowerCase()] = lang.code;
    return acc;
  }, {});
}
function abbreviateLanguage(language) {
  return createAbbreviationsDictionary()[language.toLowerCase()];
}

// services/d/api.ts
var headers = {
  Accept: "*/*",
  "Accept-Language": "en-US;q=0.8,en;q=0.7",
  "Content-Type": "application/json",
  Origin: "https://www.deepl.com",
  Referer: "https://www.deepl.com/translator",
  "Sec-Fetch-Dest": "empty",
  "Sec-Fetch-Mode": "cors",
  "Sec-Fetch-Site": "same-site"
};
function stringifyJson(object) {
  return JSON.stringify(object).replace('"method":"', () => {
    const self2 = object;
    if ((self2.id + 3) % 13 === 0 || (self2.id + 5) % 29 === 0) {
      return '"method" : "';
    }
    return '"method": "';
  });
}
async function splitSentences2(API_URL2, text, sourceLanguage, identifier) {
  const data = generateSplitSentencesRequestData(
    text,
    sourceLanguage,
    identifier
  );
  return await request2(
    {
      retry: 2,
      method: "POST",
      url: API_URL2 + "?method=LMT_split_text",
      headers,
      body: stringifyJson(data)
    }
  );
}
async function requestTranslation(API_URL2, text, targetLanguage, sourceLanguage, identifier, alternatives, formalityTone) {
  const splitResult = await splitSentences2(
    API_URL2,
    text,
    sourceLanguage,
    identifier
  );
  const data = generateTranslationRequestData(
    sourceLanguage === "auto" ? splitResult.result.lang.detected : sourceLanguage,
    targetLanguage,
    extractSplitSentences(splitResult),
    identifier,
    alternatives,
    formalityTone
  );
  const jobsIndexes = data.params.jobs.map((job) => job._index);
  data.params.jobs = data.params.jobs.map((job) => {
    const newJob = { ...job };
    delete newJob._index;
    return newJob;
  });
  const response = await request2({
    retry: 2,
    method: "POST",
    url: API_URL2 + "?method=LMT_handle_jobs",
    body: stringifyJson(data),
    headers
  });
  const finalResult = {
    from: splitResult.result.lang.detected,
    to: targetLanguage,
    text: []
  };
  response.result.translations.forEach((translation, index) => {
    const jobIndex = jobsIndexes[index];
    if (finalResult.text[jobIndex] === void 0) {
      finalResult.text[jobIndex] = "";
    }
    const originalSentencePrefix = data.params.jobs[index].sentences[0].prefix;
    const originalSentencePre = data.params.jobs[index].sentences[0].prefix;
    finalResult.text[jobIndex] = finalResult.text[jobIndex] + originalSentencePrefix + translation.beams[0].sentences[0].text;
  });
  return finalResult;
}
async function translate(API_URL2, text, targetLanguage, sourceLanguage = AUTO, identifier, alternatives, formalityTone) {
  if (!text) {
    return {
      text: [],
      from: sourceLanguage,
      to: targetLanguage
    };
  }
  if (text && text.length === 1) {
    if (text[0] === "") {
      return {
        text: [""],
        from: sourceLanguage,
        to: targetLanguage
      };
    }
  }
  const response = requestTranslation(
    API_URL2,
    text,
    abbreviateLanguage(targetLanguage),
    abbreviateLanguage(sourceLanguage) ?? "auto",
    identifier,
    alternatives,
    formalityTone
  );
  return response;
}

// services/d/mod.ts
var langMap4 = [
  ["auto", "auto"],
  ["zh-CN", "ZH"],
  ["zh-TW", "ZH"],
  ["de", "DE"],
  ["en", "EN"],
  ["es", "ES"],
  ["fr", "FR"],
  ["it", "IT"],
  ["ja", "JA"],
  ["pt", "PT"],
  ["ru", "RU"],
  ["tr", "tr"]
];
var _D = class extends Translation {
  constructor(serviceConfig, generalConfig) {
    super(serviceConfig, generalConfig);
    this.maxTextGroupLength = 3;
    this.maxTextLength = 800;
    this.isSupportList = true;
    this.API_URL = API_URL;
    if (serviceConfig && serviceConfig.apiUrl) {
      this.API_URL = mergeUrl(API_URL, serviceConfig.apiUrl);
    }
  }
  async translateList(payload) {
    const { text, to, from } = payload;
    const result = await translate(
      this.API_URL,
      text,
      _D.langMap.get(to) || to,
      _D.langMap.get(from) || "auto"
    );
    return {
      text: result.text,
      from: _D.langMapReverse.get(result.from),
      to: _D.langMapReverse.get(result.to)
    };
  }
};
var D8 = _D;
/** Translator lang to custom lang */
D8.langMap = new Map(langMap4);
/** Custom lang to translator lang */
D8.langMapReverse = new Map(
  langMap4.map(([translatorLang, lang]) => [lang, translatorLang])
);

// services/transmart.ts
var langMap5 = [
  ["auto", "auto"],
  ["zh-CN", "zh"],
  ["zh-TW", "zh-TW"],
  ["de", "de"],
  ["en", "en"],
  ["es", "es"],
  ["fr", "fr"],
  ["id", "id"],
  ["it", "it"],
  ["ja", "ja"],
  ["ko", "kr"],
  ["ms", "ms"],
  ["pt", "pt"],
  ["ru", "ru"],
  ["th", "th"],
  ["tr", "tr"],
  ["vi", "vi"]
];
var API = "https://transmart.qq.com/api/imt";
var _Transmart = class extends Translation {
  constructor(serviceConfig, generalConfig) {
    super(serviceConfig, generalConfig);
    this.maxTextGroupLength = 50;
    this.maxTextLength = 1e3;
    this.throttleLimit = 1e3;
    this.isSupportList = false;
    this.clientKey = btoa(
      "transmart_crx_" + navigator.userAgent
    ).slice(0, 100);
  }
  async translate(payload) {
    const { text, to } = payload;
    const sourceLanguage = await this.detectLanguage(text);
    const remoteSourceLanguage = _Transmart.langMap.get(sourceLanguage) || sourceLanguage;
    const remoteTargetLanguage = _Transmart.langMap.get(to) || to;
    if (sourceLanguage === to) {
      return {
        text,
        from: sourceLanguage,
        to
      };
    }
    const requestPayload = JSON.stringify(
      {
        "header": {
          "fn": "auto_translation_block",
          "client_key": this.clientKey
        },
        "source": {
          "text_block": text,
          "lang": remoteSourceLanguage,
          "orig_url": payload.url
        },
        "target": { "lang": remoteTargetLanguage }
      }
    );
    const data = await request2({
      url: API,
      body: requestPayload,
      method: "POST",
      retry: 2
    });
    if (data.header.ret_code !== "succ") {
      throw new Error(data.message || data.header.ret_code);
    }
    return {
      text: data.auto_translation,
      from: sourceLanguage || "auto",
      to
    };
  }
  async translateList(payload) {
    const { from, text, to } = payload;
    if (text.length === 1) {
      const result = await this.translate({
        from,
        text: text[0],
        to,
        url: payload.url,
        options: payload.options
      });
      return {
        text: [result.text],
        from: result.from,
        to: result.to
      };
    }
    const sourceLanguage = await this.detectLanguage(text.join("\n"));
    if (sourceLanguage === to) {
      return {
        text,
        from: sourceLanguage,
        to
      };
    }
    const remoteSourceLanguage = _Transmart.langMap.get(sourceLanguage) || sourceLanguage;
    const remoteTargetLanguage = _Transmart.langMap.get(to) || to;
    const requestPayload = JSON.stringify(
      {
        "header": {
          "fn": "auto_translation",
          "client_key": this.clientKey
        },
        "source": {
          "text_list": text,
          "lang": remoteSourceLanguage,
          "orig_url": payload.url
        },
        "target": { "lang": remoteTargetLanguage },
        "type": "plain"
      }
    );
    const data = await request2({
      url: API,
      body: requestPayload,
      method: "POST"
    });
    if (data.header.ret_code !== "succ") {
      throw new Error(data.message || data.header.ret_code);
    }
    return {
      text: data.auto_translation,
      from: sourceLanguage || "auto",
      to
    };
  }
  detectLanguageLocally(text) {
    return this.detectLanguageRemotely(text);
  }
  async detectLanguageRemotely(text) {
    const payload = {
      "header": {
        "fn": "text_analysis",
        "client_key": this.clientKey
      },
      text: text.slice(0, 280)
    };
    const response = await request2({
      url: API,
      method: "POST",
      body: JSON.stringify(payload)
    });
    if (response.header.ret_code !== "succ") {
      throw new Error(response.message || response.header.ret_code);
    }
    const remoteLanguage = response.language;
    const language = _Transmart.langMapReverse.get(remoteLanguage);
    if (language) {
      return language;
    }
    return remoteLanguage;
  }
};
var Transmart = _Transmart;
/** Translator lang to custom lang */
Transmart.langMap = new Map(langMap5);
/** Custom lang to translator lang */
Transmart.langMapReverse = new Map(
  langMap5.map(([translatorLang, lang]) => [lang, translatorLang])
);

// utils/random.ts
function getRandomBoolean() {
  return Math.random() >= 0;
}

// services/mock.ts
var Mock = class extends Translation {
  constructor() {
    super(...arguments);
    this.isSupportList = true;
  }
  async translate(payload) {
    const { text } = payload;
    await mockRequest();
    await delay(5e3);
    const startSpaceLength = text.match(/^\s*/)[0].length;
    const mockText = text.slice(0, startSpaceLength) + "\u6A21\u62DF\uFF1A" + text.slice(startSpaceLength, -6);
    return {
      text: mockText,
      from: payload.from,
      to: payload.to
    };
  }
  async translateList(payload) {
    const { text: textList, from, to } = payload;
    await mockRequest();
    if (!getRandomBoolean()) {
      throw new Error("\u6A21\u62DF\u9519\u8BEF");
    }
    if (textList.length === 0) {
      return {
        from,
        to,
        text: [""]
      };
    }
    return {
      from,
      to,
      text: textList.map((text) => {
        const startSpaceLength = text.match(/^\s*/)[0].length;
        const mockText = text.slice(0, startSpaceLength) + "\u6A21\u62DF\uFF1A" + text.slice(startSpaceLength, -6);
        return mockText;
      })
    };
  }
};

// services/openl.ts
var rawLangMap = [
  ["auto", "auto"],
  ["zh-CN", "zh"],
  ["en", "en"],
  ["ja", "ja"],
  ["de", "de"],
  ["fr", "fr"],
  ["it", "it"],
  ["es", "es"],
  ["nl", "nl"],
  ["pl", "pl"],
  ["pt", "pt"],
  ["ru", "ru"]
];
var langMap6 = new Map(rawLangMap);
var langMapReverse = new Map(
  rawLangMap.map(([translatorLang, lang]) => [lang, translatorLang])
);
var _Openl = class extends Translation {
  constructor(serviceConfig, generalConfig) {
    super(serviceConfig, generalConfig);
    this.apikey = "";
    this.codename = _Openl.DEFAULT_CODENAME;
    this.isSupportList = false;
    this.maxTextGroupLength = 1;
    if (!serviceConfig || !serviceConfig.apikey) {
      throw new Error("apikey are required");
    }
    this.apikey = serviceConfig.apikey?.trim();
    if (serviceConfig.codename) {
      this.codename = serviceConfig.codename;
    }
  }
  static getAllProps() {
    const props = _Openl.getProps();
    return [
      ...props,
      {
        type: "password",
        name: "apikey",
        required: true
      }
    ];
  }
  static getProps() {
    return [{
      type: "select",
      name: "codename",
      label: "translationEngine",
      default: _Openl.DEFAULT_CODENAME,
      required: false,
      options: [
        {
          label: "translationServices.deepl",
          value: "deepl"
        },
        {
          label: "translationServices.youdao",
          value: "youdao"
        },
        {
          label: "translationServices.tencent",
          value: "tencent"
        },
        {
          label: "translationServices.aliyun",
          value: "aliyun"
        },
        {
          label: "translationServices.baidu",
          value: "baidu"
        },
        {
          label: "translationServices.caiyun",
          value: "caiyun"
        },
        {
          label: "translationServices.wechat",
          value: "wechat"
        },
        {
          label: "translationServices.azure",
          value: "azure"
        },
        {
          label: "translationServices.ibm",
          value: "ibm"
        },
        {
          label: "translationServices.aws",
          value: "aws"
        },
        {
          label: "translationServices.google",
          value: "google"
        }
      ]
    }];
  }
  async translate(payload) {
    const { text, from, to } = payload;
    const response = await request2(
      {
        retry: 2,
        url: `https://api.openl.club/services/${this.codename}/translate`,
        headers: {
          "content-type": "application/json"
        },
        method: "POST",
        body: JSON.stringify({
          apikey: this.apikey,
          text,
          source_lang: langMap6.get(from) || "auto",
          target_lang: langMap6.get(to) || to
        })
      }
    );
    if (response.status) {
      const result = response;
      return {
        text: result.result,
        from: langMapReverse.get(result.source_lang),
        to: langMapReverse.get(result.target_lang)
      };
    } else {
      throw new Error(response.msg);
    }
  }
};
var Openl = _Openl;
Openl.DEFAULT_CODENAME = "deepl";
var openl_default = Openl;

// services/deepl.ts
var rawLangMap2 = [
  ["auto", ""],
  ["zh-CN", "ZH"],
  ["zh-TW", "ZH"],
  ["en", "EN"],
  ["de", "DE"],
  ["fr", "FR"],
  ["it", "IT"],
  ["ja", "JA"],
  ["es", "ES"],
  ["nl", "NL"],
  ["pl", "PL"],
  ["pt", "PT"],
  ["ru", "RU"]
];
var langMap7 = new Map(rawLangMap2);
var langMapReverse2 = new Map(
  rawLangMap2.map(([translatorLang, lang]) => [lang, translatorLang])
);
var Deepl = class extends Translation {
  constructor(serviceConfig, generalConfig) {
    super(serviceConfig, generalConfig);
    this.authKey = "";
    this.maxTextGroupLength = 10;
    this.maxTextLength = 1200;
    this.freeApiUrl = "https://api-free.deepl.com/v2/translate";
    this.proApiUrl = "https://api.deepl.com/v2/translate";
    this.immersiveTranslateApiUrl = "https://deepl.immersivetranslate.com/v2/translate";
    if (!serviceConfig || !serviceConfig.authKey) {
      throw new Error("authKey are required");
    }
    if (serviceConfig && serviceConfig.freeApiUrl) {
      this.freeApiUrl = mergeUrl(this.freeApiUrl, serviceConfig.freeApiUrl);
    }
    if (serviceConfig && serviceConfig.proApiUrl) {
      this.proApiUrl = mergeUrl(this.proApiUrl, serviceConfig.proApiUrl);
    }
    if (serviceConfig && serviceConfig.immersiveTranslateApiUrl) {
      this.immersiveTranslateApiUrl = mergeUrl(
        this.immersiveTranslateApiUrl,
        serviceConfig.immersiveTranslateApiUrl
      );
    }
    this.authKey = serviceConfig.authKey?.trim();
  }
  static getAllProps() {
    return [{
      name: "authKey",
      required: true,
      type: "password"
    }];
  }
  async translateList(payload) {
    const { from, to, text } = payload;
    const bodyParams = {
      ["source_lang"]: langMap7.get(from) || "",
      ["target_lang"]: langMap7.get(to) || to
    };
    const bodySearchParams = new URLSearchParams(bodyParams);
    text.forEach((item) => {
      bodySearchParams.append("text", item);
    });
    const body = bodySearchParams.toString();
    let deeplEndpoint = this.freeApiUrl;
    if (this.authKey.endsWith(":im")) {
      deeplEndpoint = this.immersiveTranslateApiUrl;
    } else if (!this.authKey.endsWith(":fx")) {
      deeplEndpoint = this.proApiUrl;
    }
    const response = await request2(
      {
        retry: 2,
        url: deeplEndpoint,
        method: "POST",
        body,
        headers: {
          Authorization: "DeepL-Auth-Key " + this.authKey,
          "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8"
        },
        extra: {
          "overrideMimeType": "application/json; charset=utf-8"
        }
      }
    );
    const { translations: translations2 } = response;
    const resultText = translations2.map((t4) => t4.text);
    return {
      text: resultText,
      from: translations2[0] && langMapReverse2.get(translations2[0].detected_source_language) || from,
      to
    };
  }
};
var deepl_default = Deepl;

// services/niu.ts
var rawLangMap3 = [
  ["auto", "auto"],
  ["zh-CN", "zh"],
  ["zh-TW", "cht"],
  ["en", "en"],
  ["ja", "ja"],
  ["ru", "ru"],
  ["es", "es"],
  ["de", "de"],
  ["ko", "ko"],
  ["fr", "fr"]
];
var langMap8 = new Map(rawLangMap3);
var Niu = class extends Translation {
  constructor(serviceConfig, generalConfig) {
    super(serviceConfig, generalConfig);
    this.APIKEY = "";
    this.isSupportList = false;
    if (!serviceConfig || !serviceConfig.APIKEY) {
      throw new Error("APIKEY are required");
    }
    this.APIKEY = serviceConfig.APIKEY?.trim();
  }
  static getAllProps() {
    return [{
      name: "APIKEY",
      required: true,
      type: "password"
    }];
  }
  async translate(payload) {
    let { text, from, to } = payload;
    const src_text = text;
    const options2 = {
      url: "https://api.niutrans.com/NiuTransServer/translation",
      retry: 2,
      headers: {
        "content-type": "application/json"
      },
      method: "POST",
      body: JSON.stringify({
        src_text,
        from: langMap8.get(from) || from,
        to: langMap8.get(to) || to,
        apikey: this.APIKEY
      })
    };
    const response = await request2(
      options2
    );
    if (!response.tgt_text) {
      throw new Error(JSON.stringify(response));
    } else {
      let result = response.tgt_text;
      if (result.endsWith("\n")) {
        result = result.slice(0, -1);
      }
      return {
        text: result,
        from,
        to
      };
    }
  }
};
var niu_default = Niu;

// services/volc/sign.ts
var unsignableHeaders = [
  "authorization",
  "content-type",
  "content-length",
  "user-agent",
  "presigned-expires",
  "expect"
];
var constant = {
  algorithm: "HMAC-SHA256",
  v4Identifier: "request",
  dateHeader: "X-Date",
  tokenHeader: "X-Security-Token",
  contentSha256Header: "X-Content-Sha256",
  notSignBody: "X-NotSignBody",
  kDatePrefix: "",
  credential: "X-Credential",
  algorithmKey: "X-Algorithm",
  signHeadersKey: "X-SignedHeaders",
  signQueriesKey: "X-SignedQueries",
  signatureKey: "X-Signature"
};
var uriEscape = (str) => {
  try {
    return encodeURIComponent(str).replace(/[^A-Za-z0-9_.~\-%]+/g, escape).replace(
      /[*]/g,
      (ch) => `%${ch.charCodeAt(0).toString(16).toUpperCase()}`
    );
  } catch (e3) {
    return "";
  }
};
var queryParamsToString = (params) => Object.keys(params).map((key) => {
  const val = params[key];
  if (typeof val === "undefined" || val === null) {
    return;
  }
  const escapedKey = uriEscape(key);
  if (!escapedKey) {
    return;
  }
  if (Array.isArray(val)) {
    return `${escapedKey}=${val.map(uriEscape).sort().join(`&${escapedKey}=`)}`;
  }
  return `${escapedKey}=${uriEscape(val)}`;
}).filter((v2) => v2).join("&");
var Signer = class {
  constructor(request3, serviceName, options2) {
    this.request = request3;
    this.request.headers = request3.headers || {};
    this.serviceName = serviceName;
    options2 = options2 || {};
    this.bodySha256 = options2.bodySha256;
    this.request.params = this.sortParams(this.request.params);
  }
  sortParams(params) {
    const newParams = {};
    if (params) {
      Object.keys(params).filter((key) => {
        const value = params[key];
        return typeof value !== "undefined" && value !== null;
      }).sort().map((key) => {
        newParams[key] = params[key];
      });
    }
    return newParams;
  }
  async addAuthorization(credentials, date) {
    const datetime = this.getDateTime(date);
    await this.addHeaders(credentials, datetime);
    this.request.headers["Authorization"] = await this.authorization(
      credentials,
      datetime
    );
  }
  async authorization(credentials, datetime) {
    const parts = [];
    const credString = this.credentialString(datetime);
    parts.push(
      `${constant.algorithm} Credential=${credentials.accessKeyId}/${credString}`
    );
    parts.push(`SignedHeaders=${this.signedHeaders()}`);
    parts.push(`Signature=${await this.signature(credentials, datetime)}`);
    return parts.join(", ");
  }
  async getSignUrl(credentials, date) {
    const datetime = this.getDateTime(date);
    let query = { ...this.request.params };
    const params = this.request.params;
    const headers2 = this.request.headers;
    if (credentials.sessionToken) {
      query[constant.tokenHeader] = credentials.sessionToken;
    }
    query[constant.dateHeader] = datetime;
    query[constant.notSignBody] = "";
    query[constant.credential] = `${credentials.accessKeyId}/${this.credentialString(datetime)}`;
    query[constant.algorithmKey] = constant.algorithm;
    query[constant.signHeadersKey] = "";
    query[constant.signQueriesKey] = void 0;
    query[constant.signatureKey] = void 0;
    query = this.sortParams(query);
    this.request.params = query;
    this.request.headers = {};
    const sig = await this.signature(credentials, datetime);
    this.request.params = params;
    this.request.headers = headers2;
    query[constant.signQueriesKey] = Object.keys(query).sort().join(";");
    query[constant.signatureKey] = sig;
    return queryParamsToString(query);
  }
  getDateTime(date) {
    return this.iso8601(date).replace(/[:\-]|\.\d{3}/g, "");
  }
  async addHeaders(credentials, datetime) {
    this.request.headers[constant.dateHeader] = datetime;
    if (credentials.sessionToken) {
      this.request.headers[constant.tokenHeader] = credentials.sessionToken;
    }
    if (this.request.body) {
      let body = this.request.body;
      this.request.headers[constant.contentSha256Header] = await sha256(body);
    }
  }
  async signature(credentials, datetime) {
    const signingKey = await this.getSigningKey(
      credentials,
      datetime.substr(0, 8),
      this.request.region,
      this.serviceName
    );
    return hex(await hmacSha256(await this.stringToSign(datetime), signingKey));
  }
  async stringToSign(datetime) {
    const parts = [];
    parts.push(constant.algorithm);
    parts.push(datetime);
    parts.push(this.credentialString(datetime));
    const x5 = await this.canonicalString();
    parts.push(
      await this.hexEncodedHash(x5)
    );
    const result = parts.join("\n");
    return result;
  }
  async canonicalString() {
    const parts = [], pathname = this.request.pathname || "/";
    parts.push(this.request.method.toUpperCase());
    parts.push(pathname);
    const queryString = queryParamsToString(this.request.params) || "";
    parts.push(queryString);
    parts.push(`${this.canonicalHeaders()}
`);
    parts.push(this.signedHeaders());
    parts.push(await this.hexEncodedBodyHash());
    const result = parts.join("\n");
    return result;
  }
  canonicalHeaders() {
    const headers2 = [];
    Object.keys(this.request.headers).forEach((key) => {
      headers2.push([key, this.request.headers[key]]);
    });
    headers2.sort((a4, b4) => a4[0].toLowerCase() < b4[0].toLowerCase() ? -1 : 1);
    const parts = [];
    headers2.forEach((item) => {
      const key = item[0].toLowerCase();
      if (this.isSignableHeader(key)) {
        const value = item[1];
        if (typeof value === "undefined" || value === null || typeof value.toString !== "function") {
          throw new Error(`Header ${key} contains invalid value`);
        }
        parts.push(`${key}:${this.canonicalHeaderValues(value.toString())}`);
      }
    });
    return parts.join("\n");
  }
  canonicalHeaderValues(values) {
    return values.replace(/\s+/g, " ").replace(/^\s+|\s+$/g, "");
  }
  signedHeaders() {
    const keys = [];
    Object.keys(this.request.headers).forEach((key) => {
      key = key.toLowerCase();
      if (this.isSignableHeader(key)) {
        keys.push(key);
      }
    });
    return keys.sort().join(";");
  }
  signedQueries() {
    return Object.keys(this.request.params).join(";");
  }
  credentialString(datetime) {
    return this.createScope(
      datetime.substr(0, 8),
      this.request.region,
      this.serviceName
    );
  }
  async hexEncodedHash(str) {
    return await sha256(str);
  }
  async hexEncodedBodyHash() {
    if (this.request.headers[constant.contentSha256Header]) {
      return this.request.headers[constant.contentSha256Header];
    }
    if (this.request.body) {
      return await this.hexEncodedHash(queryParamsToString(this.request.body));
    }
    return await this.hexEncodedHash("");
  }
  isSignableHeader(key) {
    return unsignableHeaders.indexOf(key) < 0;
  }
  iso8601(date) {
    if (date === void 0) {
      date = /* @__PURE__ */ new Date();
    }
    return date.toISOString().replace(/\.\d{3}Z$/, "Z");
  }
  async getSigningKey(credentials, date, region, service) {
    const kDate = await hmacSha256(
      date,
      `${constant.kDatePrefix}${credentials.secretKey}`
    );
    const kRegion = await hmacSha256(region, kDate);
    const kService = await hmacSha256(service, kRegion);
    return hmacSha256(constant.v4Identifier, kService);
  }
  createScope(date, region, serviceName) {
    return [date.substr(0, 8), region, serviceName, constant.v4Identifier].join(
      "/"
    );
  }
};

// services/volc/mod.ts
var rawLangMap4 = [
  ["af", "af"],
  ["am", "am"],
  ["ar", "ar"],
  ["az", "az"],
  ["be", "be"],
  ["bg", "bg"],
  ["bn", "bn"],
  ["bs", "bs"],
  ["ca", "ca"],
  ["co", "co"],
  ["cs", "cs"],
  ["cy", "cy"],
  ["da", "da"],
  ["de", "de"],
  ["el", "el"],
  ["en", "en"],
  ["eo", "eo"],
  ["es", "es"],
  ["et", "et"],
  ["eu", "eu"],
  ["fa", "fa"],
  ["fi", "fi"],
  ["fj", "fj"],
  ["fr", "fr"],
  ["fy", "fy"],
  ["ga", "ga"],
  ["gd", "gd"],
  ["gl", "gl"],
  ["gu", "gu"],
  ["ha", "ha"],
  ["he", "he"],
  ["hi", "hi"],
  ["hr", "hr"],
  ["ht", "ht"],
  ["hu", "hu"],
  ["hy", "hy"],
  ["id", "id"],
  ["ig", "ig"],
  ["is", "is"],
  ["it", "it"],
  ["ja", "ja"],
  ["ka", "ka"],
  ["kk", "kk"],
  ["km", "km"],
  ["kn", "kn"],
  ["ko", "ko"],
  ["ku", "ku"],
  ["ky", "ky"],
  ["la", "la"],
  ["lb", "lb"],
  ["lo", "lo"],
  ["lt", "lt"],
  ["lv", "lv"],
  ["mg", "mg"],
  ["mi", "mi"],
  ["mk", "mk"],
  ["ml", "ml"],
  ["mn", "mn"],
  ["mr", "mr"],
  ["ms", "ms"],
  ["mt", "mt"],
  ["my", "my"],
  ["ne", "ne"],
  ["nl", "nl"],
  ["no", "no"],
  ["ny", "ny"],
  ["pa", "pa"],
  ["pl", "pl"],
  ["ps", "ps"],
  ["pt", "pt"],
  ["ro", "ro"],
  ["ru", "ru"],
  ["sd", "sd"],
  ["si", "si"],
  ["sk", "sk"],
  ["sl", "sl"],
  ["sm", "sm"],
  ["sn", "sn"],
  ["so", "so"],
  ["sq", "sq"],
  ["sr", "sr"],
  ["st", "st"],
  ["su", "su"],
  ["sv", "sv"],
  ["sw", "sw"],
  ["ta", "ta"],
  ["te", "te"],
  ["tg", "tg"],
  ["th", "th"],
  ["tn", "tn"],
  ["to", "to"],
  ["tr", "tr"],
  ["ty", "ty"],
  ["ug", "ug"],
  ["uk", "uk"],
  ["ur", "ur"],
  ["uz", "uz"],
  ["vi", "vi"],
  ["xh", "xh"],
  ["yi", "yi"],
  ["yo", "yo"],
  ["zh-CN", "zh"],
  ["zh-TW", "zh-Hans"],
  ["zu", "zu"]
];
var langMap9 = new Map(rawLangMap4);
var langMapReverse3 = new Map(
  rawLangMap4.map(([translatorLang, lang]) => [lang, translatorLang])
);
var Volc = class extends Translation {
  constructor(serviceConfig, generalConfig) {
    super(serviceConfig, generalConfig);
    this.accessKeyId = "";
    this.secretAccessKey = "";
    this.maxTextGroupLength = 8;
    if (!serviceConfig || !serviceConfig.accessKeyId || !serviceConfig.secretAccessKey) {
      throw new Error("accessKeyId and secretAccessKey are required");
    }
    this.accessKeyId = serviceConfig.accessKeyId?.trim();
    this.secretAccessKey = serviceConfig.secretAccessKey?.trim();
  }
  static getAllProps() {
    return [{
      name: "accessKeyId",
      required: true,
      type: "text"
    }, {
      name: "secretAccessKey",
      required: true,
      type: "password"
    }];
  }
  async remoteDetectLanguage(text) {
    const bodyParams = {
      "TextList": [text]
    };
    const requestObj = {
      region: "cn-north-1",
      method: "POST",
      params: {
        "Action": "LangDetect",
        "Version": "2020-06-01"
      },
      pathname: "/",
      headers: {
        "Content-Type": "application/json",
        "host": "open.volcengineapi.com"
      },
      body: JSON.stringify(bodyParams)
    };
    const signer = new Signer(requestObj, "translate");
    await signer.addAuthorization({
      accessKeyId: this.accessKeyId,
      secretKey: this.secretAccessKey
    });
    const urlSearchParams = new URLSearchParams(requestObj.params);
    const response = await request2(
      {
        retry: 2,
        url: "https://open.volcengineapi.com" + requestObj.pathname + "?" + urlSearchParams.toString(),
        headers: signer.request.headers,
        method: requestObj.method,
        body: requestObj.body
      }
    );
    if (response.DetectedLanguageList && response.DetectedLanguageList.length > 0) {
      return response.DetectedLanguageList[0].Language;
    } else {
      if (response.ResponseMetadata && response.ResponseMetadata.Error) {
        const error = response.ResponseMetadata.Error;
        throw new CommonError(error.Code, error.Message);
      } else if (response.ResponseMetaData && response.ResponseMetaData.Error) {
        const error = response.ResponseMetaData.Error;
        throw new CommonError(error.Code, error.Message);
      } else {
        throw new Error("response: " + JSON.stringify(response));
      }
    }
  }
  async translateList(payload) {
    const { text, from, to } = payload;
    const remoteFrom = langMap9.get(from);
    const bodyParams = {
      "TargetLanguage": langMap9.get(to) || to,
      "TextList": text
    };
    if (remoteFrom) {
      bodyParams.SourceLanguage = remoteFrom;
    } else {
      bodyParams.SourceLanguage = await this.remoteDetectLanguage(
        text.join("\n").slice(0, 1e3)
      );
    }
    const requestObj = {
      region: "cn-north-1",
      method: "POST",
      params: {
        "Action": "TranslateText",
        "Version": "2020-06-01"
      },
      pathname: "/",
      headers: {
        "Content-Type": "application/json",
        "host": "open.volcengineapi.com"
      },
      body: JSON.stringify(bodyParams)
    };
    const signer = new Signer(requestObj, "translate");
    await signer.addAuthorization({
      accessKeyId: this.accessKeyId,
      secretKey: this.secretAccessKey
    });
    const urlSearchParams = new URLSearchParams(requestObj.params);
    const response = await request2(
      {
        retry: 2,
        url: "https://open.volcengineapi.com" + requestObj.pathname + "?" + urlSearchParams.toString(),
        headers: signer.request.headers,
        method: requestObj.method,
        body: requestObj.body
      }
    );
    if (response.TranslationList) {
      const resultText = response.TranslationList.map((item) => item.Translation);
      let remoteFrom2 = from;
      if (response.TranslationList.length > 0) {
        if (response.TranslationList[0].DetectedSourceLanguage) {
          remoteFrom2 = langMapReverse3.get(
            response.TranslationList[0].DetectedSourceLanguage
          ) || from;
        }
      }
      return {
        text: resultText,
        from: remoteFrom2,
        to
      };
    } else {
      if (response.ResponseMetadata && response.ResponseMetadata.Error) {
        const error = response.ResponseMetadata.Error;
        throw new CommonError(error.Code, error.Message);
      } else if (response.ResponseMetaData && response.ResponseMetaData.Error) {
        const error = response.ResponseMetaData.Error;
        throw new CommonError(error.Code, error.Message);
      } else {
        throw new Error("response: " + JSON.stringify(response));
      }
    }
  }
};
var mod_default2 = Volc;

// services/volc_alpha.ts
var rawLangMap5 = [
  ["auto", "detect"],
  ["af", "af"],
  ["am", "am"],
  ["ar", "ar"],
  ["az", "az"],
  ["be", "be"],
  ["bg", "bg"],
  ["bn", "bn"],
  ["bs", "bs"],
  ["ca", "ca"],
  ["co", "co"],
  ["cs", "cs"],
  ["cy", "cy"],
  ["da", "da"],
  ["de", "de"],
  ["el", "el"],
  ["en", "en"],
  ["eo", "eo"],
  ["es", "es"],
  ["et", "et"],
  ["eu", "eu"],
  ["fa", "fa"],
  ["fi", "fi"],
  ["fj", "fj"],
  ["fr", "fr"],
  ["fy", "fy"],
  ["ga", "ga"],
  ["gd", "gd"],
  ["gl", "gl"],
  ["gu", "gu"],
  ["ha", "ha"],
  ["he", "he"],
  ["hi", "hi"],
  ["hr", "hr"],
  ["ht", "ht"],
  ["hu", "hu"],
  ["hy", "hy"],
  ["id", "id"],
  ["ig", "ig"],
  ["is", "is"],
  ["it", "it"],
  ["ja", "ja"],
  ["ka", "ka"],
  ["kk", "kk"],
  ["km", "km"],
  ["kn", "kn"],
  ["ko", "ko"],
  ["ku", "ku"],
  ["ky", "ky"],
  ["la", "la"],
  ["lb", "lb"],
  ["lo", "lo"],
  ["lt", "lt"],
  ["lv", "lv"],
  ["mg", "mg"],
  ["mi", "mi"],
  ["mk", "mk"],
  ["ml", "ml"],
  ["mn", "mn"],
  ["mr", "mr"],
  ["ms", "ms"],
  ["mt", "mt"],
  ["my", "my"],
  ["ne", "ne"],
  ["nl", "nl"],
  ["no", "no"],
  ["ny", "ny"],
  ["pa", "pa"],
  ["pl", "pl"],
  ["ps", "ps"],
  ["pt", "pt"],
  ["ro", "ro"],
  ["ru", "ru"],
  ["sd", "sd"],
  ["si", "si"],
  ["sk", "sk"],
  ["sl", "sl"],
  ["sm", "sm"],
  ["sn", "sn"],
  ["so", "so"],
  ["sq", "sq"],
  ["sr", "sr"],
  ["st", "st"],
  ["su", "su"],
  ["sv", "sv"],
  ["sw", "sw"],
  ["ta", "ta"],
  ["te", "te"],
  ["tg", "tg"],
  ["th", "th"],
  ["tn", "tn"],
  ["to", "to"],
  ["tr", "tr"],
  ["ty", "ty"],
  ["ug", "ug"],
  ["uk", "uk"],
  ["ur", "ur"],
  ["uz", "uz"],
  ["vi", "vi"],
  ["xh", "xh"],
  ["yi", "yi"],
  ["yo", "yo"],
  ["zh-CN", "zh"],
  ["zh-TW", "zh-Hans"],
  ["zu", "zu"]
];
var langMap10 = new Map(rawLangMap5);
var langMapReverse4 = new Map(
  rawLangMap5.map(([translatorLang, lang]) => [lang, translatorLang])
);
var VolcAlpha = class extends Translation {
  constructor() {
    super(...arguments);
    this.maxTextGroupLength = 50;
    this.isSupportList = false;
  }
  async translate(payload) {
    const { text, from, to } = payload;
    const remoteFrom = langMap10.get(from) || "detect";
    const remoteTo = langMap10.get(to) || to;
    const bodyParams = {
      "source_language": remoteFrom,
      "target_language": remoteTo,
      "text": text
    };
    const response = await request2(
      {
        url: "https://translate.volcengine.com/crx/translate/v1/",
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(bodyParams)
      }
    );
    if (response.base_resp && response.base_resp.status_code === 0) {
      const resultText = response.translation;
      let remoteFrom2 = from;
      if (response.detected_language) {
        remoteFrom2 = langMapReverse4.get(response.detected_language) || from;
      }
      return {
        text: resultText,
        from: remoteFrom2,
        to
      };
    } else {
      const error = response.base_resp;
      throw new CommonError(error.status_code.toString(), error.status_message);
    }
  }
};

// services/deeplx.ts
var rawLangMap6 = [
  ["auto", "auto"],
  ["zh-CN", "ZH"],
  ["zh-TW", "ZH"],
  ["de", "DE"],
  ["en", "EN"],
  ["es", "ES"],
  ["fr", "FR"],
  ["it", "IT"],
  ["ja", "JA"],
  ["pt", "PT"],
  ["ru", "RU"],
  ["tr", "tr"]
];
var langMap11 = new Map(rawLangMap6);
var Deeplx = class extends Translation {
  constructor(serviceConfig, generalConfig) {
    super(serviceConfig, generalConfig);
    this.url = "";
    this.isSupportList = false;
    this.maxTextGroupLength = 1;
    if (!serviceConfig || !serviceConfig.url) {
      throw new Error(
        "deeplx custom url are required, please check your settings."
      );
    }
    this.url = serviceConfig.url;
  }
  static getAllProps() {
    return [{
      name: "url",
      required: true,
      type: "text"
    }];
  }
  async translate(payload) {
    const { text, from, to } = payload;
    const response = await request2(
      {
        retry: 2,
        url: this.url,
        headers: {
          "content-type": "application/json"
        },
        method: "POST",
        body: JSON.stringify({
          source_lang: langMap11.get(from) || from,
          target_lang: langMap11.get(to) || to,
          text
        })
      }
    );
    const result = response;
    if (result.code === 200) {
      return {
        text: result.data,
        from,
        to
      };
    } else {
      throw new Error(result.message || result.message || "API Error");
    }
  }
};

// services/bing/api.js
var TRANSLATE_API_ROOT = "https://{s}bing.com";
var TRANSLATE_WEBSITE = TRANSLATE_API_ROOT + "/translator";
var TRANSLATE_API = TRANSLATE_API_ROOT + "/ttranslatev3";
var TRANSLATE_SPELL_CHECK_API = TRANSLATE_API_ROOT + "/tspellcheckv3";
var globalConfigStorageKey = "bingGlobalConfig";
var rawLangMap7 = [
  ["auto", "auto-detect"],
  ["ar", "ar"],
  ["ga", "ga"],
  ["et", "et"],
  ["bg", "bg"],
  ["is", "is"],
  ["pl", "pl"],
  ["bs", "bs-Latn"],
  ["fa", "fa"],
  ["da", "da"],
  ["de", "de"],
  ["ru", "ru"],
  ["fr", "fr"],
  ["zh-TW", "zh-Hant"],
  ["fil", "fil"],
  ["fj", "fj"],
  ["fi", "fi"],
  ["gu", "gu"],
  ["kk", "kk"],
  ["ht", "ht"],
  ["ko", "ko"],
  ["nl", "nl"],
  ["ca", "ca"],
  ["zh-CN", "zh-Hans"],
  ["cs", "cs"],
  ["kn", "kn"],
  ["otq", "otq"],
  ["tlh", "tlh"],
  ["hr", "hr"],
  ["lv", "lv"],
  ["lt", "lt"],
  ["ro", "ro"],
  ["mg", "mg"],
  ["mt", "mt"],
  ["mr", "mr"],
  ["ml", "ml"],
  ["ms", "ms"],
  ["mi", "mi"],
  ["bn", "bn-BD"],
  ["hmn", "mww"],
  ["af", "af"],
  ["pa", "pa"],
  ["pt", "pt"],
  ["ps", "ps"],
  ["ja", "ja"],
  ["sv", "sv"],
  ["sm", "sm"],
  ["sr-Latn", "sr-Latn"],
  ["sr-Cyrl", "sr-Cyrl"],
  ["no", "nb"],
  ["sk", "sk"],
  ["sl", "sl"],
  ["sw", "sw"],
  ["ty", "ty"],
  ["te", "te"],
  ["ta", "ta"],
  ["th", "th"],
  ["to", "to"],
  ["tr", "tr"],
  ["cy", "cy"],
  ["ur", "ur"],
  ["uk", "uk"],
  ["es", "es"],
  ["he", "iw"],
  ["el", "el"],
  ["hu", "hu"],
  ["it", "it"],
  ["hi", "hi"],
  ["id", "id"],
  ["en", "en"],
  ["yua", "yua"],
  ["yue", "yua"],
  ["vi", "vi"],
  ["ku", "ku"],
  ["km", "kmr"]
];
var langMap12 = new Map(rawLangMap7);
var langMapReverse5 = new Map(
  rawLangMap7.map(([translatorLang, lang]) => [lang, translatorLang])
);
var MAX_TEXT_LEN = 1e3;
var globalConfig;
var globalConfigPromise;
function replaceSubdomain(url, subdomain) {
  return url.replace("{s}", subdomain ? subdomain + "." : "");
}
async function isTokenExpired() {
  if (!globalConfig) {
    const storageValue = await browserAPI.storage.local.get(
      globalConfigStorageKey
    );
    if (storageValue) {
      globalConfig = storageValue[globalConfigStorageKey];
    }
    return true;
  }
  const { tokenTs, tokenExpiryInterval } = globalConfig;
  return Date.now() - tokenTs > tokenExpiryInterval;
}
async function fetchGlobalConfig() {
  let subdomain;
  let IG;
  let IID;
  let token;
  let key;
  let tokenExpiryInterval;
  let isVertical;
  let frontDoorBotClassification;
  let isSignedInOrCorporateUser;
  let cookie;
  try {
    const finalUrl = replaceSubdomain(TRANSLATE_WEBSITE, subdomain);
    const response = await request2({
      retry: 2,
      url: finalUrl,
      responseType: "raw"
    });
    const { body, headers: headers2, url } = response;
    subdomain = url.match(/^https?:\/\/(\w+)\.bing\.com/)[1];
    cookie = headers2["set-cookie"];
    IG = body.match(/IG:"([^"]+)"/)[1];
    IID = body.match(/data-iid="([^"]+)"/)[1];
    [
      key,
      token,
      tokenExpiryInterval,
      isVertical,
      frontDoorBotClassification,
      isSignedInOrCorporateUser
    ] = JSON.parse(
      body.match(/params_AbusePreventionHelper\s?=\s?([^\]]+\])/)[1]
    );
  } catch (e3) {
    console.error("failed to fetch global config", e3);
    throw e3;
  }
  globalConfig = {
    subdomain,
    IG,
    IID,
    key,
    token,
    tokenTs: key,
    tokenExpiryInterval,
    isVertical,
    frontDoorBotClassification,
    isSignedInOrCorporateUser,
    cookie,
    // PENDING: reset count if count value is large?
    count: 0
  };
  await browserAPI.storage.local.set({
    [globalConfigStorageKey]: globalConfig
  });
  return globalConfig;
}
function makeRequestURL(isSpellCheck) {
  const { IG, IID, subdomain, isVertical } = globalConfig;
  return replaceSubdomain(
    isSpellCheck ? TRANSLATE_SPELL_CHECK_API : TRANSLATE_API,
    subdomain
  ) + "?isVertical=1" + (IG && IG.length ? "&IG=" + IG : "") + (IID && IID.length ? "&IID=" + IID + "." + globalConfig.count++ : "");
}
function makeRequestBody(isSpellCheck, text, fromLang, toLang) {
  const { token, key } = globalConfig;
  const body = {
    fromLang,
    text,
    token,
    key
  };
  if (!isSpellCheck && toLang) {
    body.to = toLang;
  }
  return body;
}
async function translate2(text, from, to) {
  if (!text || !(text = text.trim())) {
    return;
  }
  if (text.length > MAX_TEXT_LEN) {
    throw new Error(
      `The supported maximum length of text is ${MAX_TEXT_LEN}. Please shorten the text.`
    );
  }
  if (!globalConfigPromise) {
    globalConfigPromise = fetchGlobalConfig();
  }
  await globalConfigPromise;
  const isTokenExpiredValue = await isTokenExpired();
  if (isTokenExpiredValue) {
    globalConfigPromise = fetchGlobalConfig();
    await globalConfigPromise;
  }
  from = from || "auto";
  to = to || "zh-CN";
  from = langMap12.get(from) || from;
  to = langMap12.get(to) || to;
  const requestURL = makeRequestURL(false);
  const requestBody = makeRequestBody(
    false,
    text,
    from,
    to === "auto-detect" ? "zh-Hans" : to
  );
  const requestHeaders = {
    referer: replaceSubdomain(TRANSLATE_WEBSITE, globalConfig.subdomain),
    // cookie: globalConfig.cookie,
    "content-type": "application/x-www-form-urlencoded"
  };
  const searchParams = new URLSearchParams(requestBody);
  const finalUrl = requestURL;
  const requestBodyString = searchParams.toString();
  const body = await request2({
    retry: 2,
    url: finalUrl,
    headers: requestHeaders,
    method: "POST",
    body: requestBodyString
  });
  if (body.ShowCaptcha || body.StatusCode === 401 || body.statusCode) {
    globalConfig = null;
    globalConfigPromise = null;
    await browserAPI.storage.local.remove(globalConfigStorageKey);
    if (body.ShowCaptcha) {
      throw new Error(`
      Sorry that bing translator seems to be asking for the captcha,
      Please take care not to request too frequently.
      The response code is ${body.StatusCode}.
    `);
    }
    if (body.StatusCode === 401) {
      throw new Error(`
      Max count of translation exceeded. Please try it again later.
      The response code is 401.
    `);
    }
    if (body.statusCode) {
      throw new Error(
        `Something went wrong! The response is ${JSON.stringify(body)}.`
      );
    }
  }
  const translation = body[0].translations[0];
  const detectedLang = body[0].detectedLanguage;
  const res = {
    text: translation.text,
    from: langMapReverse5.get(detectedLang.language),
    to: langMapReverse5.get(translation.to)
  };
  return res;
}

// services/bing/mod.ts
var Bing = class extends Translation {
  constructor(serviceConfig, generalConfig) {
    super(serviceConfig, generalConfig);
    this.isSupportList = false;
    this.maxTextLength = 1e3;
  }
  async translate(payload) {
    const { text, from, to } = payload;
    if (!text)
      return { ...payload };
    const result = await translate2(text, from, to);
    return result;
  }
};

// services/baidu.ts
var rawLangMap8 = [
  ["auto", "auto"],
  ["zh-CN", "zh"],
  ["en", "en"],
  ["yue", "yue"],
  ["wyw", "wyw"],
  ["ja", "jp"],
  ["ko", "kor"],
  ["fr", "fra"],
  ["es", "spa"],
  ["th", "th"],
  ["ar", "ara"],
  ["ru", "ru"],
  ["pt", "pt"],
  ["de", "de"],
  ["it", "it"],
  ["el", "el"],
  ["nl", "nl"],
  ["pl", "pl"],
  ["bg", "bul"],
  ["et", "est"],
  ["da", "dan"],
  ["fi", "fin"],
  ["cs", "cs"],
  ["ro", "rom"],
  ["sl", "slo"],
  ["sv", "swe"],
  ["hu", "hu"],
  ["zh-TW", "cht"],
  ["vi", "vie"]
];
var langMap13 = new Map(rawLangMap8);
var langMapReverse6 = new Map(
  rawLangMap8.map(([translatorLang, lang]) => [lang, translatorLang])
);
var Baidu = class extends Translation {
  constructor(serviceConfig, generalConfig) {
    super(serviceConfig, generalConfig);
    this.endpoint = "https://api.fanyi.baidu.com/api/trans/vip/translate";
    this.appid = "";
    this.key = "";
    this.isSupportList = false;
    if (!serviceConfig || !serviceConfig.appid || !serviceConfig.key) {
      throw new Error("appid and key are required");
    }
    this.appid = serviceConfig.appid?.trim();
    this.key = serviceConfig.key?.trim();
  }
  static getAllProps() {
    return [{
      name: "appid",
      required: true,
      type: "text"
    }, {
      name: "key",
      required: true,
      type: "password"
    }];
  }
  async translate(payload) {
    const salt = Date.now().toString();
    const { endpoint } = this;
    const { appid, key } = this;
    const { text, from, to } = payload;
    const params = new URLSearchParams({
      from: langMap13.get(from) || "auto",
      to: langMap13.get(to) || to,
      q: text,
      salt,
      appid,
      sign: md5(appid + text + salt + key)
    });
    const urlObj = new URL(endpoint);
    urlObj.search = params.toString();
    const data = await request2(
      {
        url: urlObj.toString()
      }
    );
    if (data.error_code) {
      console.error(
        new Error("[Baidu service]" + data.error_msg)
      );
      throw new CommonError(
        "API_SERVER_ERROR",
        data.error_msg
      );
    }
    const {
      trans_result: transResult,
      from: langDetected
    } = data;
    const transParagraphs = transResult.map(({ dst }) => dst);
    const detectedFrom = langMapReverse6.get(langDetected);
    return {
      from: detectedFrom || langDetected,
      to,
      text: transParagraphs.join("\n")
    };
  }
};
var baidu_default = Baidu;

// services/caiyun.ts
var rawLangMap9 = [
  ["auto", "auto"],
  ["zh-CN", "zh"],
  ["en", "en"],
  ["ja", "ja"]
];
var langMap14 = new Map(rawLangMap9);
var Caiyun = class extends Translation {
  constructor(serviceConfig, generalConfig) {
    super(serviceConfig, generalConfig);
    this.token = "";
    if (!serviceConfig || !serviceConfig.token) {
      throw new Error("token are required");
    }
    this.token = serviceConfig.token?.trim();
  }
  static getAllProps() {
    return [{
      name: "token",
      required: true,
      type: "password"
    }];
  }
  async translateList(payload) {
    let { text, from, to } = payload;
    const remoteTo = langMap14.get(to);
    if (!remoteTo) {
      throw new Error(`Unsupported language: ${to}`);
    }
    if (from === "auto") {
      from = await detectLanguage({ text: text.join(" "), minLength: 10 });
    }
    const source = text;
    const response = await request2(
      {
        retry: 2,
        url: "https://api.interpreter.caiyunai.com/v1/translator",
        headers: {
          "content-type": "application/json",
          "x-authorization": "token " + this.token
        },
        method: "POST",
        body: JSON.stringify({
          source,
          trans_type: `${langMap14.get(from) || "auto"}2${langMap14.get(to)}`
        })
      }
    );
    const result = response;
    return {
      text: result.target,
      from,
      to
    };
  }
};
var caiyun_default = Caiyun;

// services/youdao.ts
var rawLangMap10 = [
  ["auto", "auto"],
  ["en", "en"],
  ["ru", "ru"],
  ["pt", "pt"],
  ["es", "es"],
  ["zh-CN", "zh-CHS"],
  ["ja", "ja"],
  ["ko", "ko"],
  ["fr", "fr"],
  ["ar", "ar"],
  ["id", "id"],
  ["vi", "vi"],
  ["it", "it"]
];
var langMap15 = new Map(rawLangMap10);
var langMapReverse7 = new Map(
  rawLangMap10.map(([translatorLang, lang]) => [lang, translatorLang])
);
function truncate(q6) {
  const len = q6.length;
  if (len <= 20)
    return q6;
  return q6.substring(0, 10) + len + q6.substring(len - 10, len);
}
var Youdao = class extends Translation {
  constructor(serviceConfig, generalConfig) {
    super(serviceConfig, generalConfig);
    this.isSupportList = false;
    this.appId = "";
    this.appSecret = "";
    if (!serviceConfig || !serviceConfig.appId || !serviceConfig.appSecret) {
      throw new Error("appId and appSecret are required");
    }
    this.appId = serviceConfig.appId?.trim();
    this.appSecret = serviceConfig.appSecret?.trim();
  }
  static getAllProps() {
    return [{
      name: "appId",
      required: true,
      type: "text"
    }, {
      name: "appSecret",
      required: true,
      type: "password"
    }];
  }
  async translate(payload) {
    const { text, from, to } = payload;
    const salt = (/* @__PURE__ */ new Date()).getTime();
    const curTime = Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3);
    const str1 = this.appId + truncate(text) + salt + curTime + this.appSecret;
    const sign = await sha256(str1);
    const params = {
      q: text,
      appKey: this.appId,
      salt: salt.toString(),
      from: langMap15.get(from) || "auto",
      to: langMap15.get(to) || to,
      sign,
      signType: "v3",
      curtime: curTime.toString()
    };
    const urlSearchParams = new URLSearchParams(params);
    const res = await request2(
      {
        url: "https://openapi.youdao.com/api",
        method: "POST",
        body: urlSearchParams.toString(),
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        }
      }
    );
    const result = res;
    const l2 = result.l;
    const [remoteFrom, _2] = l2.split("2");
    return {
      text: result.translation.join("\n"),
      from: langMapReverse7.get(remoteFrom),
      to
    };
  }
};
var youdao_default = Youdao;

// services/mod.ts
var TranslationServices = {
  mock: {
    class: Mock,
    name: "Mock",
    homepage: "https://www.google.com"
  },
  mock2: {
    class: Mock,
    name: "Mock2",
    homepage: "https://www.google.com"
  },
  google: {
    class: Google,
    name: "Google",
    homepage: "https://translate.google.com/"
  },
  transmart: {
    class: Transmart,
    name: "Transmart",
    homepage: "https://transmart.qq.com/"
  },
  deepl: {
    class: deepl_default,
    name: "DeepL",
    homepage: "https://www.deepl.com/translator",
    docUrl: "https://immersive-translate.owenyoung.com/services/deepL"
  },
  volc: {
    class: mod_default2,
    name: "Volc",
    homepage: "https://www.volcengine.com/",
    docUrl: "https://immersive-translate.owenyoung.com/services/volcano"
  },
  volcAlpha: {
    class: VolcAlpha,
    name: "Volc Alpha",
    alpha: true,
    homepage: "https://www.volcengine.com/"
  },
  bing: {
    class: Bing,
    name: "Bing",
    homepage: "https://www.bing.com/translator"
  },
  // bai: {
  //   class: Bai,
  //   name: "Baidu(Alapa)",
  //   homepage: "https://fanyi.baidu.com/",
  //   alpha: true,
  // },
  tencent: {
    class: Tencent,
    name: "Tencent",
    homepage: "https://fanyi.qq.com/",
    docUrl: "https://immersive-translate.owenyoung.com/services/tencent"
  },
  baidu: {
    class: baidu_default,
    name: "Baidu",
    homepage: "https://fanyi.baidu.com/",
    docUrl: "https://immersive-translate.owenyoung.com/services/baidu"
  },
  caiyun: {
    class: caiyun_default,
    name: "Caiyun",
    homepage: "https://fanyi.caiyunapp.com/",
    docUrl: "https://immersive-translate.owenyoung.com/services/caiyun"
  },
  openl: {
    class: openl_default,
    name: "Openl",
    homepage: "https://openl.club/",
    docUrl: "https://immersive-translate.owenyoung.com/services/openL"
  },
  youdao: {
    class: youdao_default,
    name: "Youdao",
    homepage: "https://immersive-translate.owenyoung.com/services/youdao",
    docUrl: "https://hcfy.app/docs/services/youdao-api"
  },
  d: {
    class: D8,
    name: "D () ",
    alpha: true,
    homepage: "https://www.deepl.com/translator"
  },
  dpro: {
    class: D8,
    name: "DPro (Canary) ",
    canary: true,
    homepage: "https://www.deepl.com/translator"
  },
  deeplx: {
    class: Deeplx,
    name: "DeepLX (Beta)",
    beta: true,
    homepage: "https://www.deepl.com/translator"
  },
  niu: {
    class: niu_default,
    name: "niutrans",
    homepage: "https://niutrans.com/",
    docUrl: "https://immersive-translate.owenyoung.com/services/niu"
  }
};
function formatTranslationService(key, ctx) {
  const service = TranslationServices[key];
  const translationConfig = ctx.config.translationServices[key] || {};
  let ok = true;
  const allProps = service.class.getAllProps();
  if (allProps.length > 0) {
    const requiredProps = allProps.filter((prop) => prop.required);
    if (requiredProps.length > 0) {
      for (const prop of requiredProps) {
        if (!translationConfig[prop.name]) {
          ok = false;
          break;
        }
      }
    }
  }
  return {
    ...service,
    id: key,
    selected: ctx.translationService === key,
    ok,
    config: translationConfig,
    props: service.class.getProps(),
    allProps
  };
}
var allServiceKeys = Object.keys(
  TranslationServices
);
var getTranslationServices = (ctx) => {
  const { config } = ctx;
  const alpha = config.alpha;
  const beta = config.beta;
  const canary = config.canary;
  const debug = config.debug;
  return allServiceKeys.filter((key) => {
    const service = TranslationServices[key];
    if (key.startsWith("mock")) {
      if (debug) {
        return true;
      } else {
        return false;
      }
    }
    const isCanaryFeature = !!service.canary;
    const isAlphaFeature = !!service.alpha;
    const isBetaFeature = !!service.beta;
    if (isCanaryFeature && canary) {
      return true;
    } else if (isAlphaFeature && (alpha || canary)) {
      return true;
    } else if (isBetaFeature && (beta || alpha || canary)) {
      return true;
    } else if (key === ctx.translationService) {
      return true;
    }
    return !isAlphaFeature && !isBetaFeature && !isCanaryFeature;
  }).map((key) => {
    return formatTranslationService(key, ctx);
  });
};
async function translateSingleSentence(sentence, ctx) {
  if (!sentence.text) {
    return sentence;
  }
  const result = await translateMultipleSentences(
    {
      sentences: [sentence]
    },
    ctx
  );
  if (result.sentences.length > 0) {
    return {
      ...sentence,
      ...result.sentences[0]
    };
  }
  throw new CommonError("translateFailed", "translate failed");
}
async function translateMultipleSentences(payload, ctx, everySentenceCallback) {
  if (!payload.sentences.length) {
    return {
      ...payload
    };
  }
  const { config, translationService } = ctx;
  const generalConfig = config.translationGeneralConfig;
  const services = config.translationServices;
  const defaultTranslationEngine = translationService;
  const serviceConfig = services[defaultTranslationEngine] || {};
  const noCacheSentences = [];
  const finalResult = {
    sentences: Array(payload.sentences.length)
  };
  const sourceLength = payload.sentences.length;
  let sentenceIndex = -1;
  if (config.cache) {
    for (const sentence of payload.sentences) {
      sentenceIndex++;
      let cacheServiceKey = defaultTranslationEngine;
      if (defaultTranslationEngine === "openl") {
        cacheServiceKey = defaultTranslationEngine + "-" + serviceConfig.codename || openl_default.DEFAULT_CODENAME;
      }
      let res = null;
      try {
        res = await deadline(
          queryDb({
            originalText: sentence.text,
            from: sentence.from,
            to: sentence.to,
            service: cacheServiceKey
          }),
          1e3
        );
      } catch (e3) {
        log_default.warn("query cache DB error, but it's ok", e3);
      }
      if (res) {
        const result = {
          ...sentence,
          text: res.translatedText
        };
        finalResult.sentences[sentenceIndex] = result;
        if (everySentenceCallback) {
          everySentenceCallback(null, result, sentence);
        }
      } else {
        noCacheSentences.push(sentence);
      }
    }
  } else {
    noCacheSentences.push(...payload.sentences);
  }
  const resultLength = noCacheSentences.length;
  if (sourceLength - resultLength > 0) {
    log_default.debug(`use ${sourceLength - resultLength} sentences from cache`);
  }
  if (!noCacheSentences.length) {
    return finalResult;
  }
  let translator;
  try {
    translator = new TranslationServices[defaultTranslationEngine].class(
      serviceConfig,
      generalConfig
    );
    await translator.init();
  } catch (e3) {
    if (everySentenceCallback) {
      for (const sentence of noCacheSentences) {
        everySentenceCallback(e3, null, sentence);
      }
    }
    throw e3;
  }
  const noCacheResult = await translator.multipleTranslate(
    {
      sentences: noCacheSentences
    },
    serviceConfig,
    (err, a4, b4) => {
      if (everySentenceCallback) {
        everySentenceCallback(err, a4, b4);
        if (!err && a4 && !defaultTranslationEngine.startsWith("mock") && config.cache) {
          let cacheServiceKey = defaultTranslationEngine;
          if (defaultTranslationEngine === "openl") {
            cacheServiceKey = defaultTranslationEngine + "-" + serviceConfig.codename || openl_default.DEFAULT_CODENAME;
          }
          if (config.cache) {
            deadline(
              setDbStore(
                {
                  translatedText: a4.text,
                  from: b4.from,
                  to: b4.to,
                  detectedFrom: a4.from,
                  key: md5(b4.text),
                  service: cacheServiceKey
                }
              ),
              3e3
            ).catch((e3) => {
              log_default.warn("set cache DB error", e3);
            });
          }
        }
      }
    }
  );
  for (const sentence of noCacheResult.sentences) {
    const index = finalResult.sentences.findIndex((s4) => !s4);
    if (index === -1) {
      throw new CommonError("translateFailed", "can not match the result");
    }
    finalResult.sentences[index] = sentence;
  }
  return finalResult;
}

// utils/url_match.ts
var matchAll = ["*://*/*", "*", "*://*"];
var placeholder = "immersive-translate-wildcard-placeholder.com";
function getMatchedUrl(rawUrl, rawMatches) {
  let matches = [];
  if (!rawMatches) {
    return null;
  }
  if (rawMatches && !Array.isArray(rawMatches)) {
    matches = [rawMatches];
  } else {
    matches = rawMatches;
  }
  if (matches.length === 0) {
    return null;
  }
  if (matches.some((m4) => matchAll.includes(m4))) {
    return rawUrl;
  }
  const urlObj = new URL(rawUrl);
  urlObj.hash = "";
  urlObj.search = "";
  const url = urlObj.href;
  const hostname2 = urlObj.hostname;
  if (matches && matches.length > 0) {
    const matched = matches.find((match) => {
      const rawMatch = match;
      if (match === hostname2) {
        return true;
      } else if (matchAll.includes(match)) {
        return true;
      } else if (!match.includes("*") && match.includes("://")) {
        try {
          const matchUrl = new URL(match);
          if (matchUrl.pathname === "/" && !match.endsWith("/")) {
            return matchUrl.hostname === hostname2;
          } else {
            return isTwoUrlMatched(url, match);
          }
        } catch (_e3) {
        }
        return false;
      } else {
        let scheme;
        const rawMatch2 = match;
        if (match.includes("://")) {
          scheme = match.split("://")[0];
        } else {
          scheme = "*";
          match = "https://" + match;
        }
        const validUrlMatch = match.replace(
          /\*/g,
          placeholder
        );
        let validUrlObj;
        try {
          validUrlObj = new URL(validUrlMatch);
        } catch (_e3) {
          log_default.debug(
            "invalid match pattern",
            validUrlMatch,
            "raw match value:",
            rawMatch2
          );
          return false;
        }
        const hostname3 = validUrlObj.hostname;
        let pathname = validUrlObj.pathname;
        if (pathname === "/") {
          if (!rawMatch2.replace("://", "").includes("/")) {
            pathname = "/*";
          }
        }
        const regex = makeRegExp(
          scheme + ":",
          restorePlaceholderToWildcard(hostname3),
          restorePlaceholderToWildcard(pathname)
        );
        if (regex) {
          const clonedUrl = new URL(url);
          clonedUrl.port = "";
          return regex.test(clonedUrl.href);
        } else {
          return false;
        }
      }
    });
    if (matched) {
      return matched;
    }
  }
  return null;
}
function restorePlaceholderToWildcard(str) {
  return str.replace(placeholder, "*");
}
function makeRegExp(scheme, host, path) {
  let regex = "^";
  if (scheme === "*:") {
    regex += "(http:|https:|file:)";
  } else {
    regex += scheme;
  }
  regex += "//";
  if (host) {
    if (scheme === "file:") {
    } else {
      if (host === "*") {
        regex += "[^/]+?";
      } else {
        if (host.match(/^\*\./)) {
          regex += "[^/]*?";
          host = host.substring(2);
        }
        regex += host.replace(/\./g, "\\.").replace(/\*/g, "[^/]*");
      }
    }
  }
  if (path) {
    if (path === "*" || path === "/*") {
      regex += "(/.*)?";
    } else if (path.includes("*")) {
      regex += path.replace(/\*/g, ".*?");
      regex += "/?";
    } else {
      regex += path.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  } else {
    regex += "/?";
  }
  regex += "$";
  return new RegExp(regex);
}
function isMatchUrl(url, rawMatches) {
  return getMatchedUrl(url, rawMatches) !== null;
}
function isTwoUrlMatched(url1, url2) {
  const urlObj1 = new URL(url1);
  const urlObj2 = new URL(url2);
  return urlObj1.hostname === urlObj2.hostname && urlObj1.pathname === urlObj2.pathname && urlObj1.protocol === urlObj2.protocol && urlObj1.port === urlObj2.port;
}

// dom/context.ts
async function getContext(options2) {
  const { url, config, state } = options2;
  const urlObj = new URL(url);
  let sourceLanguage = "auto";
  const {
    translationParagraphLanguagePattern,
    translationService,
    translationServices,
    translationTheme,
    translationThemePatterns,
    translationUrlPattern,
    targetLanguage,
    sourceLanguageUrlPattern,
    immediateTranslationPattern
  } = config;
  const isDetectParagraphLanguage = isMatched(
    url,
    translationParagraphLanguagePattern
  );
  const isImmediateTranslate = isMatched(url, immediateTranslationPattern);
  let defaultTranslationService = translationService;
  const services = Object.keys(translationServices);
  for (const service of services) {
    const serviceConfig = translationServices[service];
    if (isMatched(url, serviceConfig)) {
      defaultTranslationService = service;
      break;
    }
  }
  let defaultTheme = translationTheme;
  const themes = Object.keys(translationThemePatterns);
  for (const theme of themes) {
    const themeConfig = translationThemePatterns[theme];
    if (isMatched(url, themeConfig)) {
      defaultTheme = theme;
      break;
    }
  }
  const isTranslateUrl = isMatched(url, translationUrlPattern);
  let isTranslateExcludeUrl = isMatchedExclude(
    url,
    translationUrlPattern
  );
  if (!isTranslateExcludeUrl) {
    isTranslateExcludeUrl = isMatchUrl(url, buildinExcludeUrls);
  }
  const sourceConfigLanguages = Object.keys(sourceLanguageUrlPattern);
  const sourceLanguageReverseMap = {};
  for (const language of sourceConfigLanguages) {
    const matchPattern = sourceLanguageUrlPattern[language];
    if (matchPattern && matchPattern.matches) {
      for (const match of matchPattern.matches) {
        sourceLanguageReverseMap[match] = language;
      }
    }
  }
  const sourceUrlMatches = Object.keys(sourceLanguageReverseMap);
  const sourceUrlMatched = getMatchedUrl(url, sourceUrlMatches);
  if (sourceUrlMatched) {
    sourceLanguage = sourceLanguageReverseMap[sourceUrlMatched] ?? "auto";
    if (sourceLanguageReverseMap[sourceUrlMatched] && sourceLanguageReverseMap[sourceUrlMatched] !== "auto") {
      setCurrentPageLanguageByClient(
        sourceLanguageReverseMap[sourceUrlMatched]
      );
    }
  }
  const defaultTargetLanguage = targetLanguage || "zh-CN";
  const hostname2 = urlObj.hostname;
  const encryptedHostname = await sha256(hostname2);
  const pathAndQueryAndHash = urlObj.pathname + urlObj.search + urlObj.hash;
  const encryptedPath = await sha256(pathAndQueryAndHash);
  const encryptedUrl = `https://${encryptedHostname}.com/${encryptedPath}`;
  const localConfig2 = await getLocalConfig();
  let translationStartMode = config.translationStartMode;
  if (translationStartMode === "dynamic") {
    if (isImmediateTranslate) {
      translationStartMode = "immediate";
    }
  }
  const ctx = {
    targetLanguage: defaultTargetLanguage,
    config,
    translationService: defaultTranslationService,
    isTranslateUrl,
    sourceLanguage,
    isTranslateExcludeUrl,
    rule: config.generalRule,
    url,
    encryptedUrl,
    state: state ? Object.assign({
      translationArea: config.translationArea,
      translationStartMode,
      isAutoTranslate: false,
      isNeedClean: false,
      isDetectParagraphLanguage,
      translationTheme: defaultTheme
    }, state) : {
      translationArea: config.translationArea,
      translationStartMode,
      isAutoTranslate: false,
      isNeedClean: false,
      isDetectParagraphLanguage,
      translationTheme: defaultTheme
    },
    localConfig: localConfig2
  };
  if (ctx.state.translationArea === "body") {
    ctx.config.generalRule.excludeTags = ctx.config.generalRule.excludeTags.filter((tag) => {
      return !ctx.config.generalRule.bodyTranslateTags.includes(tag);
    });
    ctx.config.generalRule.additionalExcludeSelectors = ctx.config.generalRule.additionalExcludeSelectors.filter(
      (selector) => selector !== ".btn"
    );
  }
  if (ctx.translationService === "d") {
    config.immediateTranslationTextCount = 0;
  }
  const rules = config.rules;
  let rule;
  if (globalThis.PDFViewerApplication) {
    rule = rules.find((rule2) => rule2.isPdf);
  } else {
    rule = rules.find((rule2) => {
      const isMatchedRule = isMatched(url, rule2);
      return isMatchedRule;
    });
  }
  if (ctx.rule.isPdf) {
    ctx.state.translationArea = "main";
  }
  if (ctx.state.translationArea === "body") {
    ctx.rule.paragraphMinTextCount = 1;
    ctx.rule.paragraphMinWordCount = 1;
  }
  const generalRule = config.generalRule;
  if (rule) {
    ctx.rule = mergeRule(generalRule, rule);
  }
  if (ctx.state.translationArea === "body") {
    if (ctx.rule.excludeTags) {
      ctx.rule.excludeTags = ctx.rule.excludeTags.filter((tag) => {
        return !ctx.rule.bodyTranslateTags.includes(tag) && !ctx.rule.forceTranslateTags.includes(tag);
      });
    }
  }
  return ctx;
}
function isMatched(url, matchPattern) {
  if (!matchPattern) {
    return false;
  }
  const { matches, excludeMatches, selectorMatches, excludeSelectorMatches } = matchPattern;
  if (excludeMatches && excludeMatches.length > 0) {
    const isMatchedExclude2 = isMatchUrl(url, excludeMatches);
    if (isMatchedExclude2) {
      return false;
    }
  }
  if (matches && matches.length > 0) {
    const isMatchedUrl = isMatchUrl(url, matches);
    if (isMatchedUrl) {
      return true;
    }
  }
  if (excludeSelectorMatches && excludeSelectorMatches.length > 0) {
    const isMatchedExclude2 = isMatchSelectors(excludeSelectorMatches);
    if (isMatchedExclude2) {
      return false;
    }
  }
  if (selectorMatches && selectorMatches.length > 0) {
    const isMatchedSelector = isMatchSelectors(selectorMatches);
    if (isMatchedSelector) {
      return true;
    }
  }
  return false;
}
function isMatchedExclude(url, matchPattern) {
  if (!matchPattern) {
    return false;
  }
  const { excludeMatches, excludeSelectorMatches } = matchPattern;
  if (excludeMatches && excludeMatches.length > 0) {
    const isMatchedExclude2 = isMatchUrl(url, excludeMatches);
    if (isMatchedExclude2) {
      return true;
    }
  }
  if (excludeSelectorMatches && excludeSelectorMatches.length > 0) {
    const isMatchedExclude2 = isMatchSelectors(excludeSelectorMatches);
    if (isMatchedExclude2) {
      return true;
    }
  }
  return false;
}

// dom/translate_page.ts
var pageStatus = "Original";
var currentParagraphIds = [];
var waitToTranslateParagraphIds = /* @__PURE__ */ new Set();
var allNewDynamicElements = [];
var allIntersectionObserver = [];
var allResizebleObserver = [];
var currentNewDynamicElements = [];
var oldUrl = getRealUrl().split("#")[0];
var currentTranslatedTextLength = 0;
var globalContext;
var debounceTranslateCurrentQueue = le(translateCurrentQueue, 300);
var debounceTranslateNewDynamicNodes = debounce(
  translateNewDynamicNodes,
  200
);
var env3 = getEnv();
var isProd2 = env3.PROD === "1";
var titleMutationObserver;
var mutationObserverMap = /* @__PURE__ */ new Map();
var mainMutaionObserver;
var originalPageTitle = "";
async function toggleTranslatePage() {
  if (getPageStatus() === "Original") {
    let ctx = await getGlobalContext(getRealUrl(), {});
    ctx.state.translationTheme = ctx.config.translationTheme;
    ctx = await getGlobalContext(getRealUrl(), {});
    await translatePage(globalContext);
  } else if (getPageStatus() === "Translated" || getPageStatus() === "Error") {
    restorePage();
  }
}
async function toggleTranslationMask() {
  if (getPageStatus() === "Original") {
    globalContext = await getGlobalContext(getRealUrl(), {
      translationTheme: "mask"
    });
    await translatePage(globalContext);
  } else if (getPageStatus() === "Translated") {
    const allFrames = [
      document.body,
      ...mutationObserverMap.keys()
    ];
    const currentTranslationTheme = globalContext?.state.translationTheme;
    for (const frame of allFrames) {
      const currentRootTheme = getAttribute(
        frame,
        translationFrameRootThemeAttributeNameForJs,
        true
      );
      if (currentTranslationTheme === "mask") {
        if (currentRootTheme !== "none") {
          setAttribute(
            frame,
            translationFrameRootThemeAttributeNameForJs,
            "none",
            true
          );
        } else {
          setAttribute(
            frame,
            translationFrameRootThemeAttributeNameForJs,
            "mask",
            true
          );
        }
      } else {
        if (currentRootTheme !== "mask") {
          setAttribute(
            frame,
            translationFrameRootThemeAttributeNameForJs,
            "mask",
            true
          );
        } else {
          setAttribute(
            frame,
            translationFrameRootThemeAttributeNameForJs,
            "none",
            true
          );
        }
      }
    }
  }
}
function showTranslationOnly() {
}
function restorePage() {
  clean();
  const allFrames = [
    document.body,
    ...mutationObserverMap.keys()
  ];
  for (const rootFrame of allFrames) {
    disableMutatinObserver(rootFrame);
    const elements = rootFrame.querySelectorAll(
      "." + translationTargetElementWrapperClass
    );
    elements.forEach((element) => {
      element.remove();
    });
    const pdfElements = rootFrame.querySelectorAll(
      "." + translationPdfTargetContainerClass
    );
    pdfElements.forEach((element) => {
      element.remove();
    });
    const elementsEffected = rootFrame.querySelectorAll(
      "[" + sourceElementEffectAttributeName + "]"
    );
    elementsEffected.forEach((element) => {
      if (isProd2) {
        delete element[elementMarkRootKey];
        const allKeys = Object.keys(element.dataset);
        const keys = allKeys.filter((key) => key.startsWith(brandIdForJs));
        for (const key of keys) {
          delete element.dataset[key];
        }
      } else {
        const allKeys = Object.keys(element.dataset);
        const keys = allKeys.filter((key) => key.startsWith(brandIdForJs));
        for (const key of keys) {
          delete element.dataset[key];
        }
      }
      element.removeAttribute(sourceElementEffectAttributeName);
    });
  }
  disableTitleMutationObserver();
  setPageTranslatedStatus("Translating");
  if (originalPageTitle) {
    document.title = originalPageTitle;
  }
  setPageTranslatedStatus("Original");
}
function onElementVisible(paragraph, callback) {
  let isCalled = false;
  const firstElement = getFirstHTMLElement(paragraph.elements);
  const lastElement = getLastHTMLElement(paragraph.elements);
  waitToTranslateParagraphIds.add(paragraph.id);
  const observers = [];
  if (firstElement) {
    const observe = new IntersectionObserver((entries, observer) => {
      entries.forEach((entry) => {
        if (entry.intersectionRatio > 0) {
          observer.disconnect();
          if (!isCalled) {
            isCalled = true;
            callback(paragraph);
          }
        }
      });
    });
    allIntersectionObserver.push(observe);
    observers.push(observe);
    observe.observe(firstElement);
  }
  if (lastElement && lastElement !== firstElement) {
    const observe = new IntersectionObserver((entries, observer) => {
      entries.forEach((entry) => {
        if (entry.intersectionRatio > 0) {
          observer.disconnect();
          if (!isCalled) {
            isCalled = true;
            callback(paragraph);
          }
        }
      });
    });
    allIntersectionObserver.push(observe);
    observers.push(observe);
    observe.observe(lastElement);
  }
  const paragraphEntiry = getParagraph(paragraph.id);
  if (paragraphEntiry) {
    paragraphEntiry.observers = observers;
    setParagraph(paragraph.id, paragraphEntiry);
  }
}
function onHiddenElementVisible(element, callback) {
  if (element) {
    const resizewatcher = new ResizeObserver((entries, observer) => {
      for (const entry of entries) {
        if (entry.contentRect.width > 10) {
          observer.disconnect();
          callback(entry.target);
        }
      }
    });
    resizewatcher.observe(element);
    allResizebleObserver.push(resizewatcher);
  }
}
async function translateNewDynamicNodes(ctx) {
  const currentNewDynamicNodes = [...currentNewDynamicElements];
  currentNewDynamicElements = [];
  const frameMap = /* @__PURE__ */ new Map();
  currentNewDynamicNodes.forEach((node) => {
    if (!frameMap.has(node.rootFrame)) {
      frameMap.set(node.rootFrame, []);
    }
    frameMap.get(node.rootFrame)?.push(node.element);
  });
  for (const [rootFrame, elements] of frameMap) {
    try {
      const allContainers = [];
      for (const element of elements) {
        const rawContainers = getContainers(
          element,
          ctx
        );
        if (rawContainers.length === 0) {
          continue;
        }
        const containers = rawContainers;
        allContainers.push(...containers);
      }
      await translateContainers(allContainers, rootFrame, ctx);
    } catch (e3) {
      log_default.error(`translateNewDynamicNodes error: ${e3.message}`);
    }
  }
}
function translationParagraph(visibleParagraph, ctx) {
  waitToTranslateParagraphIds.delete(visibleParagraph.id);
  const paragraphWithState = getParagraph(visibleParagraph.id);
  if (paragraphWithState) {
    if (paragraphWithState.observers && paragraphWithState.observers.length > 0) {
      paragraphWithState.observers.forEach((observer) => {
        observer.disconnect();
      });
    }
    paragraphWithState.observers = [];
    paragraphWithState.state = "Translating";
    setParagraph(visibleParagraph.id, paragraphWithState);
  }
  const id = visibleParagraph.id;
  currentTranslatedTextLength += visibleParagraph.text.length;
  const realElements = getHTMLElements(visibleParagraph.elements);
  if (!visibleParagraph.isPdf) {
    const lastElement = getLastHTMLElement(visibleParagraph.elements);
    let position = "afterend";
    if (visibleParagraph.elements.length > 0 && lastElement) {
      if (realElements.length === 1) {
        position = "beforeend";
      } else {
        if (!isInlineElement(
          visibleParagraph.elements[0],
          ctx.rule
        )) {
          position = "beforeend";
        }
      }
    }
    if (ctx.rule.insertPosition) {
      position = ctx.rule.insertPosition;
    }
    const targetTranslationWrapper = document.createElement("span");
    targetTranslationWrapper.classList.add(
      "notranslate",
      translationTargetElementWrapperClass
    );
    targetTranslationWrapper.id = `${translationTargetElementWrapperClass}-${id}`;
    const loadingHtml = getLoadingHTML(
      ctx.config.loadingTheme
    );
    targetTranslationWrapper.innerHTML = loadingHtml;
    if (position === "beforeend") {
      const innerElement = getTheLastTextNodeParentElement(lastElement);
      if (innerElement) {
        innerElement.appendChild(targetTranslationWrapper);
      } else {
        lastElement.appendChild(targetTranslationWrapper);
      }
    } else if (position === "afterend") {
      lastElement.insertAdjacentElement(position, targetTranslationWrapper);
    } else {
      throw new Error("not support position");
    }
  } else {
    const firstElement = getFirstHTMLElement(visibleParagraph.elements);
    const elementStyle = globalThis.getComputedStyle(firstElement);
    const top = elementStyle.top;
    let fontSize = elementStyle.fontSize;
    const fontSizeNumber = parseFloat(fontSize.slice(0, -2));
    if (!isNaN(fontSizeNumber)) {
      if (fontSizeNumber > 20) {
        fontSize = "20px";
      }
    }
    const targetContainer = visibleParagraph.targetContainer;
    const paragraphTarget = document.createElement("span");
    if (realElements.length === 1) {
      paragraphTarget.style.fontSize = fontSize;
    }
    paragraphTarget.id = `${translationTargetElementWrapperClass}-${id}`;
    paragraphTarget.style.top = top;
    let firstElementLeft = getAttribute(firstElement, sourceElementLeft);
    const minLeft = realElements.reduce((prev, current) => {
      const left = getAttribute(current, sourceElementLeft);
      if (left && left < prev) {
        return left;
      }
      return prev;
    }, 1e3);
    const maxRight = realElements.reduce((prev, current) => {
      const right = getAttribute(current, sourceElementRight);
      if (right && right > prev) {
        return right;
      }
      return prev;
    }, 0);
    let width = maxRight - minLeft;
    if (width < 30) {
    }
    if (width > 600) {
      width = 600;
    }
    if (firstElementLeft < 200) {
      firstElementLeft = 10;
    }
    if (firstElementLeft) {
      if (firstElementLeft < 0) {
        firstElementLeft = 0;
      }
    }
    paragraphTarget.style.left = `${minLeft || 10}px`;
    if (minLeft < 400) {
      paragraphTarget.style.width = width + "px";
    } else {
      paragraphTarget.style.width = `calc(100% - ${minLeft}px)`;
    }
    paragraphTarget.classList.add(
      `notranslate`,
      `${translationTargetElementWrapperClass}`
    ), targetContainer.appendChild(paragraphTarget);
  }
  currentParagraphIds.push(id);
  debounceTranslateCurrentQueue(ctx);
}
function addParagraphToQueue(paragraph, ctx) {
  if (ctx.state.translationStartMode === "dynamic") {
    if (currentTranslatedTextLength > ctx.config.immediateTranslationTextCount) {
      onElementVisible(paragraph, (visibleParagraph) => {
        translationParagraph(visibleParagraph, ctx);
      });
    } else {
      translationParagraph(paragraph, ctx);
    }
  } else {
    translationParagraph(paragraph, ctx);
  }
}
async function translatePage(ctx) {
  if (pageStatus === "Translating") {
    return;
  }
  setPageTranslatedStatus("Translating");
  if (!ctx) {
    ctx = await getGlobalContext(getRealUrl(), {});
  }
  if (!ctx.state.isAutoTranslate) {
    if (ctx.config.tempTranslateDomainMinutes > 0) {
      const now = Date.now();
      const urlObj = new URL(ctx.url);
      const currentDomain = urlObj.hostname;
      const currentTempTranslationDomains = ctx.localConfig.tempTranslationUrlMatches || [];
      const index = currentTempTranslationDomains.findIndex(
        (item) => item.match === currentDomain && item.expiredAt > now
      );
      let isChanged = false;
      if (index > -1) {
      } else {
        currentTempTranslationDomains.push({
          match: currentDomain,
          expiredAt: now + ctx.config.tempTranslateDomainMinutes * 60 * 1e3
        });
        isChanged = true;
      }
      if (isChanged) {
        await setLocalConfig({
          ...ctx.localConfig,
          tempTranslationUrlMatches: [
            ...currentTempTranslationDomains
          ]
        });
      }
    }
  }
  ctx.state.isAutoTranslate = true;
  const currentScrollOffset = globalThis.scrollY;
  const currentWindowHeight = globalThis.innerHeight;
  if (currentScrollOffset >= currentWindowHeight) {
    ctx.config.immediateTranslationTextCount = 0;
  }
  log_default.debug("ctx", ctx);
  if (ctx.state.isNeedClean) {
    restorePage();
  } else {
    globalContext.state.isNeedClean = true;
  }
  if (ctx.rule.normalizeBody) {
    const element = document.querySelector(ctx.rule.normalizeBody);
    if (element) {
      document.body = document.body.cloneNode(true);
    }
  }
  addToUnmountQueue(() => {
    currentTranslatedTextLength = 0;
    cleanParagraphs();
    allIntersectionObserver.forEach((observer) => {
      observer.disconnect();
    });
    allResizebleObserver.forEach((observer) => {
      observer.disconnect();
    });
    allIntersectionObserver = [];
    waitToTranslateParagraphIds.clear();
  });
  setPageTranslatedStatus("Translating");
  try {
    const allFrames = [document.body];
    const allFramesElements = document.querySelectorAll("iframe");
    allFramesElements.forEach((frame) => {
      if (isInlineIframe(frame)) {
        allFrames.push(frame.contentDocument.body);
        injectCSS(frame.contentDocument, env3.IMMERSIVE_TRANSLATE_INJECTED_CSS);
      }
    });
    if (ctx.rule.shadowRootSelectors && ctx.rule.shadowRootSelectors.length > 0) {
      const shadowRootHosts = getElementsBySelectors(
        document.body,
        ctx.rule.shadowRootSelectors
      );
      shadowRootHosts.forEach((host) => {
        if (host.shadowRoot) {
          if (host.shadowRoot.mode === "open") {
            allFrames.push(host.shadowRoot);
          }
        }
      });
    }
    let containersCount = 0;
    setPageTranslatedStatus("Translating");
    log_default.debug("allFrames", allFrames);
    for (const rootFrame of allFrames) {
      const containerCount = await translateFrame(rootFrame, ctx);
      containersCount += containerCount;
    }
    if (containersCount === 0) {
      setPageTranslatedStatus("Translated");
    }
    translateTitle(ctx).catch((e3) => {
      log_default.error(
        `translateTitle error:`,
        e3.name,
        e3.message,
        e3.details || ""
      );
    });
    enableTitleMutationObserver(ctx);
  } catch (e3) {
    setPageTranslatedStatus("Error");
    log_default.error(e3);
  }
}
async function translateFrame(rootFrame, ctx) {
  markContainers(rootFrame, ctx.rule);
  const containers = getContainers(rootFrame, ctx);
  log_default.debug("detect containers", containers);
  const { rule } = ctx;
  if (containers.length > 0) {
    await translateContainers(containers, rootFrame, ctx);
  }
  const observer = enableMutatinObserver(rootFrame, rule, ctx);
  if (rootFrame === document.body) {
    mainMutaionObserver = observer;
  } else {
    mutationObserverMap.set(rootFrame, observer);
  }
  return containers.length;
}
async function getGlobalContext(url, state) {
  const config = await getConfig2();
  if (!globalContext) {
    const options2 = {
      url,
      config,
      state
    };
    const ctx = await getContext(options2);
    globalContext = ctx;
  } else {
    const options2 = {
      url,
      config,
      state: { ...globalContext.state, ...state }
    };
    const ctx = await getContext(options2);
    globalContext = ctx;
  }
  return globalContext;
}
async function toggleTranslateTheMainPage() {
  if (getPageStatus() === "Original") {
    await translateTheMainPage();
  } else if (getPageStatus() === "Translated" || getPageStatus() === "Error") {
    globalContext = await getGlobalContext(getRealUrl(), {});
    if (globalContext.state.translationArea !== "main") {
      await translateTheMainPage();
    } else {
      restorePage();
    }
  }
}
async function translateTheMainPage() {
  globalContext = await getGlobalContext(getRealUrl(), {
    translationArea: "main"
  });
  await translatePage(globalContext);
}
async function translateTheWholePage() {
  globalContext = await getGlobalContext(getRealUrl(), {
    translationArea: "body"
  });
  await translatePage(globalContext);
}
async function toggleTranslateTheWholePage() {
  if (getPageStatus() === "Original") {
    await translateTheWholePage();
  } else if (getPageStatus() === "Translated" || getPageStatus() === "Error") {
    globalContext = await getGlobalContext(getRealUrl(), {});
    if (globalContext.state.translationArea !== "body") {
      globalContext.state.translationArea = "body";
      globalContext = await getGlobalContext(getRealUrl(), {});
      await translatePage(globalContext);
    } else {
      restorePage();
    }
  }
}
async function translateToThePageEndImmediately() {
  globalContext = await getGlobalContext(getRealUrl(), {
    translationArea: "body",
    translationStartMode: "immediate"
  });
  await translatePage(globalContext);
  await translateNewDynamicNodes(globalContext);
}
async function translateTitle(ctx) {
  const pageTitle = document.title;
  if (!pageTitle) {
    return;
  }
  if (pageTitle.includes(titleDelimiters)) {
    return;
  }
  if (originalPageTitle !== pageTitle) {
    originalPageTitle = pageTitle;
  }
  let currentLang = "auto";
  if (!ctx.state.isDetectParagraphLanguage) {
    currentLang = getCurrentPageLanguageByClient();
  }
  if (currentLang === "auto") {
    const detectedLang = await detectLanguage({
      text: pageTitle,
      minLength: 10
    });
    if (isSameTargetLanguage(detectedLang, ctx.targetLanguage)) {
      return;
    }
  }
  try {
    const result = await translateSingleSentence({
      id: 0,
      url: ctx.url,
      text: pageTitle,
      from: currentLang,
      to: ctx.targetLanguage,
      fromByClient: currentLang
    }, ctx);
    if (result && result.text) {
      document.title = originalPageTitle + titleDelimiters + result.text;
    }
  } catch (e3) {
    throw e3;
  }
}
function setLoadingToParagraph(rootFrame, id, ctx) {
  const element = rootFrame.querySelector(
    "#" + translationTargetElementWrapperClass + "-" + id
  );
  if (element) {
    element.innerHTML = getLoadingHTML(ctx.config.loadingTheme);
  }
}
function getLoadingHTML(theme) {
  return `&#160;<span class="${brandId}-loading-${theme} notranslate"></span>`;
}
async function translateContainers(containers, rootFrame, ctx) {
  const { rule } = ctx;
  for (const container of containers) {
    markContainers(container, rule);
  }
  let targetContainers = [];
  if (!ctx.rule.isPdf) {
    setPageTranslatedStatus("Translating");
    const normalizeResult = normalizeContainer(
      containers,
      rule
    );
    const { hiddenElements } = normalizeResult;
    for (const element of hiddenElements) {
      onHiddenElementVisible(element, () => {
        removeAttribute(element, sourceElementExcludeAttributeName, true);
        translateContainers([element], rootFrame, ctx);
      });
    }
    setPageTranslatedStatus("Translating");
  } else {
    if (containers.length > 0) {
      setPageTranslatedStatus("Translating");
      const normalizeResult = normalizeContainer2(
        containers,
        rule
      );
      targetContainers = normalizeResult.targetContainers;
    }
  }
  let paragraphs = [];
  if (ctx.rule.isPdf) {
    paragraphs = await getParagraphs2(
      rootFrame,
      containers,
      ctx,
      targetContainers
    );
  } else {
    containers = containers.filter((container) => {
      return !isExcludeElement(container, rule, false);
    });
    paragraphs = await getParagraphs(
      rootFrame,
      containers,
      ctx
    );
  }
  setPageTranslatedStatus("Translating");
  if (paragraphs.length === 0) {
    setPageTranslatedStatus("Translated");
    return;
  }
  log_default.debug("detect paragraphs", paragraphs);
  for (const paragraph of paragraphs) {
    addParagraphToQueue(paragraph, ctx);
  }
  setPageTranslatedStatus("Translated");
}
async function translateParagraphById(id) {
  const paragraph = getParagraph(id);
  if (!paragraph) {
    throw new Error(`paragraph not found`);
  }
  const ctx = await getGlobalContext(getRealUrl(), {});
  setLoadingToParagraph(paragraph.rootFrame, id, ctx);
  const sentence = {
    id: paragraph.id,
    text: paragraph.text,
    from: paragraph.languageByLocal,
    fromByClient: paragraph.languageByClient,
    to: ctx.targetLanguage,
    url: ctx.encryptedUrl
  };
  try {
    const result = await translateSingleSentence(sentence, ctx);
    onParagraphTranslated(null, result, sentence, ctx);
  } catch (e3) {
    onParagraphTranslated(e3, null, sentence, ctx);
  }
}
function onParagraphTranslated(err, translatedSentence, sentenceRequest, ctx) {
  const paragraphWithState = getParagraph(sentenceRequest.id);
  if (paragraphWithState && (err || !translatedSentence)) {
    if (!err) {
      log_default.error(`translate error`, translatedSentence);
      err = new Error("no response from server");
    }
    const wrapperId = sentenceRequest.id;
    const wrapper = paragraphWithState.rootFrame.querySelector(
      `#${translationTargetElementWrapperClass}-${wrapperId}`
    );
    let errorMessage = err.message.replaceAll("\n", "");
    errorMessage = errorMessage.replaceAll('"', "&quot;");
    if (paragraphWithState) {
      paragraphWithState.state = "Error";
      setParagraph(paragraphWithState.id, paragraphWithState);
    }
    const errorHtml = `<span class="${brandId}-error notranslate"> <span class="immersive-translate-tooltip" data-immersive-translate-tooltip-text="${errorMessage}"><button class="${brandId}-clickable-button notranslate" title="${errorMessage}">\u2757</button></span> <button class="${brandId}-clickable-button notranslate" data-${brandId}-paragraph-id="${wrapperId}" data-${brandId}-action="retry">\u{1F504}</button></span>`;
    if (wrapper) {
      wrapper.innerHTML = errorHtml;
    }
  } else {
    const paragraph = getParagraph(sentenceRequest.id);
    if (paragraph) {
      paragraph.state = "Translated";
      setParagraph(paragraph.id, paragraph);
      const targetItem = paragraphToHtml(
        paragraph,
        translatedSentence,
        ctx
      );
      const wrapperId = translatedSentence.id;
      const wrapper = paragraph.rootFrame.querySelector(
        `#${translationTargetElementWrapperClass}-${wrapperId}`
      );
      if (wrapper) {
        wrapper.innerHTML = targetItem.html;
        const originalElements = paragraph.rootFrame.querySelectorAll(
          `[${sourceElementParagraphAttributeName}="${wrapperId}"]`
        );
        originalElements.forEach((element) => {
          setAttribute(
            element,
            sourceElementTranslatedMarkAttributeName,
            "1"
          );
        });
      }
    } else {
      log_default.error(`paragraph not found`, sentenceRequest.id);
    }
  }
}
async function translateCurrentQueue(ctx) {
  if (currentParagraphIds.length === 0) {
    return Promise.resolve();
  }
  const ids = [...currentParagraphIds];
  currentParagraphIds = [];
  let currentParagraphLang = "auto";
  if (!ctx.state.isDetectParagraphLanguage) {
    currentParagraphLang = getCurrentPageLanguage();
  }
  const payload = {
    sentences: ids.filter((id) => getParagraph(id)).map((id) => {
      const paragraph = getParagraph(id);
      let from = paragraph.languageByLocal;
      if (from === "auto") {
        from = currentParagraphLang;
      }
      return {
        id: paragraph.id,
        url: ctx.encryptedUrl,
        text: paragraph.text,
        from,
        fromByClient: paragraph.languageByClient,
        to: ctx.targetLanguage
      };
    })
  };
  const sentenceLength = payload.sentences.length;
  if (sentenceLength > 0) {
    setPageTranslatedStatus("Translating");
    try {
      await translateMultipleSentences(
        payload,
        ctx,
        (err, translatedSentence, sentenceRequest) => {
          onParagraphTranslated(err, translatedSentence, sentenceRequest, ctx);
        }
      );
    } catch (e3) {
      setPageTranslatedStatus("Error");
      log_default.error(
        `translateCurrentQueue error`,
        e3.name,
        e3.message,
        e3.details || " "
      );
      return;
    }
  }
  setPageTranslatedStatus("Translated");
}
function setPageTranslatedStatus(_pageStatus) {
  pageStatus = _pageStatus;
  sendPageTranslatedStatus(pageStatus);
}
function enableMutatinObserver(rootFrame, rule, ctx) {
  log_default.debug(`enableMutatinObserver for `, rootFrame);
  disableMutatinObserver(rootFrame);
  allNewDynamicElements = [];
  currentNewDynamicElements = [];
  const inlineAndIgnoreAndTextTags = rule.inlineTags.concat(rule.excludeTags).concat("#text", "BR");
  const mutationObserver = new MutationObserver(function(mutations) {
    mutations.forEach((mutation) => {
      if (rootFrame === document.body) {
        const currentUrl = getRealUrl();
        const currentUrlWithoutHash = currentUrl.split("#")[0];
        if (currentUrlWithoutHash !== oldUrl) {
          if (rule.observeUrlChange) {
            oldUrl = currentUrl.split("#")[0];
            clean();
            disableMutatinObserver(rootFrame);
            disableTitleMutationObserver();
            setTimeout(() => {
              log_default.debug(`url changed, reinit page`);
              initPage();
            }, rule.urlChangeDelay);
            const event = new Event(pageUrlChangedEventName);
            document.dispatchEvent(event);
            return;
          }
        }
      }
      mutation.addedNodes.forEach((addedNode) => {
        if (addedNode.nodeType === Node.ELEMENT_NODE) {
          const element = addedNode;
          if (element.nodeName === "IFRAME") {
            if (isInlineIframe(element)) {
              setTimeout(() => {
                injectCSS(
                  element.contentDocument,
                  env3.IMMERSIVE_TRANSLATE_INJECTED_CSS
                );
                translateFrame(
                  element.contentDocument.body,
                  ctx
                ).catch((e3) => {
                  log_default.error(
                    `translateFrame error`,
                    e3.details || " ",
                    e3
                  );
                });
              }, ctx.rule.urlChangeDelay);
            }
          } else if (mutationElementIsInline(rule, element) || !inlineAndIgnoreAndTextTags.includes(
            element.nodeName
          )) {
            if (element.classList.contains("notranslate") || element.getAttribute("translate") === "no") {
              return;
            }
            if (!isDuplicateElement(element, allNewDynamicElements)) {
              currentNewDynamicElements.push({
                element,
                rootFrame
              });
              allNewDynamicElements.push(element);
              debounceTranslateNewDynamicNodes(ctx);
            }
          }
        }
      });
    });
  });
  mutationObserver.observe(rootFrame, {
    childList: true,
    subtree: true
  });
  return mutationObserver;
}
function enableTitleMutationObserver(ctx) {
  const titleElement = document.querySelector("title");
  if (titleElement) {
    titleMutationObserver = new MutationObserver(function(mutations) {
      if (mutations.length > 0) {
        const title = mutations[0].target.text;
        if (!title.includes(titleDelimiters)) {
          translateTitle(ctx).catch((e3) => {
            log_default.error(
              `translateTitle error:`,
              e3.name,
              e3.message,
              e3.details || ""
            );
          });
        }
      }
    });
    titleMutationObserver.observe(titleElement, {
      subtree: true,
      characterData: true,
      childList: true
    });
  }
}
function mutationElementIsInline(rule, element) {
  if (rule.extraBlockSelectors) {
    for (const match of rule.extraBlockSelectors) {
      if (element.matches(match)) {
        return true;
      }
    }
  }
  return false;
}
async function initPage() {
  const isInIframe = getIsInIframe();
  const ctx = await getGlobalContext(getRealUrl(), {});
  if (ctx.rule.urlChangeDelay) {
    await delay(ctx.rule.urlChangeDelay);
  }
  let lang = ctx.sourceLanguage;
  if (lang === "auto") {
    if (!isMonkey()) {
      if (!isInIframe) {
        lang = await detectTabLanguage();
      } else {
        lang = await detectLanguage({
          text: getMainText(document.body).slice(0, 1e3)
        });
      }
    } else {
      lang = await detectLanguage({
        text: getMainText(document.body).slice(0, 1e3)
      });
    }
    if (lang === "auto") {
      lang = await detectPageLanguage();
    }
    setCurrentPageLanguage(lang);
  } else {
    setCurrentPageLanguageByClient(lang);
  }
  let isAutoTranslate = ctx.state.isAutoTranslate || ctx.isTranslateUrl || ctx.rule.isPdf;
  if (!isAutoTranslate && !ctx.isTranslateExcludeUrl) {
    log_default.debug(`detect page language: ${lang}`);
    if (isMatchLanguage(lang, ctx.config.translationLanguagePattern)) {
      isAutoTranslate = true;
      log_default.debug(`match language pattern ${lang}, auto translate`);
    }
  }
  if (isAutoTranslate) {
    globalContext.state.isAutoTranslate = true;
    await translatePage(globalContext);
  } else {
    log_default.debug(`do not auto translate`, ctx);
  }
}
function disableMutatinObserver(rootFrame) {
  if (mutationObserverMap.has(rootFrame)) {
    const mutationObserver = mutationObserverMap.get(rootFrame);
    mutationObserver.disconnect();
    mutationObserver.takeRecords();
    mutationObserverMap.delete(rootFrame);
  } else if (rootFrame === document.body) {
    const mutationObserver = mainMutaionObserver;
    if (mutationObserver) {
      mutationObserver.disconnect();
      mutationObserver.takeRecords();
    }
  }
}
function disableTitleMutationObserver() {
  if (titleMutationObserver) {
    titleMutationObserver.disconnect();
    titleMutationObserver.takeRecords();
    titleMutationObserver = void 0;
  }
}
function getPageStatus() {
  return pageStatus;
}

// libs/preact-translation/utils.ts
function getResourceUrl(root2, lang) {
  return [root2, !root2 || root2.endsWith("/") ? "" : "/", lang, ".json"].join("");
}
function format(str, params) {
  let result = str;
  if (params) {
    Object.keys(params).forEach((key) => {
      let rawValue = params[key];
      const keyIsNumber = isNumber(key);
      if (typeof rawValue === "object" || keyIsNumber) {
        let value = rawValue;
        if (keyIsNumber) {
          if (typeof value === "string") {
            value = {
              tag: "a",
              href: value
            };
          }
        }
        const tag = `<${key}>`;
        const tagIndex = result.indexOf(tag);
        if (tagIndex !== -1) {
          const actualTag = value.tag || "a";
          const endIndex = result.indexOf(`</${key}>`);
          if (endIndex !== -1) {
            const html = result.substring(tagIndex + tag.length, endIndex);
            const attrs = Object.keys(value).filter((attr) => attr !== "tag").map((attr) => `${attr}="${value[attr]}"`).join(" ");
            result = result.replace(
              `${tag}${html}</${key}>`,
              `<${actualTag} ${attrs}>${html}</${actualTag}>`
            );
          }
        }
      } else {
        const template = new RegExp("{" + key + "}", "gm");
        result = result.replace(template, rawValue.toString());
      }
    });
  }
  return result;
}
function getValue(languageData, lang, key) {
  let localeData = languageData[lang];
  if (!localeData) {
    return key;
  }
  const keys = key.split(".");
  let propKey = "";
  do {
    propKey += keys.shift();
    const value = localeData[propKey];
    if (value !== void 0 && (typeof value === "object" || !keys.length)) {
      localeData = value;
      propKey = "";
    } else if (!keys.length) {
      localeData = key;
    } else {
      propKey += ".";
    }
  } while (keys.length);
  return localeData;
}
function t2(data, key, lang, fallbackLang, params) {
  if (!data.hasOwnProperty(lang)) {
    return key;
  }
  let value = getValue(data, lang, key);
  if (value === key && lang !== fallbackLang) {
    value = getValue(data, fallbackLang, key);
  }
  return format(value, params);
}
function isNumber(value) {
  if (typeof value === "number") {
    return true;
  }
  if (value) {
    const num = parseInt(value);
    return !isNaN(num);
  } else {
    return false;
  }
}

// locales.ts
var internalLocaleMap = {
  "zh-CN": {
    "languages.en": "\u82F1\u8BED",
    "languages.ja": "\u65E5\u8BED",
    "languages.ko": "\u97E9\u8BED",
    "languages.es": "\u897F\u73ED\u7259\u8BED",
    "languages.fr": "\u6CD5\u8BED",
    "languages.de": "\u5FB7\u8BED",
    "languages.it": "\u610F\u5927\u5229\u8BED",
    "languages.pt": "\u8461\u8404\u7259\u8BED",
    "languages.ru": "\u4FC4\u8BED"
  },
  "zh-TW": {
    "languages.en": "\u82F1\u8A9E",
    "languages.ja": "\u65E5\u8A9E",
    "languages.ko": "\u97D3\u8A9E",
    "languages.es": "\u897F\u73ED\u7259\u8A9E",
    "languages.fr": "\u6CD5\u8A9E",
    "languages.de": "\u5FB7\u8A9E",
    "languages.it": "\u610F\u5927\u5229\u8A9E",
    "languages.pt": "\u8461\u8404\u7259\u8A9E",
    "languages.ru": "\u4FC4\u8A9E"
  }
};
var finalTranslations = {
  ...translations,
  "zh-CN": {
    ...internalLocaleMap["zh-CN"],
    ...translations["zh-CN"]
  },
  "zh-TW": {
    ...internalLocaleMap["zh-TW"],
    ...translations["zh-TW"]
  }
};
var locales_default = finalTranslations;
function t3(key, interfaceLanguage, params) {
  return t2(
    finalTranslations,
    key,
    interfaceLanguage,
    fallbackLanguage,
    params
  );
}
var getLanguageName = (lang, interfaceLanguage, useOriginal) => {
  const translation = t2(
    finalTranslations,
    `languages.${lang}`,
    interfaceLanguage,
    "en"
  );
  if (useOriginal) {
    return langMap[lang] || lang;
  }
  if (translation !== `languages.${lang}`) {
    return translation;
  } else {
    return langMap[lang];
  }
};

// content_dom_listeners.ts
var throttleToggleTranslatePage = le(() => {
  toggleTranslatePage();
  const event = new CustomEvent(userscriptCommandEventName, {
    detail: {
      method: "toggleTranslatePage"
    }
  });
  globalThis.document.dispatchEvent(event);
}, 200);
var throttleToggleTranslationMask = le(() => {
  toggleTranslationMask();
  const event = new CustomEvent(userscriptCommandEventName, {
    detail: {
      method: "toggleTranslationMask"
    }
  });
  globalThis.document.dispatchEvent(event);
}, 200);
function setupDomListeners(ctx) {
  document.addEventListener("click", (e3) => {
    const target = e3.target;
    const action = target.getAttribute("data-immersive-translate-action");
    if (action) {
      if (action === "retry") {
        const paragraphId = target.getAttribute(
          "data-immersive-translate-paragraph-id"
        );
        if (paragraphId) {
          translateParagraphById(Number(paragraphId));
        }
      }
    }
  });
  if (ctx.rule.fingerCountToToggleTranslagePageWhenTouching >= 2) {
    document.addEventListener("touchstart", (e3) => {
      if (e3.touches.length == ctx.rule.fingerCountToToggleTranslagePageWhenTouching) {
        throttleToggleTranslatePage();
      } else if (e3.touches.length === ctx.rule.fingerCountToToggleTranslationMaskWhenTouching) {
        throttleToggleTranslationMask();
      }
    });
  }
  if (isMonkey()) {
    if (globalThis.top != globalThis.self) {
      globalThis.addEventListener("message", (event) => {
        if (event && event.data && event.data.payload && event.data.author === iframeMessageIdentifier) {
          asyncMessageHandler(event.data.payload, {
            // @ts-ignore: it's ok
            tab: {
              id: 1,
              url: "https://www.fake-iframe.com",
              active: true
            }
          });
        }
      }, false);
    }
  }
}

// utils/compare_version.ts
function isAVersionGreaterOrEqualWithB(a4, b4) {
  const result = a4.localeCompare(b4, void 0, {
    numeric: true,
    sensitivity: "base"
  });
  return result >= 0;
}

// cron.ts
async function runCron(interval) {
  try {
    const now = /* @__PURE__ */ new Date();
    log_default.debug(
      `cron task start, next will run at`,
      new Date(now.getTime() + interval).toLocaleString()
    );
    await browserAPI.storage.local.set({
      [lastRunTimeStorageKey]: now.toISOString()
    });
    await syncRules();
    if (!isMonkey()) {
      await autoSyncLatestConfig();
    }
  } catch (e3) {
    log_default.error("run cron task failed", e3);
  }
}
async function checkCronAndRunOnce() {
  const config = await getConfig2();
  const interval = config.interval;
  if (interval) {
    const lastRunTimeResult = await browserAPI.storage.local.get(
      lastRunTimeStorageKey
    );
    if (lastRunTimeResult && lastRunTimeResult[lastRunTimeStorageKey]) {
      const lastRunTime = lastRunTimeResult[lastRunTimeStorageKey];
      if (Date.now() - new Date(lastRunTime).getTime() < interval) {
        const nextRunAt = new Date(new Date(lastRunTime).getTime() + interval);
        log_default.debug(`cron task not run, next will run at ${nextRunAt}`);
        return;
      } else {
        runCron(interval);
      }
    } else {
      runCron(interval);
    }
  }
}
async function syncRules() {
  try {
    const localConfig2 = await getConfig2();
    const data = await request2({ url: buildinConfigSyncUrl });
    const localConfigUpdatedAtIsoString = localConfig2.buildinConfigUpdatedAt;
    const localConfigUpdatedAt = new Date(localConfigUpdatedAtIsoString);
    const latestIsoTime = data.buildinConfigUpdatedAt;
    const latest = new Date(latestIsoTime);
    const remoteMinVersion = data.minVersion;
    const localVersion = browserAPI.runtime.getManifest().version;
    if (isAVersionGreaterOrEqualWithB(localVersion, remoteMinVersion)) {
      if (latest > localConfigUpdatedAt) {
        await browserAPI.storage.local.set({
          buildinConfig: data
        });
        log_default.info(
          `sync remote rules success, latest: ${new Date(latestIsoTime).toLocaleString()}`
        );
      } else {
        log_default.debug(`no need to sync rules, latest: ${localConfigUpdatedAt}`);
      }
    } else {
      log_default.info(
        `local version is too old, please update to ${remoteMinVersion} or later`
      );
    }
  } catch (e3) {
    log_default.error(`sync rules error: `, e3);
  }
}

// web-options/is_web_options_page.ts
function isWebOptionsPage() {
  const optionsHostnames = ["localhost", hostname];
  const optionsPaths = ["/dist/userscript/options/", "/options/", "/options"];
  const url = getRealUrl();
  const urlObj = new URL(url);
  const currentHostname = urlObj.hostname;
  const currentPath = urlObj.pathname;
  if (optionsHostnames.includes(currentHostname) || currentHostname.startsWith("192.168")) {
    if (optionsPaths.includes(currentPath)) {
      const optionsMetaElement = document.querySelector(
        "meta[name=immersive-translate-options]"
      );
      if (optionsMetaElement && optionsMetaElement.getAttribute("content") === "true") {
        return true;
      }
    }
  }
  return false;
}

// web-options/setup_web_options_page.ts
async function setupWebOptionsPage() {
  const statusElement = document.getElementById(
    "immersive-translate-status"
  );
  if (!statusElement) {
    log_default.error("Could not find status element");
    return;
  }
  await initStorage("local");
  await initStorage("sync");
  initOther();
  const pageReadyElement = document.getElementById(
    "immersive-translate-page-ready"
  );
  if (pageReadyElement) {
    setTimeout(() => {
      pageReadyElement.value = "true";
      pageReadyElement.dispatchEvent(new Event("change"));
    }, 100);
  }
}
function initOther() {
  const manifestElement = document.getElementById(
    "immersive-translate-manifest"
  );
  if (!manifestElement) {
    log_default.error(`Could not find manifest element`);
    return;
  }
  manifestElement.value = JSON.stringify(browserAPI.runtime.getManifest());
  manifestElement.dispatchEvent(new Event("change"));
  const messageElement = document.getElementById(
    `immersive-translate-message`
  );
  messageElement.addEventListener(
    "change",
    (event) => {
      try {
        const messageObj = JSON.parse(
          event.target.value
        );
        if (messageObj) {
          if (messageObj.method === "removeStorageKey") {
            if (messageObj.data) {
              if (messageObj.data.area && messageObj.data.keys) {
                browserAPI.storage[messageObj.data.area].remove(
                  messageObj.data.keys
                );
              }
            }
          }
        }
      } catch (e3) {
        log_default.error(`parse message error`, e3);
      }
    }
  );
}
async function initStorage(area) {
  const statusElement = document.getElementById(
    "immersive-translate-status"
  );
  const storageInputElement = document.getElementById(
    `immersive-translate-${area}-storage`
  );
  if (!storageInputElement) {
    log_default.error(`Could not find storage ${area} element`);
    statusElement.innerText = "Could not find storage local input element";
    return;
  } else {
    log_default.debug(`init storage`);
    const browserStorageObj = await browserAPI.storage[area].get(null);
    storageInputElement.value = JSON.stringify(browserStorageObj);
    storageInputElement.dispatchEvent(new Event("change"));
    storageInputElement.addEventListener("change", (event) => {
      try {
        const storageObj = JSON.parse(event.target.value);
        browserAPI.storage[area].set(storageObj);
      } catch (e3) {
        log_default.error(`save to storage error`, e3);
      }
    });
  }
}

// userscript_message.ts
function sendMessageToContent(request3) {
  asyncMessageHandler(request3, {
    // @ts-ignore: it's ok
    tab: {
      id: 1,
      url: "https://www.fake.com",
      active: true
    }
  }).catch((e3) => {
    log_default.error("send content message request failed", request3, e3);
  });
  const iframes = document.querySelectorAll("iframe");
  iframes.forEach((iframe) => {
    if (iframe.contentWindow) {
      iframe.contentWindow.postMessage(
        {
          author: iframeMessageIdentifier,
          payload: request3
        },
        "*"
      );
    }
  });
  const event = new CustomEvent(userscriptCommandEventName, {
    detail: request3
  });
  globalThis.document.dispatchEvent(event);
}

// userscript_command_listeners.ts
function setupCommandListeners(config) {
  const shortcuts = config.shortcuts || {};
  const keys = Object.keys(shortcuts);
  const keyMap = keys.reduce((acc, key) => {
    acc[shortcuts[key]] = key;
    return acc;
  }, {});
  const shortcutsKeys = Object.keys(keyMap);
  for (const key of shortcutsKeys) {
    const realKey = key.replace(/MacCtrl/ig, "Ctrl");
    v(realKey, (e3) => {
      e3.preventDefault();
      sendMessageToContent({
        method: keyMap[key]
      });
    });
  }
}

// libs/preact-translation/useTranslate.tsx
var cache = {};
var defaultOptions = {
  root: "",
  lang: "en",
  fallbackLang: "en"
};
function useTranslate(rawOptions, translations2) {
  const options2 = Object.assign(
    {},
    defaultOptions,
    rawOptions
  );
  cache = translations2 || cache;
  const [lang, setLang] = P2(options2.lang);
  const [data, setData] = P2(cache);
  const [isReady2, setReady] = P2(false);
  const loadData = (langKey) => {
    if (data.hasOwnProperty(langKey)) {
      return;
    }
    setReady(false);
    let url = getResourceUrl(options2.root || "", langKey);
    if (options2.getUrl) {
      url = options2.getUrl(options2.root || "", langKey);
      fetch(url).then((results) => results.json()).then((resource) => {
        cache[langKey] = resource;
        setData({ ...cache });
        setReady(true);
      }).catch((error) => {
        setData({ ...cache });
        setReady(true);
      });
    }
  };
  j2(() => {
    loadData(options2.fallbackLang || "en");
    loadData(lang);
  }, [lang]);
  const t4 = (key, params) => {
    if (!data.hasOwnProperty(lang)) {
      return key;
    }
    let value = getValue(data, lang, key);
    if (value === key && lang !== options2.fallbackLang) {
      value = getValue(data, options2.fallbackLang, key);
    }
    return format(value, params);
  };
  return { lang, setLang, t: t4, isReady: isReady2 };
}

// https://esm.sh/stable/preact@10.11.0/deno/jsx-runtime.js
var a3 = 0;
function p5(n3, s4, t4, f4, u3) {
  var r, o3, _2 = {};
  for (o3 in s4)
    o3 == "ref" ? r = s4[o3] : _2[o3] = s4[o3];
  var e3 = { type: n3, props: _2, key: t4, ref: r, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: --a3, __source: u3, __self: f4 };
  if (typeof n3 == "function" && (r = n3.defaultProps))
    for (o3 in r)
      _2[o3] === void 0 && (_2[o3] = r[o3]);
  return d.vnode && d.vnode(e3), e3;
}

// libs/preact-translation/translateProvider.tsx
var TranslateContext = ce(null);
var defaultOptions2 = {
  root: "assets",
  lang: "en",
  fallbackLang: "en"
};
var TranslateProvider = (props) => {
  const { t: t4, setLang, lang, isReady: isReady2 } = useTranslate(
    {
      root: props.root || defaultOptions2.root,
      lang: props.lang || defaultOptions2.lang,
      fallbackLang: props.fallbackLang || defaultOptions2.fallbackLang,
      getUrl: props.getUrl
    },
    props.translations
  );
  return /* @__PURE__ */ p5(
    TranslateContext.Provider,
    {
      value: {
        t: t4,
        setLang,
        lang,
        isReady: isReady2
      },
      children: props.children
    }
  );
};

// utils/source_language_url_pattern.ts
function handleSourceLanguageUrlPattern(url, language, currentSourceLanguageUrlPattern) {
  let currentMatches = [];
  if (!currentSourceLanguageUrlPattern) {
    currentSourceLanguageUrlPattern = {};
  }
  if (language !== "auto" && !currentSourceLanguageUrlPattern[language]) {
    currentSourceLanguageUrlPattern[language] = {
      "matches": [],
      "excludeMatches": []
    };
  }
  currentMatches = language !== "auto" ? currentSourceLanguageUrlPattern[language].matches : [];
  const urlToLanguage = {};
  const allKeys = Object.keys(currentSourceLanguageUrlPattern);
  for (const key of allKeys) {
    const value = currentSourceLanguageUrlPattern[key];
    const urlKeys = value.matches;
    for (const urlKey of urlKeys) {
      if (!urlToLanguage[urlKey]) {
        urlToLanguage[urlKey] = [];
      }
      urlToLanguage[urlKey].push(key);
    }
  }
  const currentMatchedlanguages = urlToLanguage[url];
  if (currentMatchedlanguages && currentMatchedlanguages.length > 0) {
    for (const currentMatchedlanguage of currentMatchedlanguages) {
      const index = currentSourceLanguageUrlPattern[currentMatchedlanguage].matches.indexOf(url);
      if (index > -1) {
        currentSourceLanguageUrlPattern[currentMatchedlanguage] = {
          ...currentSourceLanguageUrlPattern[currentMatchedlanguage],
          matches: currentSourceLanguageUrlPattern[currentMatchedlanguage].matches.filter(
            (item) => item !== url
          )
        };
      }
    }
  }
  const currentMatchSet = new Set(currentMatches);
  if (language === "auto") {
    return {
      ...currentSourceLanguageUrlPattern
    };
  } else {
    currentMatchSet.add(url);
  }
  const newMatches = Array.from(currentMatchSet);
  return {
    ...currentSourceLanguageUrlPattern,
    [language]: {
      ...currentSourceLanguageUrlPattern[language],
      matches: newMatches
    }
  };
}

// utils/click-multiple-times.ts
function onClickMultipleTimes(requiredClicks, timeLimit = 2e3) {
  return (cb) => {
    let timer2;
    let clicked = 0;
    return (e3) => {
      if (++clicked == requiredClicks) {
        cb(e3);
        clicked = 0;
      }
      clearTimeout(timer2);
      timer2 = setTimeout(
        () => clicked = 0,
        // reset the number of clicks after a traditional 300ms duration
        timeLimit
      );
    };
  };
}

// utils/is_valid_html_url.ts
function isValidHtmlUrl(url) {
  let urlObj;
  try {
    urlObj = new URL(url);
  } catch (_2) {
    return false;
  }
  const pathname = urlObj.pathname;
  if (pathname.endsWith(".html") || pathname.endsWith(".htm")) {
    return true;
  }
  if (urlObj.protocol !== "http:" && urlObj.protocol !== "https:" && urlObj.protocol !== "file:" && urlObj.protocol !== "data:") {
    return false;
  }
  return true;
}

// utils/hostname_to_wild_hostname.ts
function hostnameToWildHostname(hostname2) {
  const parts = hostname2.split(`.`);
  if (parts.length > 2) {
    parts[0] = `*`;
    return parts.join(".");
  } else {
    return null;
  }
}

// utils/url_without_hash.ts
function getUrlWithoutHash(url) {
  const hashIndex = url.indexOf("#");
  if (hashIndex === -1) {
    return url;
  } else {
    return url.slice(0, hashIndex);
  }
}

// browser/version.ts
function getVersion() {
  const manifest = browserAPI.runtime.getManifest();
  return manifest.version;
}

// components/select_link.tsx
function SelectLink(props) {
  let { items, maxWidth } = props;
  maxWidth = maxWidth || 128;
  return /* @__PURE__ */ p5(
    "select",
    {
      autoComplete: "off",
      class: "min-select",
      style: { maxWidth: `${maxWidth}px` },
      value: items.find((item) => item.selected)?.value,
      onChange: (e3) => {
        const value = e3.target.value;
        const item = items.find((item2) => item2.value === value);
        if (item) {
          item.onSelected(item);
        }
      },
      children: items.map((item) => /* @__PURE__ */ p5("option", { value: item.value, selected: item.selected, children: item.label }))
    }
  );
}

// components/button_drop_down.tsx
var DEFAULT_VALUE = "DROP_DOWN_DEFAULT_VALUE";
function SelectDropDown(props) {
  let { showArrow, onSelected, className, menus, maxWidth } = props;
  className = className || "";
  showArrow = showArrow ?? true;
  maxWidth = maxWidth || 60;
  const ref = w2(null);
  return /* @__PURE__ */ p5(
    "select",
    {
      ref,
      autoComplete: "off",
      class: `min-select ${showArrow ? "" : "min-select-no-arrow"} ${className ? className : ""}`,
      value: DEFAULT_VALUE,
      style: { maxWidth: `${maxWidth}px` },
      onChange: (e3) => {
        e3.preventDefault();
        const value = e3.target.value;
        if (ref.current && value !== DEFAULT_VALUE) {
          ref.current.value = DEFAULT_VALUE;
          ref.current?.dispatchEvent(new Event("change"));
          const item = menus.find((item2) => item2.value === value);
          if (item) {
            onSelected(item);
          }
        }
      },
      children: [{
        value: DEFAULT_VALUE,
        label: props.label
      }].concat(menus).map((item) => /* @__PURE__ */ p5("option", { value: item.value, children: item.label }))
    }
  );
}

// hooks/use_i18n.ts
function useI18n() {
  return M2(TranslateContext);
}

// components/popup_field.tsx
function PopupField(props) {
  let { field, onChange, value } = props;
  value = value || field.default || "";
  const { t: t4 } = useI18n();
  if (field.type === "select") {
    return /* @__PURE__ */ p5("div", { class: "flex justify-between mb-2", children: [
      /* @__PURE__ */ p5("label", { class: "inline-block", children: [
        field.label ? t4(field.label) : field.name,
        "\uFF1A"
      ] }),
      /* @__PURE__ */ p5(
        SelectLink,
        {
          items: field.options.map(
            (fieldOption) => {
              return {
                label: `${fieldOption.label ? t4(fieldOption.label) : fieldOption.value}`,
                value,
                selected: value === fieldOption.value,
                onSelected: () => {
                  onChange(fieldOption.value);
                }
              };
            }
          )
        }
      )
    ] });
  }
  return null;
}

// components/sync_latest.tsx
var SyncSuccess = ({ date }) => {
  const { t: t4 } = useI18n();
  const [isHide, setIsHide] = P2(false);
  j2(() => {
    setTimeout(() => {
      setIsHide(true);
    }, 5e3);
  }, []);
  return isHide ? null : /* @__PURE__ */ p5("p", { class: "text-sm", children: [
    t4("Successfully synchronized with the latest official rules:"),
    " ",
    new Date(date).toLocaleString()
  ] });
};
var LocalVersionIsTooOld = ({ minVersion }) => {
  const { t: t4 } = useI18n();
  return /* @__PURE__ */ p5("p", { class: "text-sm", children: t4(
    "localVersionIsTooOld",
    {
      minVersion
    }
  ) });
};
var BadUserscriptBrowser = () => {
  const { t: t4 } = useI18n();
  return /* @__PURE__ */ p5(
    "p",
    {
      class: "text-sm",
      dangerouslySetInnerHTML: {
        __html: t4(
          "badUserscriptBrowser",
          {
            "1": "https://immersive-translate.owenyoung.com/installation.html"
          }
        )
      }
    }
  );
};
var SyncFailed = ({ message, handleSyncing, date }) => {
  const { t: t4 } = useI18n();
  return /* @__PURE__ */ p5("p", { class: "text-sm", children: [
    t4("failToSyncRules"),
    " ",
    /* @__PURE__ */ p5("a", { onClick: handleSyncing, children: t4("retry") }),
    /* @__PURE__ */ p5("br", {}),
    t4("failedReason"),
    "\uFF1A",
    message,
    /* @__PURE__ */ p5("br", {}),
    t4("currentRuleVersion"),
    "\uFF1A",
    date
  ] });
};
function SyncLatest(props) {
  const { request: request3 } = props;
  const [localBuildinConfigUpdatedAt, setLocalBuildinConfigUpdatedAt] = P2(null);
  const { t: t4 } = useI18n();
  const [remoteConfig, setRemoteConfig] = P2(null);
  const [isNeedUpdate, setIsNeedUpdate] = P2(null);
  const [syncErrorMessage, setSyncErrorMessage] = P2("");
  const [isSyncSuccess, setIsSyncSuccess] = P2(false);
  const [isInvalidLocalVersion, setIsInvalidLocalVersion] = P2(
    false
  );
  const [isBadUserscriptBrowser, setIsBadUserscriptBrowser] = P2(
    false
  );
  const [config, setConfig] = P2(null);
  const [_isLatestVersion, setIsLatestVersion] = P2(null);
  const version = getVersion();
  const handleSyncing = async () => {
    setSyncErrorMessage("");
    let finalRemoteConfig = remoteConfig;
    if (remoteConfig === null) {
      try {
        const response = await request3({ url: buildinConfigSyncUrl });
        if (response) {
          setRemoteConfig(response);
          finalRemoteConfig = response;
          setIsSyncSuccess(true);
        } else {
          setSyncErrorMessage(t4("unknownError"));
          setIsNeedUpdate(null);
        }
      } catch (e3) {
        setIsNeedUpdate(null);
        setSyncErrorMessage(e3.message);
        return;
      }
    }
    if (finalRemoteConfig !== null) {
      props.setStorageBuildinConfig(finalRemoteConfig);
      setIsNeedUpdate(false);
      setLocalBuildinConfigUpdatedAt(
        finalRemoteConfig.buildinConfigUpdatedAt
      );
    } else {
      setSyncErrorMessage(t4("canNotFetchRemoteRule"));
      setIsNeedUpdate(null);
    }
  };
  j2(() => {
    getConfig().then((localConfig2) => {
      const localConfigUpdatedAtIsoString = localConfig2.buildinConfigUpdatedAt;
      setConfig(localConfig2);
      const localConfigUpdatedAt = new Date(localConfigUpdatedAtIsoString);
      setLocalBuildinConfigUpdatedAt(localConfigUpdatedAtIsoString);
      if (version === "0.0.0") {
        setIsBadUserscriptBrowser(true);
        return;
      }
      request3({
        url: buildinConfigSyncUrl
      }).then((response) => {
        const data = response;
        const remoteMinVersion = data.minVersion;
        const localVersion = version;
        setRemoteConfig(data);
        const remoteVersion = data.latestVersion;
        if (remoteVersion) {
          if (!isAVersionGreaterOrEqualWithB(localVersion, remoteVersion)) {
            setIsLatestVersion(false);
          } else {
            setIsLatestVersion(true);
          }
        }
        if (isAVersionGreaterOrEqualWithB(localVersion, remoteMinVersion)) {
          const latestIsoTime = data.buildinConfigUpdatedAt;
          const latest = new Date(latestIsoTime);
          if (latest > localConfigUpdatedAt) {
            setIsNeedUpdate(true);
            handleSyncing();
          } else {
            setIsNeedUpdate(false);
          }
        } else {
          setIsInvalidLocalVersion(true);
          setIsNeedUpdate(null);
        }
      }).catch((e3) => {
        setIsNeedUpdate(null);
        setSyncErrorMessage(e3.message);
      });
    });
  }, []);
  j2(() => {
    getConfig().then((config2) => {
      setConfig(config2);
    });
  }, [localBuildinConfigUpdatedAt]);
  if (!config) {
    return null;
  }
  return /* @__PURE__ */ p5("div", { class: "text-sm mt-2", style: { maxWidth: 218 }, children: isBadUserscriptBrowser ? /* @__PURE__ */ p5(BadUserscriptBrowser, {}) : syncErrorMessage ? /* @__PURE__ */ p5(
    SyncFailed,
    {
      handleSyncing,
      message: syncErrorMessage,
      date: localBuildinConfigUpdatedAt || ""
    }
  ) : isInvalidLocalVersion ? /* @__PURE__ */ p5(LocalVersionIsTooOld, { minVersion: remoteConfig.minVersion }) : isNeedUpdate === null ? null : isNeedUpdate === true ? null : isSyncSuccess ? /* @__PURE__ */ p5(SyncSuccess, { date: localBuildinConfigUpdatedAt }) : null });
}

// components/popup.tsx
function Popup(props) {
  const version = getVersion();
  const {
    onTranslateTheMainPage,
    onUserConfigChange,
    request: request3,
    onSetBuildinConfig,
    pageStatus: pageStatus2,
    config,
    openAboutPage: openAboutPage2,
    onTranslateTheWholePage,
    openOptionsPage: openOptionsPage2,
    ontranslateToThePageEndImmediately,
    onSetPageLanguage,
    onToggleTranslate,
    onTranslateLocalPdfFile,
    onTranslatePdf,
    onRestorePage,
    ctx,
    currentUrl,
    currentLang,
    onClose,
    onTranslatePage,
    onSetLocalConfig
  } = props;
  const setSettings = onUserConfigChange;
  const [message, setMessage] = P2("");
  const [errorMessage, _setErrorMessage] = P2("");
  const { t: t4 } = useI18n();
  let isAlwaysTranslateDomain = null;
  let isAlwaysTranslateWildDomain = null;
  let isNeverTranslaateDomain = null;
  let isNeverTranslateWildDomain = null;
  let isAlwaysTranslateLang = null;
  let isAlwaysTranslateUrl = null;
  let isNeverTranslateUrl = null;
  let curentTranslationServiceItem = null;
  let currentUrlObj = null;
  let currentWildHostname = null;
  let currentUrlWithoutHash = null;
  let currentTranslationServiceConfig = null;
  if (config) {
    const { translationService, translationServices, translationUrlPattern } = config;
    if (TranslationServices[translationService]) {
      curentTranslationServiceItem = formatTranslationService(
        translationService,
        ctx
      );
    }
    if (translationServices && translationServices[translationService]) {
      currentTranslationServiceConfig = translationServices[translationService] || {};
    } else {
      currentTranslationServiceConfig = {};
    }
    if (currentUrl && isValidHtmlUrl(currentUrl)) {
      currentUrlObj = new URL(currentUrl);
      currentWildHostname = hostnameToWildHostname(currentUrlObj.hostname);
      currentUrlWithoutHash = getUrlWithoutHash(currentUrl);
      const { matches, excludeMatches } = translationUrlPattern;
      isAlwaysTranslateWildDomain = matches.includes(currentWildHostname);
      isAlwaysTranslateDomain = matches.includes(currentUrlObj.hostname);
      isNeverTranslateWildDomain = excludeMatches.includes(
        currentWildHostname
      );
      isNeverTranslaateDomain = excludeMatches.includes(
        currentUrlObj.hostname
      );
      isAlwaysTranslateUrl = matches.includes(currentUrlWithoutHash);
      isNeverTranslateUrl = excludeMatches.includes(currentUrlWithoutHash);
    }
  }
  if (config && currentLang && currentLang !== "auto") {
    const { translationLanguagePattern } = config;
    const { matches } = translationLanguagePattern;
    if (matches.includes(currentLang)) {
      isAlwaysTranslateLang = true;
    } else {
      isAlwaysTranslateLang = false;
    }
  }
  const handleOpenOptions = (e3) => {
    e3.preventDefault();
    openOptionsPage2();
  };
  const handleToggleAlpha = (_e3) => {
    setSettings((settings) => {
      if (!settings.alpha) {
        setMessage("Success enable alpha!");
      } else {
        setMessage("Success disable alpha!");
      }
      return {
        ...settings,
        alpha: !settings.alpha
      };
    });
  };
  const handleChangeToTranslateTheWholePage = () => {
    setSettings((state) => {
      return {
        ...state,
        translationArea: "body"
      };
    });
    onTranslateTheWholePage();
  };
  const handleChangeToTranslateTheMainPage = () => {
    setSettings((state) => {
      return {
        ...state,
        translationArea: "main"
      };
    });
    onTranslateTheMainPage();
  };
  const handleTranslationUrlPatternSelected = (value, matchString, reverseRemoveStrings, removeStrings) => {
    if (value === "default") {
      setSettings((state) => {
        const translationUrlPattern = { ...state.translationUrlPattern };
        const newState = {
          ...state,
          translationUrlPattern: {
            ...state.translationUrlPattern,
            matches: removeFromArray(
              [currentUrlObj?.hostname, currentWildHostname, currentUrl],
              translationUrlPattern.matches
            ),
            excludeMatches: removeFromArray(
              [currentUrlObj?.hostname, currentWildHostname, currentUrl],
              translationUrlPattern.excludeMatches
            )
          }
        };
        return newState;
      });
      return;
    }
    const name = value;
    const reverseName = name === "matches" ? "excludeMatches" : "matches";
    if (currentUrlObj) {
      setSettings((state) => {
        const translationUrlPattern = { ...state.translationUrlPattern };
        translationUrlPattern[name] = addToUniqueArray(
          matchString,
          translationUrlPattern[name]
        );
        if (removeStrings.length > 0) {
          translationUrlPattern[name] = removeFromArray(
            removeStrings,
            translationUrlPattern[name]
          );
        }
        translationUrlPattern[reverseName] = removeFromArray(
          reverseRemoveStrings,
          translationUrlPattern[reverseName]
        );
        const newState = {
          ...state,
          translationUrlPattern: {
            ...state.translationUrlPattern,
            ...translationUrlPattern
          }
        };
        return newState;
      });
    }
    if (name === "matches" && pageStatus2 === "Original") {
      setTimeout(() => {
        onTranslatePage();
        onClose();
      }, 100);
    } else if (name === "excludeMatches" && pageStatus2 === "Translated") {
      setTimeout(() => {
        onRestorePage();
        onClose();
      }, 100);
    }
  };
  const handleTranslationLanguagePatternSelected = (value) => {
    if (!value) {
      setSettings((state) => {
        const translationLanguagePattern = {
          ...state.translationLanguagePattern
        };
        const newState = {
          ...state,
          translationLanguagePattern: {
            ...state.translationLanguagePattern,
            matches: removeFromArray(
              currentLang,
              translationLanguagePattern.matches
            ),
            excludeMatches: removeFromArray(
              currentLang,
              translationLanguagePattern.excludeMatches
            )
          }
        };
        return newState;
      });
      return;
    }
    const name = value;
    const reverseName = name === "matches" ? "excludeMatches" : "matches";
    if (currentLang) {
      setSettings((state) => {
        const translationLanguagePattern = {
          ...state.translationLanguagePattern
        };
        translationLanguagePattern[name] = addToUniqueArray(
          currentLang,
          translationLanguagePattern[name]
        );
        translationLanguagePattern[reverseName] = removeFromArray(
          currentLang,
          translationLanguagePattern[reverseName]
        );
        const newState = {
          ...state,
          translationLanguagePattern: {
            ...state.translationLanguagePattern,
            ...translationLanguagePattern
          }
        };
        return newState;
      });
    }
    if (name === "matches" && pageStatus2 === "Original") {
      setTimeout(() => {
        onTranslatePage();
        onClose();
      }, 100);
    }
  };
  const isPdfUrl = currentUrlObj?.pathname.toLowerCase().endsWith(".pdf");
  let buttonLabel = t4("translate");
  if (pageStatus2 === "Translated") {
    buttonLabel = t4("show-original");
  } else if (pageStatus2 === "Original") {
    if (isPdfUrl) {
      if (isFirefox() && currentUrlObj.protocol === "file:") {
        buttonLabel = t4("translate-firefox-local-pdf");
      } else {
        buttonLabel = t4("translate-pdf");
      }
    } else {
      buttonLabel = t4("translate");
    }
  } else {
    buttonLabel = t4(pageStatus2);
  }
  let translateToThePageEndImmediatelyLabel = t4(
    "translateToThePageEndImmediately"
  );
  if (pageStatus2 === "Original" || pageStatus2 === "Translated") {
    if (config.shortcuts.toggleTranslatePage) {
      if (isTouchDevice() && ctx.rule.fingerCountToToggleTranslagePageWhenTouching >= 2) {
        buttonLabel += ` (${t4(`fingers.${ctx.rule.fingerCountToToggleTranslagePageWhenTouching}`)})`;
      } else {
        buttonLabel += ` (${config.shortcuts.toggleTranslatePage})`;
      }
    }
    if (config.shortcuts.toggleTranslateToThePageEndImmediately) {
      translateToThePageEndImmediatelyLabel += ` (${config.shortcuts.toggleTranslateToThePageEndImmediately})`;
    }
  }
  let translationServiceItems = [];
  if (ctx) {
    translationServiceItems = getTranslationServices(ctx);
  }
  const handleClosePopup = (e3) => {
    e3.preventDefault();
    onClose();
  };
  return /* @__PURE__ */ p5("div", { class: "p-3", children: [
    /* @__PURE__ */ p5("div", { class: "text-sm", children: [
      /* @__PURE__ */ p5("div", { class: "flex justify-between mb-2", children: [
        /* @__PURE__ */ p5("label", { class: "inline-block", children: [
          t4("popupSourceLanguage"),
          "\uFF1A"
        ] }),
        /* @__PURE__ */ p5(
          SelectLink,
          {
            items: languages.map((code2) => {
              return {
                label: getLanguageName(code2, config.interfaceLanguage),
                value: code2,
                selected: code2 === currentLang,
                onSelected: (item) => {
                  onSetPageLanguage(item.value);
                }
              };
            })
          }
        )
      ] }),
      config && config.targetLanguage && /* @__PURE__ */ p5("div", { class: "flex justify-between mb-2", children: [
        /* @__PURE__ */ p5("label", { class: "inline-block", children: [
          t4("popupTarget"),
          "\uFF1A"
        ] }),
        /* @__PURE__ */ p5(
          SelectLink,
          {
            items: languages.filter((code2) => code2 !== "auto").map((code2) => {
              return {
                label: getLanguageName(code2, config.interfaceLanguage),
                value: code2,
                selected: code2 === config.targetLanguage,
                onSelected: (item) => {
                  setSettings((state) => {
                    return {
                      ...state,
                      targetLanguage: item.value
                    };
                  });
                }
              };
            })
          }
        )
      ] }),
      curentTranslationServiceItem && translationServiceItems.length > 0 && /* @__PURE__ */ p5(L, { children: [
        /* @__PURE__ */ p5("div", { class: "flex justify-between mb-2", children: [
          /* @__PURE__ */ p5("label", { class: "inline-block", children: [
            t4("popupService"),
            "\uFF1A"
          ] }),
          /* @__PURE__ */ p5(
            SelectLink,
            {
              items: translationServiceItems.map(
                (translationServiceItem) => {
                  return {
                    label: `${t4("translationServices." + translationServiceItem.id)}${translationServiceItem.ok ? "" : " " + t4("needAction")}`,
                    value: translationServiceItem.id,
                    selected: translationServiceItem.selected,
                    onSelected: (option) => {
                      const selectedItem = translationServiceItems.find(
                        (item) => item.id === option.value
                      );
                      if (selectedItem.ok) {
                        setSettings((state) => {
                          return {
                            ...state,
                            translationService: selectedItem.id
                          };
                        });
                        if (selectedItem.props.length === 0) {
                          setTimeout(() => {
                            onTranslatePage();
                          }, 1);
                        } else {
                          setTimeout(() => {
                            onRestorePage();
                          }, 1);
                        }
                      } else {
                        setSettings((state) => {
                          return {
                            ...state,
                            translationService: selectedItem.id
                          };
                        });
                        setTimeout(() => {
                          openOptionsPage2();
                        }, 100);
                      }
                    }
                  };
                }
              )
            }
          )
        ] }),
        currentTranslationServiceConfig && curentTranslationServiceItem.props.length > 0 && curentTranslationServiceItem.props.map((prop, index) => {
          return /* @__PURE__ */ p5("div", { class: "pl-4 text-sm", children: /* @__PURE__ */ p5(
            PopupField,
            {
              field: prop,
              value: currentTranslationServiceConfig[prop.name],
              onChange: (value) => {
                setSettings((state) => {
                  const currentServices = state.translationServices || {};
                  const currentServiceConfig = currentServices[curentTranslationServiceItem.id] || {};
                  setTimeout(() => {
                    onRestorePage();
                  }, 1);
                  return {
                    ...state,
                    translationServices: {
                      ...currentServices,
                      [curentTranslationServiceItem.id]: {
                        ...currentServiceConfig,
                        [prop.name]: value
                      }
                    }
                  };
                });
              }
            },
            "field-" + index
          ) });
        })
      ] }),
      currentUrlObj && /* @__PURE__ */ p5("div", { class: "flex justify-between mb-2", children: [
        /* @__PURE__ */ p5("label", { class: "inline-block", children: t4("forThisSite") }),
        /* @__PURE__ */ p5(
          SelectLink,
          {
            items: [
              {
                label: t4("default"),
                value: "default",
                selected: isAlwaysTranslateDomain === false && isNeverTranslaateDomain === false && !isAlwaysTranslateWildDomain && !isNeverTranslateWildDomain && !isAlwaysTranslateUrl && !isNeverTranslateUrl,
                onSelected: () => {
                  handleTranslationUrlPatternSelected(
                    "default",
                    currentUrlObj.hostname,
                    [],
                    []
                  );
                  const currentDomain = currentUrlObj.hostname;
                  const currentTempTranslationDomains = ctx.localConfig.tempTranslationUrlMatches || [];
                  const filteredDomains = currentTempTranslationDomains.filter(
                    (item) => item.match !== currentDomain
                  );
                  let isChanged = false;
                  if (filteredDomains.length !== currentTempTranslationDomains.length) {
                    isChanged = true;
                  }
                  if (isChanged) {
                    onSetLocalConfig({
                      ...ctx.localConfig,
                      tempTranslationUrlMatches: [
                        ...filteredDomains
                      ]
                    });
                  }
                }
              },
              currentUrlWithoutHash && {
                label: t4("alwaysTranslateSomeSite", {
                  hostname: t4("currentUrl")
                }),
                value: "matchesUrl",
                selected: isAlwaysTranslateUrl,
                onSelected: () => {
                  handleTranslationUrlPatternSelected(
                    "matches",
                    currentUrlWithoutHash,
                    [currentUrlWithoutHash],
                    []
                  );
                }
              },
              {
                label: t4("alwaysTranslateSomeSite", {
                  hostname: currentUrlObj.hostname
                }),
                value: "matches",
                selected: isAlwaysTranslateDomain,
                onSelected: (item) => {
                  handleTranslationUrlPatternSelected(
                    item.value,
                    currentUrlObj.hostname,
                    [
                      currentUrlObj.hostname,
                      currentWildHostname,
                      currentUrlWithoutHash
                    ],
                    [currentWildHostname]
                  );
                }
              },
              currentWildHostname && {
                label: t4("alwaysTranslateSomeSite", {
                  hostname: currentWildHostname
                }),
                value: "matchesWild",
                selected: isAlwaysTranslateWildDomain,
                onSelected: () => {
                  handleTranslationUrlPatternSelected(
                    "matches",
                    currentWildHostname,
                    [
                      currentUrlWithoutHash,
                      currentUrlObj.hostname,
                      currentWildHostname
                    ],
                    [currentUrlObj.hostname]
                  );
                }
              },
              currentUrlWithoutHash && {
                label: t4("neverTranslateSomeSite", {
                  hostname: t4("currentUrl")
                }),
                value: "excludeMatchesUrl",
                selected: isNeverTranslateUrl,
                onSelected: () => {
                  handleTranslationUrlPatternSelected(
                    "excludeMatches",
                    currentUrlWithoutHash,
                    [currentUrlWithoutHash],
                    []
                  );
                }
              },
              {
                label: t4("neverTranslateSomeSite", {
                  hostname: currentUrlObj.hostname
                }),
                value: "excludeMatches",
                selected: isNeverTranslaateDomain,
                onSelected: (item) => {
                  handleTranslationUrlPatternSelected(
                    item.value,
                    currentUrlObj.hostname,
                    [
                      currentUrlObj.hostname,
                      currentWildHostname,
                      currentUrlWithoutHash
                    ],
                    [currentWildHostname]
                  );
                }
              },
              currentWildHostname && {
                label: t4("neverTranslateSomeSite", {
                  hostname: currentWildHostname
                }),
                value: "excludeMatchesWild",
                selected: isNeverTranslateWildDomain,
                onSelected: () => {
                  handleTranslationUrlPatternSelected(
                    "excludeMatches",
                    currentWildHostname,
                    [
                      currentUrlObj.hostname,
                      currentUrlWithoutHash,
                      currentWildHostname
                    ],
                    [currentUrlObj.hostname]
                  );
                }
              }
            ].filter(Boolean)
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ p5("div", { class: "", children: /* @__PURE__ */ p5(
      "button",
      {
        class: "py-2 mt-1 mb-2 main-button ",
        onClick: () => {
          if (isPdfUrl) {
            onTranslatePdf && onTranslatePdf();
          } else {
            onToggleTranslate();
          }
        },
        "aria-busy": pageStatus2 === "Translating",
        disabled: pageStatus2 === "Translating",
        children: buttonLabel
      }
    ) }),
    /* @__PURE__ */ p5("div", { class: "flex justify-between", children: [
      currentLang && currentLang !== "auto" ? /* @__PURE__ */ p5("label", { for: "alwaysTranslateThisLanugage", class: "text-sm", children: [
        /* @__PURE__ */ p5(
          "input",
          {
            type: "checkbox",
            id: "alwaysTranslateThisLanugage",
            name: "alwaysTranslateThisLanugage",
            checked: !!isAlwaysTranslateLang,
            onChange: (e3) => {
              const checked = e3.target.checked;
              handleTranslationLanguagePatternSelected(
                checked ? "matches" : void 0
              );
            }
          }
        ),
        t4("alwaysTranslateSomeLanguage", {
          language: getLanguageName(
            currentLang,
            config.interfaceLanguage
          )
        })
      ] }) : /* @__PURE__ */ p5("span", {}),
      /* @__PURE__ */ p5(
        SelectDropDown,
        {
          label: t4("more"),
          showArrow: true,
          onSelected: (item) => {
            if (item.value === "translateTheWholePage") {
              onTranslateTheWholePage();
            } else if (item.value === "translateToThePageEndImmediately") {
              ontranslateToThePageEndImmediately();
            } else if (item.value === "translateTheMainPage") {
              onTranslateTheMainPage();
            } else if (item.value === "showTranslationOnly") {
            } else if (item.value === "translateLocalPdfFile") {
              onTranslateLocalPdfFile && onTranslateLocalPdfFile();
            } else if (item.value === "donate") {
              globalThis.open(config.donateUrl);
              onClose();
            } else if (item.value === "feedback") {
              globalThis.open(config.feedbackUrl);
              onClose();
            } else if (item.value === "options") {
              openOptionsPage2();
              onClose();
            } else if (item.value === "changeToTranslateTheWholePage") {
              handleChangeToTranslateTheWholePage();
            } else if (item.value === "changeToTranslateTheMainPage") {
              handleChangeToTranslateTheMainPage();
            } else if (item.value === "about") {
              openAboutPage2();
            }
          },
          menus: [
            config.translationArea === "main" && {
              label: "\u{1F480} " + t4("changeToTranslateTheWholePage"),
              value: "changeToTranslateTheWholePage"
            },
            config.translationArea === "body" && {
              label: "\u{1F4D6} " + t4("changeToTranslateTheMainPage"),
              value: "changeToTranslateTheMainPage"
            },
            {
              label: "\u26A1 " + translateToThePageEndImmediatelyLabel,
              value: "translateToThePageEndImmediately"
            },
            !isMonkey() && {
              label: "\u{1F4C1} " + t4("browser.translateLocalPdfFile"),
              value: "translateLocalPdfFile"
            },
            {
              label: "\u2764\uFE0F " + t4("aboutLabel"),
              value: "about"
            }
          ].filter(Boolean)
        }
      )
    ] }),
    /* @__PURE__ */ p5("div", { class: "text-sm", children: message }),
    /* @__PURE__ */ p5("div", { class: "text-sm", children: errorMessage }),
    /* @__PURE__ */ p5("footer", { children: [
      /* @__PURE__ */ p5(
        SyncLatest,
        {
          request: request3,
          setStorageBuildinConfig: onSetBuildinConfig
        }
      ),
      /* @__PURE__ */ p5("div", { class: "mt-3 text-sm flex justify-between", children: [
        /* @__PURE__ */ p5("a", { href: "#", class: "secondary", onClick: handleOpenOptions, children: t4("options") }),
        isMonkey() && /* @__PURE__ */ p5("a", { href: "#", class: "secondary", onClick: handleClosePopup, children: t4("close") }),
        /* @__PURE__ */ p5(
          "span",
          {
            class: "immersive-translate-no-select muted",
            onClick: onClickMultipleTimes(7)(handleToggleAlpha),
            children: [
              "V",
              version
            ]
          }
        )
      ] })
    ] })
  ] });
}

// libs/use-chrome-storage/storage.ts
var storage = {
  get: (key, defaultValue, storageArea) => {
    const keyObj = defaultValue === void 0 ? key : { [key]: defaultValue };
    return browserAPI.storage[storageArea].get(
      keyObj
    );
  },
  set: (key, value, storageArea) => {
    return browserAPI.storage[storageArea].set({ [key]: value });
  }
};

// libs/use-chrome-storage/useChromeStorage.ts
function useChromeStorage(key, initialValue, storageArea) {
  const [INITIAL_VALUE2] = P2(() => {
    return typeof initialValue === "function" ? initialValue() : initialValue;
  });
  const [STORAGE_AREA] = P2(storageArea);
  const [state, setState] = P2(INITIAL_VALUE2);
  const [isPersistent, setIsPersistent] = P2(false);
  const [error, setError] = P2("");
  j2(() => {
    storage.get(key, INITIAL_VALUE2, STORAGE_AREA).then((res) => {
      if (res[key]) {
        setState(res[key]);
      }
      setIsPersistent(true);
      setError("");
    }).catch((error2) => {
      setIsPersistent(false);
      setError(error2);
    });
  }, [key, INITIAL_VALUE2, STORAGE_AREA]);
  const updateValue = L2(
    // @ts-ignore: npm package is not typed
    (newValue) => {
      const toStore = typeof newValue === "function" ? newValue(state) : newValue;
      log_default.debug(`new settings`, toStore);
      storage.set(key, toStore, STORAGE_AREA).then(() => {
        setState(toStore);
        setIsPersistent(true);
        setError("");
      }).catch((error2) => {
        setState(toStore);
        setIsPersistent(false);
        setError(error2);
      });
    },
    [STORAGE_AREA, key, state]
  );
  return [state, updateValue, isPersistent, error];
}

// libs/use-chrome-storage/createChromeStorageStateHook.ts
function createChromeStorageStateHook(key, initialValue, storageArea) {
  const consumers = [];
  return function useCreateChromeStorageHook() {
    const [value, setValue, isPersistent, error] = useChromeStorage(
      key,
      initialValue,
      storageArea
    );
    const setValueAll = L2((newValue) => {
      for (const consumer of consumers) {
        consumer(newValue);
      }
    }, []);
    j2(() => {
      consumers.push(setValue);
      return () => {
        consumers.splice(consumers.indexOf(setValue), 1);
      };
    }, [setValue]);
    return [value, setValueAll, isPersistent, error];
  };
}

// libs/use-chrome-storage/mod.ts
function createChromeStorageStateHookSync(key, initialValue) {
  return createChromeStorageStateHook(key, initialValue, "sync");
}

// hooks/use_user_config.ts
var SETTINGS_KEY = "userConfig";
var INITIAL_VALUE = {};
var rawUseUserConfig = createChromeStorageStateHookSync(
  SETTINGS_KEY,
  INITIAL_VALUE
);
function useUserConfig() {
  const [value, setValue, isPersistent, error] = rawUseUserConfig();
  const formatSetValue = function(newValue) {
    const toStore = typeof newValue === "function" ? newValue(value) : newValue;
    if (toStore) {
      toStore.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
    }
    setValue(toStore);
  };
  return [value, formatSetValue, isPersistent, error, setValue];
}

// userscript/popup_app.tsx
function PopupApp(props) {
  const { onClose } = props;
  const [pageStatus2, setPageStatus] = P2("Original");
  const [settings, setSettings, _isPersistent, _error] = useUserConfig();
  const [config, setConfig] = P2(null);
  const [currentUrl, setCurrentUrl] = P2(
    globalThis.location.href
  );
  const [currentLang, setCurrentLang] = P2("auto");
  const [ctx, setContext] = P2(null);
  const onToggleTranslate = (event) => {
    setPageStatus(event.detail);
  };
  const onSetPageLanguage = (lang) => {
    setCurrentLang(lang);
    const newSourceLanguageUrlPattern = handleSourceLanguageUrlPattern(
      currentUrl,
      lang,
      config.sourceLanguageUrlPattern
    );
    setSettings((state) => {
      return {
        ...state,
        sourceLanguageUrlPattern: newSourceLanguageUrlPattern
      };
    });
    setCurrentPageLanguageByClient(lang);
  };
  const onUrlChange = () => {
    setCurrentUrl(globalThis.location.href);
  };
  j2(() => {
    document.addEventListener(
      pageTranslatedStatusEventName,
      onToggleTranslate,
      false
    );
    getConfig2().then((result) => {
      setConfig(result);
      const currentLanguage = getCurrentPageLanguage();
      setCurrentLang(currentLanguage);
      const currentPageStatus = getPageStatus();
      setPageStatus(currentPageStatus);
      runCron(result.interval);
    });
    document.addEventListener("urlChange", onUrlChange);
    return () => {
      document.removeEventListener("pageTranslatedStatus", onToggleTranslate);
      document.removeEventListener("urlChange", onUrlChange);
    };
  }, []);
  j2(() => {
    getConfig2().then((config2) => {
      setConfig(config2);
    });
  }, [settings]);
  j2(() => {
    if (currentUrl && config) {
      getContext({
        url: currentUrl,
        config
      }).then((ctx2) => {
        setContext(ctx2);
      });
    }
  }, [currentUrl, config]);
  const handleSendMessageToContent = (method, isClose) => {
    return () => {
      sendMessageToContent({
        method
      });
      if (isClose) {
        onClose();
      }
    };
  };
  const handleClose = () => {
    onClose();
  };
  const handleTranslatePdf = () => {
    globalThis.alert("Not implemented yet");
    onClose();
  };
  const handleTranslateLocalPdfFile = () => {
    globalThis.alert("Not implemented yet");
    onClose();
  };
  const handleOpenOptionsPage = () => {
    openOptionsPage(true);
    setTimeout(() => {
      onClose();
    }, 50);
  };
  const handleOpenAboutPage = () => {
    openAboutPage();
    setTimeout(() => {
      onClose();
    }, 50);
  };
  if (!config || !ctx) {
    return null;
  }
  return /* @__PURE__ */ p5(
    Popup,
    {
      request: request2,
      onClose: handleClose,
      onTranslateTheWholePage: handleSendMessageToContent(
        "translateTheWholePage",
        true
      ),
      openOptionsPage: handleOpenOptionsPage,
      onToggleTranslate: handleSendMessageToContent(
        "toggleTranslatePage",
        true
      ),
      onTranslateTheMainPage: handleSendMessageToContent(
        "translateTheMainPage",
        true
      ),
      ontranslateToThePageEndImmediately: handleSendMessageToContent(
        "translateToThePageEndImmediately",
        true
      ),
      onTranslatePage: handleSendMessageToContent("translatePage", true),
      onRestorePage: handleSendMessageToContent("restorePage", false),
      onTranslatePdf: handleTranslatePdf,
      openAboutPage: handleOpenAboutPage,
      onTranslateLocalPdfFile: handleTranslateLocalPdfFile,
      onSetPageLanguage,
      onUserConfigChange: setSettings,
      config,
      pageStatus: pageStatus2,
      ctx,
      currentUrl,
      currentLang,
      onSetLocalConfig: setLocalConfig2,
      onSetBuildinConfig: setBuildinConfig2
    }
  );
}

// userscript/popup_entry.tsx
function addCSSLegacy(root2, csses) {
  for (const css of csses) {
    root2.appendChild(document.createElement("style")).innerHTML = css;
  }
}
var currentPagePopupConfig = {
  position: "right",
  right: 0,
  top: 335
};
var positionChanged = false;
var rootRef = null;
var btnRef = null;
var mountPointRef = null;
var shadowRef = null;
var timer = null;
var localConfig = null;
var delta = 6;
var startX;
var startY;
var lastBtnStyle = null;
var lastRootStyle = null;
async function initPopup() {
  const env4 = getEnv();
  localConfig = await getLocalConfig2();
  currentPagePopupConfig = localConfig.pagePopupConfig || currentPagePopupConfig;
  const popup = document.createElement("div");
  popup.id = "immersive-translate-popup";
  popup.setAttribute("style", "all: initial");
  document.documentElement.appendChild(popup);
  const shadow = popup.attachShadow({ mode: "open" });
  shadowRef = shadow;
  const csses = [
    env4.IMMERSIVE_TRANSLATE_PICO_CSS,
    env4.IMMERSIVE_TRANSLATE_COMMON_CSS,
    env4.IMMERSIVE_TRANSLATE_POPUP_CSS
  ];
  addCSSLegacy(shadow, csses);
  const mountRoot = document.createElement("div");
  mountRoot.innerHTML = env4.IMMERSIVE_TRANSLATE_POPUP_HTML;
  shadow.appendChild(mountRoot);
  const popupRoot = shadow.querySelector(
    "#immersive-translate-popup-container"
  );
  rootRef = popupRoot;
  const btn = shadow.querySelector(
    "#immersive-translate-popup-btn"
  );
  btnRef = btn;
  const mountPoint = shadow.querySelector("#mount");
  mountPointRef = mountPoint;
  rootRef.setAttribute(
    "style",
    objToStyle(currentPagePopupConfig)
  );
  setBtnTransform();
  btn.addEventListener("mousedown", onMouseDown);
  btn.addEventListener("touchstart", onTouchStart);
  globalThis.addEventListener("resize", (_e3) => {
    rootRef.setAttribute(
      "style",
      objToStyle(currentPagePopupConfig)
    );
  });
}
function showButton() {
  re(null, mountPointRef);
  mountPointRef.style.display = "none";
  btnRef.style.display = "block";
  timer = setTimeout(() => {
    setBtnTransform(true);
  }, 2e3);
}
function renderPopup(shadow) {
  const mountPoint = shadow.querySelector("#mount");
  const handleOnClose = () => {
    showButton();
  };
  const handleClickOverLay = (e3) => {
    if (e3 && e3.target && e3.target.id === "immersive-translate-popup-overlay") {
      handleOnClose();
    }
  };
  (async () => {
    const config = await getConfig2();
    re(
      /* @__PURE__ */ p5(
        TranslateProvider,
        {
          lang: config.interfaceLanguage,
          fallbackLang: "zh-CN",
          translations: locales_default,
          children: /* @__PURE__ */ p5(
            "div",
            {
              onClick: handleClickOverLay,
              id: "immersive-translate-popup-overlay",
              class: "immersive-translate-popup-overlay",
              children: /* @__PURE__ */ p5(
                "div",
                {
                  class: "immersive-translate-popup-wrapper",
                  style: calculateMountPointPosition(),
                  children: /* @__PURE__ */ p5(PopupApp, { onClose: handleOnClose })
                }
              )
            }
          )
        }
      ),
      mountPoint
    );
  })().then(() => {
    btnRef.style.display = "none";
    mountPointRef.style.display = "block";
  });
}
function calculateMountPointPosition() {
  const screenSize = getScreenSize();
  const windowHeight = screenSize.height;
  const { position, top, left } = currentPagePopupConfig;
  const style = {
    position: "fixed"
  };
  const popupHeight = 300;
  const popupWidth = 300;
  const offset = 100;
  if (position === "right" || position === "left") {
    style.top = top - offset;
    if (style.top + popupHeight >= windowHeight) {
      style.bottom = 30;
      delete style.top;
    } else if (style.top <= 10) {
      style.top = 10;
    }
    if (position === "right") {
      style.right = 0;
    } else if (position === "left") {
      style.left = 0;
    }
  } else if (position === "top" || position === "bottom") {
    style.left = left - offset;
    if (style.left + popupWidth >= screenSize.width) {
      style.right = 0;
      delete style.left;
    } else if (style.left <= 10) {
      style.left = 0;
    }
    if (position === "top") {
      style.top = 0;
    } else if (position === "bottom") {
      style.bottom = 0;
    }
  }
  return style;
}
function getScreenSize() {
  return {
    width: Math.max(
      document.documentElement.clientWidth,
      window.innerWidth || 0
    ),
    height: Math.max(
      document.documentElement.clientHeight,
      window.innerHeight || 0
    )
  };
}
function onMouseDown(e3) {
  lastRootStyle = rootRef.getAttribute("style");
  startX = e3.pageX;
  startY = e3.pageY;
  if (timer) {
    clearTimeout(timer);
  }
  positionChanged = false;
  btnRef.style.opacity = "1";
  btnRef.style.transform = "none";
  lastBtnStyle = btnRef.getAttribute("style");
  globalThis.addEventListener("mousemove", onMouseMove);
  globalThis.addEventListener("mouseup", onMouseUp);
  globalThis.addEventListener("touchmove", onTouchMove);
  globalThis.addEventListener("touchend", onTouchEnd);
  globalThis.addEventListener("touchcancel", onTouchEnd);
}
function onTouchStart(e3) {
  e3.preventDefault && e3.preventDefault();
  onMouseDown(e3.changedTouches[0]);
}
function onTouchMove(e3) {
  onMouseMove(e3.changedTouches[0]);
}
function onTouchEnd(e3) {
  e3.preventDefault && e3.preventDefault();
  onMouseUp(e3.changedTouches[0]);
}
function onMouseMove(e3) {
  e3.preventDefault && e3.preventDefault();
  positionChanged = true;
  rootRef.setAttribute(
    "style",
    `left:${e3.clientX}px;top:${e3.clientY}px;transform:scale(1.6);`
  );
}
function onMouseUp(e3) {
  e3.preventDefault && e3.preventDefault();
  removeListeners();
  if (timer) {
    clearTimeout(timer);
  }
  startX = startX || 0;
  startY = startY || 0;
  const diffX = Math.abs(e3.pageX - startX);
  const diffY = Math.abs(e3.pageY - startY);
  if (diffX < delta && diffY < delta) {
    rootRef.setAttribute("style", lastRootStyle);
    btnRef.setAttribute("style", lastBtnStyle);
    renderPopup(shadowRef);
  } else {
    if (positionChanged) {
      snapToSide(e3);
    } else {
      renderPopup(shadowRef);
    }
  }
  positionChanged = false;
}
function snapToSide(e3) {
  const screenSize = getScreenSize();
  const left = e3.clientX;
  const top = e3.clientY;
  const toTop = top;
  const toBottom = screenSize.height - top;
  const toLeft = left;
  const toRight = screenSize.width - left;
  if (toTop < toBottom && toTop < toLeft && toTop < toRight) {
    currentPagePopupConfig = {
      position: "top",
      left,
      top: 0
    };
  } else if (toBottom < toTop && toBottom < toLeft && toBottom < toRight) {
    currentPagePopupConfig = {
      position: "bottom",
      bottom: 0,
      left: e3.clientX
    };
  } else if (toLeft < toTop && toLeft < toBottom && toLeft < toRight) {
    currentPagePopupConfig = {
      position: "left",
      left: 0,
      top: e3.clientY
    };
  } else if (toRight < toTop && toRight < toBottom && toRight < toLeft) {
    currentPagePopupConfig = {
      position: "right",
      right: 0,
      top: e3.clientY
    };
  }
  const finalStyle = objToStyle(currentPagePopupConfig);
  rootRef.setAttribute(
    "style",
    finalStyle
  );
  setLocalConfig2({
    ...localConfig,
    pagePopupConfig: currentPagePopupConfig
  });
  timer = setTimeout(() => {
    setBtnTransform(true);
  }, 2e3);
}
function setBtnTransform(transition = false) {
  btnRef.style.opacity = "0.4";
  let transform = "";
  if (currentPagePopupConfig.position === "left") {
    transform = "translateX(-40%)";
  } else if (currentPagePopupConfig.position === "right") {
    transform = "translateX(40%)";
  } else if (currentPagePopupConfig.position === "top") {
    transform = "translateY(-40%)";
  } else if (currentPagePopupConfig.position === "bottom") {
    transform = "translateY(40%)";
  }
  btnRef.style.transform = transform;
  if (transition) {
    btnRef.style.transition = `transform 0.2s ease-in-out, opacity 0.2s ease-in-out`;
  }
}
function removeListeners() {
  globalThis.removeEventListener("mousemove", onMouseMove);
  globalThis.removeEventListener("mouseup", onMouseUp);
  globalThis.removeEventListener("touchmove", onTouchMove);
  globalThis.removeEventListener("touchend", onTouchEnd);
  globalThis.removeEventListener("touchcancel", onTouchEnd);
}
function objToStyle(rawObj) {
  const obj = getValidStyleObj(rawObj);
  return Object.keys(obj).map((key) => {
    if (typeof obj[key] === "number") {
      return `${key}:${obj[key]}px;`;
    } else {
      return "";
    }
  }).join("");
}
function getValidStyleObj(positionConfig) {
  const { position, ...rest } = positionConfig;
  const screenSize = getScreenSize();
  const styleObj = {};
  if (position === "left") {
    styleObj.left = 0;
    if (rest.top > screenSize.height) {
      styleObj.top = screenSize.height - 100;
    } else {
      styleObj.top = rest.top;
    }
  } else if (position === "right") {
    styleObj.right = 0;
    if (rest.top > screenSize.height) {
      styleObj.top = screenSize.height - 100;
    } else {
      styleObj.top = rest.top;
    }
  } else if (position === "top") {
    styleObj.top = 0;
    if (rest.left > screenSize.width) {
      styleObj.left = screenSize.width - 100;
    } else {
      styleObj.left = rest.left;
    }
  } else if (position === "bottom") {
    styleObj.bottom = 0;
    if (rest.left > screenSize.width) {
      styleObj.left = screenSize.width - 100;
    } else {
      styleObj.left = rest.left;
    }
  }
  return styleObj;
}

// page_popup.tsx
var isInit = false;
async function main() {
  const config = await getConfig2();
  const options2 = {
    url: globalThis.location.href,
    config
  };
  const ctx = await getContext(options2);
  if (config.debug) {
    log_default.setLevel("debug");
  }
  globalThis.document.addEventListener(
    userscriptCommandEventName,
    // @ts-ignore: hard to type
    (_e3) => {
      if (!isInit) {
        isInit = true;
        initPopup().catch((e3) => {
          log_default.error("init popup error", e3);
        });
      }
    }
  );
  if (ctx.isTranslateExcludeUrl) {
    log_default.debug("detect exclude url, do not inject anything.");
  } else {
    if ((isMobile().any || isMonkey()) && ctx.rule.isShowUserscriptPagePopup) {
      if (!isInit) {
        isInit = true;
        initPopup().catch((e3) => {
          log_default.error("init popup error", e3);
        });
      }
    }
  }
}

// userscript/inject_css.ts
var addCSS = (css) => document.head.appendChild(document.createElement("style")).innerHTML = css;
function injectCss() {
  const env4 = getEnv();
  const injectedCss = env4.IMMERSIVE_TRANSLATE_INJECTED_CSS;
  if (injectedCss) {
    addCSS(injectedCss);
  }
}
function injectCssWithSpecialCssString(css) {
  if (css) {
    addCSS(css);
  }
}

// manifest.json
var manifest_default = {
  manifest_version: 3,
  name: "__MSG_brandName__",
  description: "__MSG_brandDescription__",
  version: "0.2.56",
  default_locale: "en",
  background: {
    service_worker: "background.js"
  },
  web_accessible_resources: ["styles/inject.css", "pdf/index.html"],
  content_scripts: [
    {
      matches: [
        "<all_urls>",
        "file:///*",
        "*://*/*"
      ],
      js: [
        "content_script.js"
      ],
      run_at: "document_end",
      all_frames: true
    }
  ],
  commands: {
    toggleTranslatePage: {
      suggested_key: {
        default: "Alt+A"
      },
      description: "__MSG_toggleTranslatePage__"
    },
    toggleTranslateTheWholePage: {
      suggested_key: {
        default: "Alt+W"
      },
      description: "__MSG_toggleTranslateTheWholePage__"
    },
    toggleTranslateToThePageEndImmediately: {
      description: "__MSG_toggleTranslateToThePageEndImmediately__"
    },
    toggleTranslateTheMainPage: {
      description: "__MSG_toggleTranslateTheMainPage__"
    },
    toggleTranslationMask: {
      description: "__MSG_toggleTranslationMask__"
    }
  },
  options_page: "options.html",
  options_ui: {
    page: "options.html",
    open_in_tab: true,
    browser_style: false
  },
  permissions: [
    "storage",
    "activeTab",
    "contextMenus",
    "webRequest",
    "webRequestBlocking",
    "declarativeNetRequestWithHostAccess",
    "declarativeNetRequestFeedback",
    "declarativeNetRequest"
  ],
  host_permissions: [
    "<all_urls>"
  ],
  declarative_net_request: {
    rule_resources: [{
      id: "ruleset_1",
      enabled: true,
      path: "rules/request_modifier_rule.json"
    }]
  },
  action: {
    default_popup: "popup.html",
    default_icon: {
      "32": "icons/32.png",
      "48": "icons/48.png",
      "64": "icons/64.png",
      "128": "icons/128.png",
      "256": "icons/256.png"
    }
  },
  browser_action: {
    default_icon: "icons/32.png",
    default_popup: "popup.html"
  },
  icons: {
    "32": "icons/32.png",
    "48": "icons/48.png",
    "64": "icons/64.png",
    "128": "icons/128.png",
    "256": "icons/256.png"
  },
  browser_specific_settings: {
    gecko: {
      id: "{5efceaa7-f3a2-4e59-a54b-85319448e305}",
      strict_min_version: "63.0"
    }
  },
  key: "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA7JPn78UfqI3xIIOPPLPS74UTzLfJL1gQM8hlk/deKWvFP/WqUBnPJPdhQeF45sFpI1OjO70nFqdATT4/RwYAiZK7G/E6m27MDVnhHjszfzReOuoAEn9J3RnE2xEx5pFhRFcelhnwTTLrrn90aaPcaMtNsgXtZA1Ggz/SnX9I4ZygqpJYjx3Ql2t6SyNK222oRQiKMT93Rrjgyc8RFA7FKXsWglG0TvseRjbmG5Jk5gDx+2/YTcWGqCDotQnWnkPj/dBO23UAX7IpyJK3FGYdkvWFih6OVClHIIWY8mfCjjwSGbXNQNesaa9F2hrzBZ5MRTj4m7yj76mGxuPHPIE8mwIDAQAB"
};

// dom/main.ts
async function main2() {
  const config = await getConfig2();
  const ctx = await getContext({
    config,
    url: getRealUrl()
  });
  injectCss();
  if (ctx.isTranslateExcludeUrl && isWebOptionsPage()) {
    log_default.debug("detect web options page");
    setupWebOptionsPage();
  } else {
    setupDomListeners(ctx);
    const isUserscript = isMonkey();
    if (!isUserscript) {
      setupMessageListeners();
    } else {
      setupCommandListeners(config);
      registerCommands(config);
    }
    let injectedCss = "";
    if (ctx.rule.injectedCss || ctx.rule.additionalInjectedCss) {
      if (ctx.rule.injectedCss && ctx.rule.injectedCss.length > 0) {
        injectedCss += ctx.rule.injectedCss.join("\n");
      }
      if (ctx.rule.additionalInjectedCss && ctx.rule.additionalInjectedCss.length > 0) {
        injectedCss += "\n" + ctx.rule.additionalInjectedCss.join("\n");
      }
    }
    log_default.v("injectedCss", injectedCss);
    if (injectedCss) {
      injectCssWithSpecialCssString(injectedCss);
    }
    const isDebug = config.debug;
    if (isDebug) {
      log_default.setLevel("debug");
    } else {
      log_default.setLevel("info");
    }
    if (globalThis.top != globalThis.self) {
    } else {
      await main().catch((e3) => {
        log_default.error(`init popup page error: ${e3}`);
      });
    }
    if (!ctx.isTranslateExcludeUrl) {
      if (ctx.rule.isPdf) {
        let isFirstTextRendered = false;
        if (globalThis.PDFViewerApplication) {
          globalThis.PDFViewerApplication.initializedPromise.then(() => {
            const pdfViewer = globalThis.PDFViewerApplication;
            pdfViewer.eventBus.on("pagesdestroy", () => {
              restorePage();
            });
            pdfViewer.eventBus.on("textlayerrendered", async () => {
              if (!isFirstTextRendered) {
                isFirstTextRendered = true;
                await initPage();
              }
            });
            pdfViewer.eventBus.on("fileinputchange", () => {
              isFirstTextRendered = false;
            });
          });
        }
      } else {
        await initPage();
      }
      checkCronAndRunOnce();
    }
  }
}
var debounceOpenOptionsPage = le(async () => {
  await openOptionsPage();
}, 50);
var debounceOpenAboutPage = le(async () => {
  await openAboutPage();
}, 50);
var debounceToggleTranslatePage = le((id) => {
  sendMessageToContent2({
    method: id
  });
}, 50);
function registerCommands(config) {
  if (isMonkey() && typeof GM !== "undefined" && GM && GM.registerMenuCommand) {
    const commandsMap = manifest_default.commands;
    const commandKeys = Object.keys(commandsMap);
    const commands = commandKeys.filter((item) => {
      return item === "toggleTranslatePage";
    }).map((command) => {
      const titlePlaceholder = commandsMap[command].description;
      let title = titlePlaceholder;
      if (titlePlaceholder.startsWith("__MSG_") && titlePlaceholder.endsWith("__")) {
        title = t3(
          `browser.${titlePlaceholder.slice(6, -2)}`,
          config.interfaceLanguage
        );
      }
      return {
        id: command,
        title
      };
    });
    const menus = [
      ...commands,
      {
        id: contextOpenOptionsMenuId,
        title: t3("browser.openOptionsPage", config.interfaceLanguage),
        key: "o"
      },
      {
        id: contextOpenAboutMenuId,
        title: t3("browser.openAboutPage", config.interfaceLanguage),
        key: "o"
      }
    ];
    for (const menu of menus) {
      GM.registerMenuCommand(
        menu.title,
        () => {
          if (menu.id === contextOpenOptionsMenuId) {
            debounceOpenOptionsPage();
          } else if (menu.id === contextOpenAboutMenuId) {
            debounceOpenAboutPage();
          } else {
            debounceToggleTranslatePage(menu.id);
          }
        },
        menu.key
      );
    }
  }
}
function sendMessageToContent2(request3) {
  asyncMessageHandler(request3, {
    // @ts-ignore: it's ok
    tab: {
      id: 1,
      url: "https://www.fake.com",
      active: true
    }
  }).catch((e3) => {
    log_default.error("send content message request failed", request3, e3);
  });
  const event = new CustomEvent(userscriptCommandEventName, {
    detail: request3
  });
  globalThis.document.dispatchEvent(event);
}

// dom/ready_state.js
var options = {
  capture: true,
  once: true,
  passive: true
};
var isReady = () => document.readyState === "interactive" || document.readyState === "complete";
var isCurrentState = (state) => document.readyState === state;
var resolveState = (state, fn) => {
  if (isCurrentState(state) || isReady()) {
    fn(state);
    return true;
  }
  return false;
};
var loading = () => new Promise((resolve) => {
  if (resolveState("loading", resolve))
    return;
  document.addEventListener(
    "readystatechange",
    () => {
      document.readyState === "loading" && resolve("loading");
    },
    options
  );
});
var interactive = () => new Promise((resolve) => {
  if (resolveState("interactive", resolve))
    return;
  document.addEventListener(
    "readystatechange",
    () => {
      document.readyState === "interactive" && resolve("interactive");
    },
    options
  );
});
var complete = () => new Promise((resolve) => {
  if (resolveState("complete", resolve))
    return;
  document.addEventListener(
    "readystatechange",
    () => {
      document.readyState === "complete" && resolve("complete");
    },
    options
  );
});
var domready = () => new Promise((resolve) => {
  if (resolveState("domready", resolve))
    return;
  document.addEventListener(
    "DOMContentLoaded",
    () => {
      resolve("domready");
    },
    options
  );
});
var load = () => new Promise((resolve) => {
  if (resolveState("load", resolve))
    return;
  window.addEventListener(
    "load",
    () => {
      resolve("load");
    },
    options
  );
});
var readyState = {};
Object.defineProperties(readyState, {
  state: {
    get: function() {
      return document.readyState;
    }
  },
  loading: {
    get: function() {
      return loading();
    }
  },
  interactive: {
    get: function() {
      return interactive();
    }
  },
  complete: {
    get: function() {
      return complete();
    }
  },
  window: {
    get: function() {
      return load();
    }
  },
  load: {
    get: function() {
      return load();
    }
  },
  domready: {
    get: function() {
      return domready();
    }
  },
  dom: {
    get: function() {
      return domready();
    }
  },
  ready: {
    get: function() {
      return isReady();
    }
  }
});
var ready_state_default = readyState;

// utils/wait_for.ts
var ERRORS = {
  NOT_FUNCTION: "Your executor is not a function. functions and promises are valid.",
  FAILED_TO_WAIT: "Failed to wait"
};
function promisify(fn) {
  return async () => {
    const result = await fn();
    return result;
  };
}
function validateExecution(executeFn) {
  if (typeof executeFn !== "function") {
    throw new Error(ERRORS.NOT_FUNCTION);
  }
}
var PollUntil = class {
  constructor({
    interval = 100,
    timeout = 1e3,
    stopOnFailure = false,
    verbose = false,
    backoffFactor = 1,
    backoffMaxInterval,
    message = ""
  } = {}) {
    this._interval = interval;
    this._timeout = timeout;
    this._stopOnFailure = stopOnFailure;
    this._isWaiting = false;
    this._isResolved = false;
    this._verbose = verbose;
    this._userMessage = message;
    this.originalStacktraceError = new Error();
    this._Console = console;
    this._backoffFactor = backoffFactor;
    this._backoffMaxInterval = backoffMaxInterval || timeout;
    this.start = +Date.now();
  }
  tryEvery(interval) {
    this._interval = interval;
    return this;
  }
  stopAfter(timeout) {
    this._timeout = timeout;
    return this;
  }
  execute(executeFn) {
    this._applyPromiseHandlers();
    validateExecution(executeFn);
    this._executeFn = promisify(executeFn);
    this.start = Date.now();
    this._isWaiting = true;
    this._log("starting to execute");
    this._runFunction();
    return this.promise;
  }
  getPromise() {
    return this.promise;
  }
  isResolved() {
    return this._isResolved;
  }
  isWaiting() {
    return this._isWaiting;
  }
  stopOnFailure(stop) {
    this._stopOnFailure = stop;
    return this;
  }
  _applyPromiseHandlers() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
  _timeFromStart() {
    return Date.now() - this.start;
  }
  _shouldStopTrying() {
    return this._timeFromStart() > this._timeout;
  }
  _executeAgain() {
    this._log("executing again");
    const currentInterval = this._interval;
    const nextInterval = currentInterval * this._backoffFactor;
    this._interval = nextInterval > this._backoffMaxInterval ? this._backoffMaxInterval : nextInterval;
    setTimeout(this._runFunction.bind(this), currentInterval);
  }
  _failedToWait() {
    let waitErrorText = `${ERRORS.FAILED_TO_WAIT} after ${this._timeFromStart()}ms`;
    if (this._userMessage) {
      waitErrorText = `${waitErrorText}: ${this._userMessage}`;
    }
    if (this._lastError) {
      this._lastError.message = `${waitErrorText}
${this._lastError.message}`;
      const originalStack = this.originalStacktraceError.stack;
      if (originalStack) {
        this._lastError.stack += originalStack.substring(
          originalStack.indexOf("\n") + 1
        );
      }
    } else {
      this._lastError = this.originalStacktraceError;
      this._lastError.message = waitErrorText;
    }
    this._log(this._lastError);
    return this._lastError;
  }
  _runFunction() {
    if (this._shouldStopTrying()) {
      this._isWaiting = false;
      this.reject?.(this._failedToWait());
      return;
    }
    this._executeFn().then((result) => {
      if (result === false) {
        this._log(`then execute again with result: ${result}`);
        this._executeAgain();
        return;
      }
      this.resolve?.(result);
      this._isWaiting = false;
      this._isResolved = true;
      this._log(`then done waiting with result: ${result}`);
    }).catch((err) => {
      if (this._stopOnFailure) {
        this._log(`stopped on failure with err: ${err}`);
        return this.reject?.(err);
      }
      this._lastError = err;
      this._log(`catch with err: ${err}`);
      return this._executeAgain();
    });
  }
  _log(message) {
    if (this._verbose && this._Console && this._Console.log) {
      this._Console.log(message);
    }
  }
};
var waitFor = (waitForFunction, options2) => new PollUntil(options2).execute(waitForFunction);

// dom/wait_for_dom.ts
async function waitForDomElementReady() {
  try {
    await waitFor(() => {
      const mainText = getMainText(document.body);
      if (mainText && mainText.length >= 10) {
        return true;
      } else {
        throw new Error("there is no main text");
      }
    }, { timeout: 1e4 });
    return true;
  } catch (e3) {
    throw e3;
  }
}

// content_main.ts
ready_state_default.domready.then(() => {
  waitForDomElementReady().then(() => {
    main2().catch((e3) => {
      if (e3) {
        log_default.error(
          "translate page error",
          e3.name,
          e3.message,
          e3.details || "",
          e3
        );
      }
    });
  }).catch((e3) => {
    log_default.debug(`can not detect a valid body: `, e3);
  });
}).catch((e3) => {
  if (e3) {
    log_default.error(
      "translate dom ready detect error",
      e3
    );
  }
});
//# sourceMappingURL=content_script.js.map
